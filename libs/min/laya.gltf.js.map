{"version":3,"names":["glTFShader","static","this","Define_BaseColorMap","Shader3D","getDefineByName","Define_BaseColorMapTransform","Define_MetallicRoughnessMap","Define_MetallicRoughnessMapTransform","Define_NormalMap","Define_NormalMapTransform","Define_OcclusionMap","Define_OcclusionMapTransform","Define_EmissionMap","Define_EmissionMapTransform","Define_ClearCoatMap","Define_ClearCoatMapTransform","Define_ClearCoatRoughnessMap","Define_ClearCoatRoughnessMapTransform","Define_ClearCoatNormalMapTransform","Define_AnisotropyMap","Define_AnisotropyMapTransform","Define_IridescenceMap","Define_IridescenceMapTransform","Define_IridescenceThicknessMap","Define_IridescenceThicknessMapTransform","Define_SheenColorMap","Define_SheenColorMapTransform","Define_SheenRoughnessMap","Define_SheenRoughnessMapTransform","Define_TransmissionMap","Define_TransmissionMapTransform","Define_VolumeThicknessMap","Define_VolumeThicknessMapTransform","Define_SpecularFactorMap","Define_SpecularFactorMapTransform","Define_SpecularColorMap","Define_SpecularColorMapTransform","shader","find","name","addInclude","uniformMap","u_AlphaTestValue","ShaderDataType","Float","u_BaseColorFactor","Vector4","u_BaseColorTexture","Texture2D","u_BaseColorMapTransform","Matrix3x3","u_Specular","u_MetallicFactor","u_RoughnessFactor","u_MetallicRoughnessTexture","u_MetallicRoughnessMapTransform","u_NormalTexture","u_NormalMapTransform","u_NormalScale","u_OcclusionTexture","u_OcclusionMapTransform","u_OcclusionStrength","u_EmissionFactor","Vector3","u_EmissionTexture","u_EmissionMapTransform","u_EmissionStrength","u_ClearCoatFactor","u_ClearCoatTexture","u_ClearCoatMapTransform","u_ClearCoatRoughness","u_ClearCoatRoughnessTexture","u_ClearCoatRoughnessMapTransform","u_ClearCoatNormalTexture","u_ClearCoatNormalMapTransform","u_ClearCoatNormalScale","u_AnisotropyStrength","u_AnisotropyRotation","u_AnisotropyTexture","u_AnisotropyMapTransform","u_Ior","u_IridescenceFactor","u_IridescenceTexture","u_IridescenceMapTransform","u_IridescenceIor","u_IridescenceThicknessMinimum","u_IridescenceThicknessMaximum","u_IridescenceThicknessTexture","u_IridescenceThicknessMapTransform","u_SheenColorFactor","u_SheenColorTexture","u_SheenColorMapTransform","u_SheenRoughness","u_SheenRoughnessTexture","u_SheenRoughnessMapTransform","u_TransmissionFactor","u_TransmissionTexture","u_TransmissionMapTransform","u_VolumeThicknessFactor","u_VolumeThicknessTexture","u_VoluemThicknessMapTransform","u_VolumeAttenuationDistance","u_VolumeAttenuationColor","u_SpecularFactor","u_SpecularFactorTexture","u_SpecularFactorMapTransfrom","u_SpecularColorFactor","u_SpecularColorTexture","u_SpecularColorMapTransform","defaultValue","ONE","DEFAULT","ZERO","add","subShader","SubShader","DefaultAttributeMap","addSubShader","addShaderPass","ShaderName","glTFResource","Prefab","constructor","super","_buffers","_textures","_materials","_meshes","_extensions","Map","_pendingOps","_scenes","_nodes","factory","_Extensions","data","_data","loadBinary","basePath","progress","buffers","promises","forEach","buffer","i","Base64Tool","isBase64String","uri","bin","decode","replace","reghead","j","push","ILaya","loader","fetch","URL","join","createCallback","then","Promise","all","resolve","loadTextureFromInfo","info","sRGB","index","tex","textures","imgSource","source","glTFImg","images","samplerSource","sampler","glTFSampler","samplers","undefined","constructParams","getTextureConstructParams","propertyParams","getTexturePropertyParams","bufferView","bufferViews","byteOffset","byteLength","arraybuffer","slice","loadTextureFromBuffer","mimeType","res","addDep","loadTexture","loadTextures","materials","glTFMaterial","pbrMetallicRoughness","baseColorTexture","promise","metallicRoughnessTexture","normalTexture","occlusionTexture","emissiveTexture","extension","loadAdditionTextures","importMaterials","glTFMat","mat","createMaterial","importMeshes","meshes","nodes","glTFNode","mesh","glTFMesh","glTFSkin","_a","skins","skin","key","createMesh","_parse","createURL","asset","version","Error","getPath","_idCounter","extensionsUsed","value","extensionFactory","set","console","warn","_b","extensionsRequired","length","_parseglb","byte","Byte","readUint32","firstChunkLength","firstChunkData","readArrayBuffer","jsonStr","TextDecoder","glTFObj","JSON","parse","chunkLength","firstBuffer","Math","min","_c","create","loadNodes","buildHierarchy","loadScenes","scenes","loadAnimations","animations","defaultSceneIndex","scene","defaultScene","url","encode","load","Loader","TEXTURE2D","generateId","context","toString","getAccessorComponentsNum","type","getAttributeNum","attriStr","_getTypedArrayConstructor","componentType","Int8Array","Uint8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","_getAccessorDateByteStride","getBufferFormBufferView","accessorType","count","componentCount","byteStride","vertexStride","dataByteStride","dataStride","elementOffset","dataReader","resIndex","componentOffset","getBufferwithAccessorIndex","accessorIndex","accessor","accessors","accessorDataCount","fill","sparse","sparseCount","sparseIndices","indices","sparseIndicesBufferView","sparseIndicesData","sparseValues","values","sparseValuesBufferView","sparseValuesData","componentIndex","getTextureMipmap","minFilter","getTextureFormat","glTFImage","getTextureFilterMode","magFilter","getTextureWrapMode","mode","WrapMode","Repeat","Clamp","Mirrored","filterMode","wrapModeU","wrapS","wrapModeV","wrapT","anisoLevel","hdrEncodeFormat","HDREncodeFormat","NONE","getTextureWithInfo","glTFTextureInfo","texCoord","getExtensionTextureInfo","extensionName","get","extensions","loadExtensionTextureInfo","applyMaterialRenderState","material","alphaMode","materialRenderMode","MaterialRenderMode","RENDERMODE_OPAQUE","RENDERMODE_TRANSPARENT","RENDERMODE_CUTOUT","alphaTestValue","alphaCutoff","doubleSided","cull","RenderState","CULL_NONE","setMaterialTextureProperty","texInfo","define","transformName","transformDefine","setTexture","setDefine","transformInfo","setMatrix3x3","transform","applyDefaultMaterialProperties","baseColorFactor","getVector4","fromArray","setVector4","metallicFactor","setFloat","roughnessFactor","normalScale","scale","strength","_d","emissiveFactor","emissionFactor","getVector3","setVector3","PBRShaderLib","DEFINE_EMISSION","createDefaultMaterial","Material","setShaderName","propertiesExts","additionMaterialProperties","pickMeshMaterials","primitives","primitive","PBRStandardMaterial","indexOf","glTFScenes","glTFScene","_loadScene","_createSceneNode","glTFSceneNode","Sprite3D","nodeIndex","sprite","addChild","applyTransform","matrix","localMatrix","elements","localPosition","localRotation","localScale","translation","rotation","glTFNodes","children","childIndex","child","SkinnedMeshSprite3D","fixSkinnedSprite","loadNode","createSprite3D","createSkinnedMeshSprite3D","createMeshSprite3D","storeId","_extra","MeshSprite3D","meshRenderer","sharedMaterials","receiveShadow","castShadow","weights","render","weight","target","morphTargetData","getMorphChannelbyIndex","setMorphChannelWeight","skinnedMeshRenderer","getArrributeBuffer","attributeAccessorIndex","layaDeclarStr","attributeMap","vertexDeclarArr","attributeBuffer","getIndexBuffer","vertexCount","indexBuffer","reverse","calculateFlatNormal","positions","indexArray","normal","i0","i1","i2","p0x","p0y","p0z","x1","y1","z1","x2","y2","z2","yz","xz","xy","invPyth","sqrt","nx","ny","nz","parseMeshwithSubMeshData","subDatas","layaMesh","vertexDecler","indexCount","subData","vertexDeclaration","VertexMesh","getVertexDeclaration","vertexFloatStride","vertexArray","ibFormat","IndexFormat","UInt32","UInt16","fillMeshBuffers","generateMesh","ibPosOffset","ibVertexOffset","vbPosOffset","iAOffset","subIb","fillAttributeBuffer","attriOffset","attriFloatCount","startOffset","ac","position","color","uv","uv1","blendWeight","blendIndices","blendIndicesUint8","tangent","splitSubMeshByBonesCount","morphtargets","boneIndicesList","subIndexStartArray","subIndexCountArray","start","subIndexSet","Set","boneIndexArray","resArray","flagArray","Array","n","triangleSet","boneIndexOffset","k","tempSet","size","curBoneList","from","drawCount","newAttributeMap","array","newTargetMap","targets","newMap","attri","curMaxIndex","d","l","bl","batchFlag","batchMap","area","ci","biStart","cbi","oldBoneIndex","newBoneIndex","attOffset","oldArray","oldMap","oldFloatArray","newLength","newFloatArray","vertexBuffer","Laya3DRender","renderOBJCreate","createVertexBuffer3D","BufferUsage","Static","setData","createIndexBuffer3D","_indexFormat","_indexBuffer","_vertexBuffer","_setBuffer","_vertexCount","_byteLength","reCalculateBounds","Number","MAX_VALUE","max","subMeshOffset","subMeshCount","subMeshes","subMesh","SubMesh","subIndexStart","subIndexCount","_setIndexRange","_boneIndicesList","_subIndexBufferStart","_subIndexBufferCount","subIndex","boundMax","boundMin","x","y","z","_setSubMeshes","calculateBounds","bounds","setMin","setMax","memorySize","_setCPUMemory","_setGPUMemory","applyglTFSkinData","joints","inverseBindMatricesArray","inverseBindMatrices","boneCount","boneNames","_boneNames","node","_inverseBindPoses","_inverseBindPosesBuffer","bindPosesArrayOffset","matElement","Matrix4x4","subCount","skinnedCache","_skinnedMatrixCaches","submesh","getSubMesh","drawIndex","boneIndices","bni","bn","skinnedMatrixCache","applyMorphTarget","hasPosition","hasNormal","hasTangent","morphData","MorphTargetData","decStr","morphVertexDec","toLocaleString","targetVertexFloatStride","vertexDec","getMin","getMax","subVertexOffset","targetName","channel","getMorphChannel","MorphTargetChannel","MorphTarget","addTarget","addMorphChannel","getTargetByIndex","morphMap","vertexIndex","morphPosition","offset","getVertexElementByUsage","MESH_POSITION0","morphNormal","MESH_NORMAL0","morphTangent","MESH_TANGENT0","initData","Mesh","glTFMeshPrimitives","morphWeights","glTFMeshPrimitive","attributes","POSITION","positionAccessor","NORMAL","COLOR_0","TEXCOORD_0","TEXCOORD_1","WEIGHTS_0","JOINTS_0","TANGENT","tangentIndex","morphtargetMap","targetNames","extras","morph","morphX","morphY","morphZ","bi","PrimitiveSubMesh","calSkinnedSpriteLocalBounds","skinned","meshFilter","sharedMesh","oriRootMatrix","rootBone","worldMatrix","invertRootMatrix","invert","getIndices","boneWeights","getPositions","getBoneIndices","getBoneWeights","oriBoneIndeices","_subMeshes","bonelist","listIndex","endIndex","iindex","ii","boneIndex","w","inverseBindPoses","bones","ubones","tempMat","bone","multiply","skinTransform","resPos","pos","boneWeight","ei","transformV3ToV3","localBounds","skeleton","getAnimationRoot","channels","isContainNode","nodeArr","findNodeIndex","spriteIndex","getAnimationPath","root","curSprite","paths","parent","animation","loadAnimation","createAnimator","animatorRoot","animator","getComponent","Animator","addComponent","animatorLayer","AnimatorControllerLayer","addControllerLayer","defaultWeight","clip","createAnimatorClip","getControllerLayer","animationName","getAnimatorState","animatorState","AnimatorState","addState","defaultState","playOnWake","AnimationClip","duration","clipNodes","targetPath","path","timeBuffer","input","outBuffer","output","timeArray","outArray","animaPaths","MeshFilter","ownerStr","SkinnedMeshRenderer","channelCount","channelIndex","channelName","clipNode","interpolation","valueArray","propertyOwner","propertise","propertyLength","callbackFunc","callbackParams","propertyChangePath","_duration","islooping","_frameRate","nodeCount","nodesMap","_nodesMap","nodesDic","_nodesDic","KeyframeNode","glTFClipNode","setNodeByIndex","_indexInList","pathLength","_setOwnerPathCount","tempPath","_setOwnerPathByIndex","nodePath","_joinOwnerPath","mapArray","_setPropertyCount","_setPropertyByIndex","fullPath","_joinProperty","callbackFunData","callParams","keyframeCount","floatKeyFrame","FloatKeyframe","_setKeyframeByIndex","time","inTangent","outTangent","Infinity","lastI","lastTime","lastValue","lastTimeDet","nextI","nextTime","nextValue","nextTimeDet","floatArrayKeyframe","Vector3Keyframe","startTimev3","setValue","lastX","lastY","lastZ","nextX","nextY","nextZ","nestTimeDet","cloneTo","quaternionKeyframe","QuaternionKeyframe","startTimeQu","inTangentQua","outTangentQua","valueQua","lastW","nextW","Laya","onInitModule","init","ExtensionName","Vector2","KHR_texture_transform","resource","_resource","createTransform","createFromTranslation","rot","createFromRotation","trans","registerExtension","KHR_materials_anisotropy","anisotropyTexture","anisotropy","anisotropyStrength","anisotropyRotation","DEFINE_ANISOTROPY","KHR_materials_clearcoat","clearcoatTexture","clearcoatRoughnessTexture","clearcoatNormalTexture","clearCoat","clearcoatFactor","clearCoatRoughness","clearcoatRoughnessFactor","DEFINE_CLEARCOAT","DEFINE_CLEARCOAT_NORMAL","KHR_materials_emissive_strength","emissionStrength","emissiveStrength","KHR_materials_ior","ior","DEFINE_IOR","KHR_materials_iridescence","iridescenceTexture","iridescenceThicknessTexture","factor","iridescenceFactor","iridescenceIor","thicknessMin","iridescenceThicknessMinimum","thicknessMax","iridescenceThicknessMaximum","DEFINE_IRIDESCENCE","KHR_materials_sheen","sheenColorTexture","sheenRoughnessTexture","DEFINE_SHEEN","sheenColorFactor","sheenRoughnessFactor","KHR_materials_transmission","transmissionTexture","transmissionFactor","RENDERMODE_CUSTOME","renderQueue","DEFINE_TRANSMISSION","KHR_materials_volume","thicknessTexture","DEFINE_THICKNESS","thicknessFactor","attenuationDistance","attenuationColor","KHR_materials_specular","specularTexture","specularColorTexture","specularFactor","specularColorFactor","KHR_materials_unlit","unlit","UnlitMaterial","albedoColor","toGamma","albedoTexture","registerLoader","task","options","glTF"],"sources":["../../src/layaAir/laya/gltf/shader/glTFShader.ts","../../bin/tsc/layaAir/laya/gltf/shader/glTFMetallicRoughness.glsl","../../bin/tsc/layaAir/laya/gltf/shader/glTFPBR.vs","../../bin/tsc/layaAir/laya/gltf/shader/glTFPBR.fs","../../bin/tsc/layaAir/laya/gltf/shader/glTFPBRDepth.vs","../../bin/tsc/layaAir/laya/gltf/shader/glTFPBRDepth.fs","../../bin/tsc/layaAir/laya/gltf/shader/glTFPBRDepthNormal.vs","../../bin/tsc/layaAir/laya/gltf/shader/glTFPBRDepthNormal.fs","../../src/layaAir/laya/gltf/glTFResource.ts","../../src/layaAir/laya/gltf/extensions/KHR_texture_transform.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_anisotropy.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_clearcoat.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_emissive_strength.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_ior.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_iridescence.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_sheen.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_transmission.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_volume.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_specular.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_unlit.ts","../../src/layaAir/laya/gltf/glTFLoader.ts"],"sourcesContent":["import { Shader3D } from \"../../RenderEngine/RenderShader/Shader3D\";\r\nimport { ShaderDataType } from \"../../RenderEngine/RenderShader/ShaderData\";\r\nimport { ShaderDefine } from \"../../RenderEngine/RenderShader/ShaderDefine\";\r\nimport { SubShader } from \"../../RenderEngine/RenderShader/SubShader\";\r\nimport { Vector3 } from \"../../maths/Vector3\";\r\nimport { Vector4 } from \"../../maths/Vector4\";\r\nimport { Texture2D } from \"../../resource/Texture2D\";\r\n\r\nimport glTFMetallicRoughnessGLSL from \"./glTFMetallicRoughness.glsl\";\r\nimport glTFPBRVS from \"./glTFPBR.vs\";\r\nimport glTFPBRFS from \"./glTFPBR.fs\";\r\nimport DepthVS from \"./glTFPBRDepth.vs\";\r\nimport DephtFS from \"./glTFPBRDepth.fs\";\r\nimport DepthNormalVS from \"./glTFPBRDepthNormal.vs\";\r\nimport DepthNormalFS from \"./glTFPBRDepthNormal.fs\";\r\nimport { Matrix3x3 } from \"../../maths/Matrix3x3\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class glTFShader {\r\n\r\n    static ShaderName: string = \"glTFPBR\";\r\n\r\n    static Define_BaseColorMap: ShaderDefine;\r\n    static Define_BaseColorMapTransform: ShaderDefine;\r\n\r\n    static Define_MetallicRoughnessMap: ShaderDefine;\r\n    static Define_MetallicRoughnessMapTransform: ShaderDefine;\r\n\r\n    static Define_NormalMap: ShaderDefine;\r\n    static Define_NormalMapTransform: ShaderDefine;\r\n\r\n    static Define_OcclusionMap: ShaderDefine;\r\n    static Define_OcclusionMapTransform: ShaderDefine;\r\n\r\n    static Define_EmissionMap: ShaderDefine;\r\n    static Define_EmissionMapTransform: ShaderDefine;\r\n\r\n    // clear coat\r\n    static Define_ClearCoatMap: ShaderDefine;\r\n    static Define_ClearCoatMapTransform: ShaderDefine;\r\n    static Define_ClearCoatRoughnessMap: ShaderDefine;\r\n    static Define_ClearCoatRoughnessMapTransform: ShaderDefine;\r\n    static Define_ClearCoatNormalMapTransform: ShaderDefine;\r\n\r\n    // anisotropy\r\n    static Define_AnisotropyMap: ShaderDefine;\r\n    static Define_AnisotropyMapTransform: ShaderDefine;\r\n\r\n    // iridescence\r\n    static Define_IridescenceMap: ShaderDefine;\r\n    static Define_IridescenceMapTransform: ShaderDefine;\r\n    static Define_IridescenceThicknessMap: ShaderDefine;\r\n    static Define_IridescenceThicknessMapTransform: ShaderDefine;\r\n\r\n    // sheen\r\n    static Define_SheenColorMap: ShaderDefine;\r\n    static Define_SheenColorMapTransform: ShaderDefine;\r\n    static Define_SheenRoughnessMap: ShaderDefine;\r\n    static Define_SheenRoughnessMapTransform: ShaderDefine;\r\n\r\n    // transmission\r\n    static Define_TransmissionMap: ShaderDefine;\r\n    static Define_TransmissionMapTransform: ShaderDefine;\r\n\r\n    // volume\r\n    static Define_VolumeThicknessMap: ShaderDefine;\r\n    static Define_VolumeThicknessMapTransform: ShaderDefine;\r\n\r\n    // specular\r\n    static Define_SpecularFactorMap: ShaderDefine;\r\n    static Define_SpecularFactorMapTransform: ShaderDefine;\r\n    static Define_SpecularColorMap: ShaderDefine;\r\n    static Define_SpecularColorMapTransform: ShaderDefine;\r\n\r\n    // todo\r\n    static init() {\r\n\r\n        this.Define_BaseColorMap = Shader3D.getDefineByName(\"BASECOLORMAP\");\r\n        this.Define_BaseColorMapTransform = Shader3D.getDefineByName(\"BASECOLORMAP_TRANSFORM\");\r\n\r\n        this.Define_MetallicRoughnessMap = Shader3D.getDefineByName(\"METALLICROUGHNESSMAP\");\r\n        this.Define_MetallicRoughnessMapTransform = Shader3D.getDefineByName(\"METALLICROUGHNESSMAP_TRANSFORM\");\r\n        this.Define_NormalMap = Shader3D.getDefineByName(\"NORMALMAP\");\r\n        this.Define_NormalMapTransform = Shader3D.getDefineByName(\"NORMALMAP_TRANSFORM\");\r\n        this.Define_OcclusionMap = Shader3D.getDefineByName(\"OCCLUSIONMAP\");\r\n        this.Define_OcclusionMapTransform = Shader3D.getDefineByName(\"OCCLUSIONMAP_TRANSFORM\");\r\n        this.Define_EmissionMap = Shader3D.getDefineByName(\"EMISSIONMAP\");\r\n        this.Define_EmissionMapTransform = Shader3D.getDefineByName(\"EMISSIONMAP_TRANSFORM\");\r\n\r\n        this.Define_ClearCoatMap = Shader3D.getDefineByName(\"CLEARCOATMAP\");\r\n        this.Define_ClearCoatMapTransform = Shader3D.getDefineByName(\"CLEARCOATMAP_TRANSFORM\");\r\n        this.Define_ClearCoatRoughnessMap = Shader3D.getDefineByName(\"CLEARCOAT_ROUGHNESSMAP\");\r\n        this.Define_ClearCoatRoughnessMapTransform = Shader3D.getDefineByName(\"CLEARCOAT_ROUGHNESSMAP_TRANSFORM\");\r\n        this.Define_ClearCoatNormalMapTransform = Shader3D.getDefineByName(\"CLEARCOAT_NORMALMAP_TRANSFORM\");\r\n\r\n        this.Define_AnisotropyMap = Shader3D.getDefineByName(\"ANISOTROPYMAP\");\r\n        this.Define_AnisotropyMapTransform = Shader3D.getDefineByName(\"ANISOTROPYMAP_TRANSFORM\");\r\n\r\n        this.Define_IridescenceMap = Shader3D.getDefineByName(\"IRIDESCENCEMAP\");\r\n        this.Define_IridescenceMapTransform = Shader3D.getDefineByName(\"IRIDESCENCEMAP_TRANSFORM\");\r\n        this.Define_IridescenceThicknessMap = Shader3D.getDefineByName(\"IRIDESCENCE_THICKNESSMAP\");\r\n        this.Define_IridescenceThicknessMapTransform = Shader3D.getDefineByName(\"IRIDESCENCE_THICKNESSMAP_TRANSFORM\");\r\n\r\n        this.Define_SheenColorMap = Shader3D.getDefineByName(\"SHEENCOLORMAP\");\r\n        this.Define_SheenColorMapTransform = Shader3D.getDefineByName(\"SHEENCOLORMAP_TRANSFORM\");\r\n        this.Define_SheenRoughnessMap = Shader3D.getDefineByName(\"SHEEN_ROUGHNESSMAP\");\r\n        this.Define_SheenRoughnessMapTransform = Shader3D.getDefineByName(\"SHEEN_ROUGHNESSMAP_TRANSFORM\");\r\n\r\n        this.Define_TransmissionMap = Shader3D.getDefineByName(\"TRANSMISSIONMAP\");\r\n        this.Define_TransmissionMapTransform = Shader3D.getDefineByName(\"TRANSMISSIONMAP_TRANSFORM\");\r\n\r\n        this.Define_VolumeThicknessMap = Shader3D.getDefineByName(\"THICKNESSMAP\");\r\n        this.Define_VolumeThicknessMapTransform = Shader3D.getDefineByName(\"THICKNESSMAP_TRANSFORM\");\r\n\r\n        this.Define_SpecularFactorMap = Shader3D.getDefineByName(\"SPECULARFACTORMAP\");\r\n        this.Define_SpecularFactorMapTransform = Shader3D.getDefineByName(\"SPECULARFACTORMAP_TRANSFORM\");\r\n        this.Define_SpecularColorMap = Shader3D.getDefineByName(\"SPECULARCOLORMAP\");\r\n        this.Define_SpecularColorMapTransform = Shader3D.getDefineByName(\"SPECULARCOLORMAP_TRANSFORM\");\r\n\r\n\r\n        let shader = Shader3D.find(glTFShader.name);\r\n        if (shader) {\r\n            return;\r\n        }\r\n\r\n        Shader3D.addInclude(\"glTFMetallicRoughness.glsl\", glTFMetallicRoughnessGLSL);\r\n        let uniformMap = {\r\n            // render \r\n            \"u_AlphaTestValue\": ShaderDataType.Float,\r\n            // surface\r\n            // metallic roughness\r\n            \"u_BaseColorFactor\": ShaderDataType.Vector4,\r\n            \"u_BaseColorTexture\": ShaderDataType.Texture2D,\r\n            \"u_BaseColorMapTransform\": ShaderDataType.Matrix3x3,\r\n            \"u_Specular\": ShaderDataType.Float,\r\n            \"u_MetallicFactor\": ShaderDataType.Float,\r\n            \"u_RoughnessFactor\": ShaderDataType.Float,\r\n            \"u_MetallicRoughnessTexture\": ShaderDataType.Texture2D,\r\n            \"u_MetallicRoughnessMapTransform\": ShaderDataType.Matrix3x3,\r\n\r\n            \"u_NormalTexture\": ShaderDataType.Texture2D,\r\n            \"u_NormalMapTransform\": ShaderDataType.Matrix3x3,\r\n            \"u_NormalScale\": ShaderDataType.Float,\r\n\r\n            \"u_OcclusionTexture\": ShaderDataType.Texture2D,\r\n            \"u_OcclusionMapTransform\": ShaderDataType.Matrix3x3,\r\n            \"u_OcclusionStrength\": ShaderDataType.Float,\r\n\r\n            \"u_EmissionFactor\": ShaderDataType.Vector3,\r\n            \"u_EmissionTexture\": ShaderDataType.Texture2D,\r\n            \"u_EmissionMapTransform\": ShaderDataType.Matrix3x3,\r\n            \"u_EmissionStrength\": ShaderDataType.Float,\r\n\r\n            // clear coat\r\n            \"u_ClearCoatFactor\": ShaderDataType.Float,\r\n            \"u_ClearCoatTexture\": ShaderDataType.Texture2D,\r\n            \"u_ClearCoatMapTransform\": ShaderDataType.Matrix3x3,\r\n            \"u_ClearCoatRoughness\": ShaderDataType.Float,\r\n            \"u_ClearCoatRoughnessTexture\": ShaderDataType.Texture2D,\r\n            \"u_ClearCoatRoughnessMapTransform\": ShaderDataType.Matrix3x3,\r\n            \"u_ClearCoatNormalTexture\": ShaderDataType.Texture2D,\r\n            \"u_ClearCoatNormalMapTransform\": ShaderDataType.Matrix3x3,\r\n            \"u_ClearCoatNormalScale\": ShaderDataType.Float,\r\n\r\n            // anisotropy\r\n            \"u_AnisotropyStrength\": ShaderDataType.Float,\r\n            \"u_AnisotropyRotation\": ShaderDataType.Float,\r\n            \"u_AnisotropyTexture\": ShaderDataType.Texture2D,\r\n            \"u_AnisotropyMapTransform\": ShaderDataType.Matrix3x3,\r\n\r\n            // ior\r\n            \"u_Ior\": ShaderDataType.Float,\r\n\r\n            // iridescence\r\n            \"u_IridescenceFactor\": ShaderDataType.Float,\r\n            \"u_IridescenceTexture\": ShaderDataType.Texture2D,\r\n            \"u_IridescenceMapTransform\": ShaderDataType.Matrix3x3,\r\n            \"u_IridescenceIor\": ShaderDataType.Float,\r\n            \"u_IridescenceThicknessMinimum\": ShaderDataType.Float,\r\n            \"u_IridescenceThicknessMaximum\": ShaderDataType.Float,\r\n            \"u_IridescenceThicknessTexture\": ShaderDataType.Texture2D,\r\n            \"u_IridescenceThicknessMapTransform\": ShaderDataType.Matrix3x3,\r\n\r\n            // sheen\r\n            \"u_SheenColorFactor\": ShaderDataType.Vector3,\r\n            \"u_SheenColorTexture\": ShaderDataType.Texture2D,\r\n            \"u_SheenColorMapTransform\": ShaderDataType.Matrix3x3,\r\n            \"u_SheenRoughness\": ShaderDataType.Float,\r\n            \"u_SheenRoughnessTexture\": ShaderDataType.Texture2D,\r\n            \"u_SheenRoughnessMapTransform\": ShaderDataType.Matrix3x3,\r\n\r\n            // transmission\r\n            \"u_TransmissionFactor\": ShaderDataType.Float,\r\n            \"u_TransmissionTexture\": ShaderDataType.Texture2D,\r\n            \"u_TransmissionMapTransform\": ShaderDataType.Matrix3x3,\r\n\r\n            // volume\r\n            \"u_VolumeThicknessFactor\": ShaderDataType.Float,\r\n            \"u_VolumeThicknessTexture\": ShaderDataType.Texture2D,\r\n            \"u_VoluemThicknessMapTransform\": ShaderDataType.Matrix3x3,\r\n            \"u_VolumeAttenuationDistance\": ShaderDataType.Float,\r\n            \"u_VolumeAttenuationColor\": ShaderDataType.Vector3,\r\n\r\n            // specular\r\n            \"u_SpecularFactor\": ShaderDataType.Float,\r\n            \"u_SpecularFactorTexture\": ShaderDataType.Texture2D,\r\n            \"u_SpecularFactorMapTransfrom\": ShaderDataType.Matrix3x3,\r\n\r\n            \"u_SpecularColorFactor\": ShaderDataType.Vector3,\r\n            \"u_SpecularColorTexture\": ShaderDataType.Texture2D,\r\n            \"u_SpecularColorMapTransform\": ShaderDataType.Matrix3x3,\r\n\r\n        }\r\n\r\n        let defaultValue = {\r\n            // render \r\n            \"u_AlphaTestValue\": 0.5,\r\n            // surface\r\n            \"u_BaseColorFactor\": Vector4.ONE,\r\n            \"u_BaseColorMapTransform\": Matrix3x3.DEFAULT,\r\n            \"u_Specular\": 0.5,\r\n            \"u_MetallicFactor\": 1.0,\r\n            \"u_RoughnessFactor\": 1.0,\r\n            \"u_MetallicRoughnessMapTransform\": Matrix3x3.DEFAULT,\r\n\r\n            \"u_NormalMapTransform\": Matrix3x3.DEFAULT,\r\n            \"u_NormalScale\": 1.0,\r\n            \"u_OcclusionMapTransform\": Matrix3x3.DEFAULT,\r\n            \"u_OcclusionStrength\": 1.0,\r\n\r\n            \"u_EmissionFactor\": Vector3.ZERO,\r\n            \"u_EmissionMapTransform\": Matrix3x3.DEFAULT,\r\n            \"u_EmissionStrength\": 1.0,\r\n\r\n            // specular\r\n            \"u_SpecularFactor\": 1.0,\r\n            \"u_SpecularFactorMapTransfrom\": Matrix3x3.DEFAULT,\r\n            \"u_SpecularColorFactor\": Vector3.ONE,\r\n            \"u_SpecularColorMapTransform\": Matrix3x3.DEFAULT,\r\n\r\n            \"u_Ior\": 1.5,\r\n\r\n            // clear coat\r\n            \"u_ClearCoatFactor\": 0.0,\r\n            \"u_ClearCoatMapTransform\": Matrix3x3.DEFAULT,\r\n            \"u_ClearCoatRoughness\": 0.0,\r\n            \"u_ClearCoatRoughnessMapTransform\": Matrix3x3.DEFAULT,\r\n            \"u_ClearCoatNormalMapTransform\": Matrix3x3.DEFAULT,\r\n            \"u_ClearCoatNormalScale\": 1.0,\r\n\r\n            // anisotropy\r\n            \"u_AnisotropyStrength\": 0.0,\r\n            \"u_AnisotropyRotation\": 0.0,\r\n            \"u_AnisotropyMapTransform\": Matrix3x3.DEFAULT,\r\n\r\n            // iridescence\r\n            \"u_IridescenceFactor\": 0.0,\r\n            \"u_IridescenceMapTransform\": Matrix3x3.DEFAULT,\r\n            \"u_IridescenceIor\": 1.33,\r\n            \"u_IridescenceThicknessMinimum\": 100,\r\n            \"u_IridescenceThicknessMaximum\": 400,\r\n            \"u_IridescenceThicknessMapTransform\": Matrix3x3.DEFAULT,\r\n\r\n            // sheen\r\n            \"u_SheenColorFactor\": Vector3.ZERO,\r\n            \"u_SheenColorMapTransform\": Matrix3x3.DEFAULT,\r\n            \"u_SheenRoughness\": 0.0,\r\n            \"u_SheenRoughnessMapTransform\": Matrix3x3.DEFAULT,\r\n\r\n            // transmission\r\n            \"u_TransmissionFactor\": 0.0,\r\n            \"u_TransmissionMapTransform\": Matrix3x3.DEFAULT,\r\n        }\r\n\r\n        shader = Shader3D.add(\"glTFPBR\", true, true);\r\n        let subShader = new SubShader(SubShader.DefaultAttributeMap, uniformMap, defaultValue);\r\n        shader.addSubShader(subShader);\r\n\r\n        let shadingPass = subShader.addShaderPass(glTFPBRVS, glTFPBRFS);\r\n        let depthPass = subShader.addShaderPass(DepthVS, DephtFS, \"ShadowCaster\");\r\n        let dephtNormalPass = subShader.addShaderPass(DepthNormalVS, DepthNormalFS, \"DepthNormal\");\r\n\r\n    }\r\n\r\n}","#if !defined(glTFMetallicRoughness_lib)\r\n    #define glTFMetallicRoughness_lib\r\n\r\n    #include \"ShadingFrag.glsl\";\r\n\r\n    #include \"PBRFrag.glsl\";\r\n\r\nstruct SurfaceInputs {\r\n    vec3 diffuseColor;\r\n    float alpha;\r\n    float alphaTest;\r\n    float metallic;\r\n    float roughness;\r\n    float occlusion;\r\n    vec3 emissionColor;\r\n    vec3 normalTS;\r\n    float specular;\r\n\r\n    // specular\r\n    float specularFactor;\r\n    vec3 specularColor;\r\n\r\n    #ifdef CLEARCOAT\r\n    float clearCoat;\r\n    float clearCoatRoughness;\r\n\t#ifdef CLEARCOAT_NORMAL\r\n    vec3 clearCoatNormalTS;\r\n\t#endif // CLEARCOAT_NORMAL\r\n    #endif // CLEARCOAT\r\n\r\n    #ifdef ANISOTROPIC\r\n    float anisotropy;\r\n    vec2 anisotropyDirection;\r\n    #endif // ANISOTROPIC\r\n\r\n    #ifdef IOR\r\n    float ior;\r\n    #endif // IOR\r\n\r\n    #ifdef IRIDESCENCE\r\n    float iridescence;\r\n    float iridescenceIor;\r\n    float iridescenceThickness;\r\n    #endif // IRIDESCENCE\r\n\r\n    #ifdef SHEEN\r\n    vec3 sheenColor;\r\n    float sheenRoughness;\r\n    #endif // SHEEN\r\n\r\n    #ifdef TRANSMISSION\r\n    float transmission;\r\n    #endif // TRANSMISSION\r\n\r\n    #ifdef THICKNESS\r\n    float thickness;\r\n    vec3 attenuationColor;\r\n    float attenuationDistance;\r\n    #endif // THICKNESS\r\n};\r\n\r\nvoid initSurface(inout Surface surface, const in SurfaceInputs inputs, const in PixelParams pixel)\r\n{\r\n    surface.alpha = inputs.alpha;\r\n\r\n    surface.normalTS = inputs.normalTS;\r\n\r\n    vec3 baseColor = inputs.diffuseColor;\r\n    float metallic = inputs.metallic;\r\n    float perceptualRoughness = inputs.roughness;\r\n\r\n    #ifdef IOR\r\n    float ior = inputs.ior;\r\n    surface.ior = ior;\r\n    vec3 f0 = vec3(dielectricIorToF0(ior));\r\n    #else // IOR\r\n    vec3 f0 = vec3(dielectricSpecularToF0(inputs.specular));\r\n    surface.ior = dielectricF0ToIor(f0.x);\r\n    #endif // IOR\r\n\r\n    // KHR_materials_specular\r\n    f0 *= inputs.specularFactor * inputs.specularColor;\r\n\r\n    surface.perceptualRoughness = max(perceptualRoughness, MIN_PERCEPTUAL_ROUGHNESS);\r\n    surface.roughness = surface.perceptualRoughness * surface.perceptualRoughness;\r\n    surface.diffuseColor = computeDiffuse(baseColor, metallic);\r\n    surface.f0 = computeF0(f0, baseColor, metallic);\r\n    surface.f90 = computeF90(surface.f0);\r\n\r\n    surface.occlusion = inputs.occlusion;\r\n\r\n    #ifdef EMISSION\r\n    surface.emissionColor = inputs.emissionColor;\r\n    #endif // EMISSION\r\n\r\n    #ifdef IRIDESCENCE\r\n    surface.iridescence = inputs.iridescence;\r\n    surface.iridescenceIor = inputs.iridescenceIor;\r\n    surface.iridescenceThickness = inputs.iridescenceThickness;\r\n    #endif // IRIDESCENCE\r\n\r\n    #ifdef SHEEN\r\n    surface.sheenColor = inputs.sheenColor;\r\n    surface.sheenPerceptualRoughness = max(inputs.sheenRoughness, MIN_PERCEPTUAL_ROUGHNESS);\r\n    surface.sheenRoughness = pow2(surface.sheenPerceptualRoughness);\r\n    #endif // SHEEN\r\n\r\n    #ifdef CLEARCOAT\r\n    surface.clearCoat = inputs.clearCoat;\r\n    surface.clearCoatPerceptualRoughness = clamp(inputs.clearCoatRoughness, MIN_PERCEPTUAL_ROUGHNESS, 1.0);\r\n    surface.clearCoatRoughness = surface.clearCoatPerceptualRoughness * surface.clearCoatPerceptualRoughness;\r\n\t#ifdef CLEARCOAT_NORMAL\r\n    surface.clearCoatNormalTS = inputs.clearCoatNormalTS;\r\n\t#endif // CLEARCOAT_NORMAL\r\n    #endif // CLEARCOAT\r\n\r\n    #ifdef ANISOTROPIC\r\n    surface.anisotropy = inputs.anisotropy;\r\n    surface.anisotropyDirection = inputs.anisotropyDirection;\r\n    #endif // ANISOTROPIC\r\n\r\n    #ifdef TRANSMISSION\r\n    surface.transmission = inputs.transmission;\r\n    #endif // TRANSMISSION\r\n\r\n    #ifdef THICKNESS\r\n    surface.thickness = inputs.thickness;\r\n    surface.attenuationColor = inputs.attenuationColor;\r\n    surface.attenuationDistance = inputs.attenuationDistance;\r\n    #endif // THICKNESS\r\n}\r\n\r\nvec4 glTFMetallicRoughness(const in SurfaceInputs inputs, in PixelParams pixel)\r\n{\r\n    #ifdef ALPHATEST\r\n    if (inputs.alpha < inputs.alphaTest)\r\n\t{\r\n\t    discard;\r\n\t}\r\n    #endif // ALPHATEST\r\n\r\n    Surface surface;\r\n    initSurface(surface, inputs, pixel);\r\n\r\n    PixelInfo info;\r\n    getPixelInfo(info, pixel, surface);\r\n\r\n    vec3 surfaceColor = vec3(0.0);\r\n    surfaceColor += PBRLighting(surface, info);\r\n\r\n    return vec4(surfaceColor, surface.alpha);\r\n}\r\n\r\n#endif // glTFMetallicRoughness_lib","#define SHADER_NAME glTFPBRVS\r\n\r\n#include \"Math.glsl\";\r\n\r\n#include \"Scene.glsl\";\r\n#include \"SceneFogInput.glsl\";\r\n\r\n#include \"Camera.glsl\";\r\n#include \"Sprite3DVertex.glsl\";\r\n\r\n#include \"VertexCommon.glsl\";\r\n\r\n#include \"PBRVertex.glsl\";\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    PixelParams pixel;\r\n    initPixelParams(pixel, vertex);\r\n\r\n    gl_Position = getPositionCS(pixel.positionWS);\r\n\r\n    gl_Position = remapPositionZ(gl_Position);\r\n\r\n#ifdef FOG\r\n    FogHandle(gl_Position.z);\r\n#endif\r\n}","#define SHADER_NAME glTFPBRFS\r\n\r\n#include \"Color.glsl\";\r\n\r\n#include \"Scene.glsl\";\r\n#include \"SceneFog.glsl\";\r\n\r\n#include \"Camera.glsl\";\r\n#include \"Sprite3DFrag.glsl\";\r\n\r\n#include \"glTFMetallicRoughness.glsl\";\r\n\r\nvoid initSurfaceInputs(inout SurfaceInputs inputs, const in PixelParams pixel)\r\n{\r\n    vec2 uv = vec2(0.0);\r\n#ifdef UV\r\n    uv = pixel.uv0;\r\n#endif //\r\n\r\n    // render state\r\n    inputs.alphaTest = u_AlphaTestValue;\r\n\r\n    // surface\r\n    inputs.diffuseColor = u_BaseColorFactor.xyz;\r\n    inputs.alpha = u_BaseColorFactor.w;\r\n\r\n#ifdef COLOR\r\n    #ifdef ENABLEVERTEXCOLOR\r\n    inputs.diffuseColor *= pixel.vertexColor.xyz;\r\n    inputs.alpha *= pixel.vertexColor.a;\r\n    #endif // ENABLEVERTEXCOLOR\r\n#endif // COLOR\r\n\r\n#ifdef BASECOLORMAP\r\n    vec2 baseColorUV = uv;\r\n    #ifdef BASECOLORMAP_TRANSFORM\r\n    baseColorUV = (u_BaseColorMapTransform * vec3(baseColorUV, 1.0)).xy;\r\n    #endif // BASECOLORMAP_TRANSFORM\r\n    vec4 baseColorSampler = texture2D(u_BaseColorTexture, baseColorUV);\r\n    #ifdef Gamma_u_BaseColorTexture\r\n    baseColorSampler = gammaToLinear(baseColorSampler);\r\n    #endif // u_BaseColorTexture_Gamma\r\n    inputs.diffuseColor *= baseColorSampler.rgb;\r\n    inputs.alpha *= baseColorSampler.a;\r\n#endif // BASECOLORMAP\r\n\r\n    inputs.specular = u_Specular;\r\n\r\n    inputs.specularFactor = 1.0;\r\n    inputs.specularColor = vec3(1.0);\r\n\r\n    inputs.specularFactor = u_SpecularFactor;\r\n#ifdef SPECULARFACTORMAP\r\n    vec2 specularFactorUV = uv;\r\n    #ifdef SPECULARFACTORMAP_TRANSFORM\r\n    specularFactorUV = (u_SpecularFactorMapTransfrom * specularFactorUV).xy;\r\n    #endif // SPECULARFACTORMAP_TRANSFORM\r\n    vec4 specularFactorSampler = texture2D(u_SpecularFactorTexture, specularFactorUV);\r\n    inputs.specularFactor *= specularFactorSampler.a;\r\n#endif // SPECULARFACTORMAP\r\n\r\n    inputs.specularColor = u_SpecularColorFactor;\r\n#ifdef SPECULARCOLORMAP\r\n    vec2 specularColorUV = uv;\r\n    #ifdef SPECULARFACTORMAP_TRANSFORM\r\n    specularColorUV = (u_SpecularColorMapTransform * specularColorUV).xy;\r\n    #endif // SPECULARFACTORMAP_TRANSFORM\r\n    vec4 specularColorSampler = texture2D(u_SpecularColorTexture, specularColorUV);\r\n    #ifdef Gamma_u_SpecularColorTexture\r\n    specularColorSampler = gammaToLinear(specularColorSampler);\r\n    #endif // Gamma_u_SpecularColorTexture\r\n    inputs.specularColor *= specularColorSampler.rgb;\r\n#endif // SPECULARCOLORMAP\r\n\r\n    inputs.metallic = u_MetallicFactor;\r\n    float roughness = u_RoughnessFactor;\r\n#ifdef METALLICROUGHNESSMAP\r\n    vec2 metallicUV = uv;\r\n    #ifdef METALLICROUGHNESSMAP_TRANSFORM\r\n    metallicUV = (u_MetallicRoughnessMapTransform * vec3(metallicUV, 1.0)).xy;\r\n    #endif METALLICROUGHNESSMAP_TRANSFORM\r\n    vec4 metallicRoughnessSampler = texture2D(u_MetallicRoughnessTexture, metallicUV);\r\n    inputs.metallic *= metallicRoughnessSampler.b;\r\n    roughness *= metallicRoughnessSampler.g;\r\n#endif // METALLICROUGHNESSMAP\r\n    inputs.roughness = roughness;\r\n\r\n    float occlusion = 1.0;\r\n#ifdef OCCLUSIONMAP\r\n    vec2 occlusionUV = uv;\r\n    #ifdef OCCLUSIONMAP_TRANSFORM\r\n    occlusionUV = (u_OcclusionMapTransform * vec3(occlusionUV, 1.0)).xy;\r\n    #endif // OCCLUSIONMAP_TRANSFORM\r\n    vec4 occlusionSampler = texture2D(u_OcclusionTexture, occlusionUV);\r\n    #ifdef Gamma_u_OcclusionTexture\r\n    occlusionSampler = gammaToLinear(occlusionSampler);\r\n    #endif // Gamma_u_OcclusionTexture\r\n    occlusion = occlusionSampler.r;\r\n#endif // OCCLUSIONMAP\r\n    inputs.occlusion = (1.0 - u_OcclusionStrength) + occlusion * u_OcclusionStrength;\r\n\r\n    inputs.emissionColor = u_EmissionFactor * u_EmissionStrength;\r\n#ifdef EMISSIONMAP\r\n    vec2 emissionUV = uv;\r\n    #ifdef EMISSIONMAP_TRANSFORM\r\n    emissionUV = (u_EmissionMapTransform * vec3(emissionUV, 1.0)).xy;\r\n    #endif // EMISSIONMAP_TRANSFORM\r\n    vec4 emissionSampler = texture2D(u_EmissionTexture, emissionUV);\r\n    #ifdef Gamma_u_EmissionTexture\r\n    emissionSampler = gammaToLinear(emissionSampler);\r\n    #endif // Gamma_u_EmissionTexture\r\n    inputs.emissionColor *= emissionSampler.rgb;\r\n#endif // EMISSIONMAP\r\n\r\n    inputs.normalTS = vec3(0.0, 0.0, 1.0);\r\n#ifdef NORMALMAP\r\n    vec2 normalUV = uv;\r\n    #ifdef NORMALMAP_TRANSFORM\r\n    normalUV = (u_NormalMapTransform * vec3(normalUV, 1.0)).xy;\r\n    #endif // NORMALMAP_TRANSFORM\r\n    vec3 normalSampler = texture2D(u_NormalTexture, normalUV).xyz;\r\n    normalSampler = normalize(normalSampler * 2.0 - 1.0);\r\n    normalSampler.y *= -1.0;\r\n    inputs.normalTS = normalScale(normalSampler, u_NormalScale);\r\n#endif // NORMALMAP\r\n\r\n#ifdef IOR\r\n    inputs.ior = u_Ior;\r\n#endif // IOR\r\n\r\n#ifdef IRIDESCENCE\r\n    float iridescenceFactor = u_IridescenceFactor;\r\n    #ifdef IRIDESCENCEMAP\r\n    vec2 iridescenceUV = uv;\r\n\t#ifdef IRIDESCENCEMAP_TRANSFORM\r\n    iridescenceUV = (u_IridescenceMapTransform * vec3(iridescenceUV, 1.0)).xy;\r\n\t#endif // IRIDESCENCEMAP_TRANSFORM\r\n    vec4 iridescenceSampler = texture2D(u_IridescenceTexture, iridescenceUV);\r\n    iridescenceFactor *= iridescenceSampler.r;\r\n    #endif // IRIDESCENCEMAP\r\n    float iridescenceThickness = u_IridescenceThicknessMaximum;\r\n    #ifdef IRIDESCENCE_THICKNESSMAP\r\n    vec2 iridescenceThicknessUV = uv;\r\n\t#ifdef IRIDESCENCE_THICKNESSMAP_TRANSFORM\r\n    iridescenceThicknessUV = (u_IridescenceThicknessMapTransform, vec3(iridescenceThicknessUV, 1.0)).xy;\r\n\t#endif // IRIDESCENCE_THICKNESSMAP_TRANSFORM\r\n    vec4 iridescenceThicknessSampler = texture2D(u_IridescenceThicknessTexture, iridescenceThicknessUV);\r\n    iridescenceThickness = mix(u_IridescenceThicknessMinimum, u_IridescenceThicknessMaximum, iridescenceThicknessSampler.g);\r\n    #endif // IRIDESCENCE_THICKNESSMAP\r\n    inputs.iridescence = iridescenceFactor;\r\n    inputs.iridescenceIor = u_IridescenceIor;\r\n    inputs.iridescenceThickness = iridescenceThickness;\r\n#endif // IRIDESCENCE\r\n\r\n#ifdef SHEEN\r\n    vec3 sheenColor = u_SheenColorFactor;\r\n    #ifdef SHEENCOLORMAP\r\n    vec2 sheenColorUV = uv;\r\n\t#ifdef SHEENCOLORMAP_TRANSFORM\r\n    sheenColorUV = (u_SheenColorMapTransform * vec3(sheenColorUV, 1.0)).xy;\r\n\t#endif // SHEENCOLORMAP_TRANSFORM\r\n    vec4 sheenColorSampler = texture2D(u_SheenColorTexture, sheenColorUV);\r\n\t#ifdef Gamma_u_SheenColorFactor\r\n    sheenColorSampler = gammaToLinear(sheenColorSampler);\r\n\t#endif // Gamma_u_SheenColorFactor\r\n    sheenColor *= sheenColorSampler.rgb;\r\n    #endif // SHEENCOLORMAP\r\n\r\n    float sheenRoughness = u_SheenRoughness;\r\n    #ifdef SHEEN_ROUGHNESSMAP\r\n    vec2 sheenRoughnessUV = uv;\r\n\t#ifdef SHEEN_ROUGHNESSMAP_TRANSFORM\r\n    sheenRoughnessUV = (u_SheenRoughnessMapTransform * vec3(sheenRoughnessUV, 1.0)).xy;\r\n\t#endif // SHEEN_ROUGHNESSMAP_TRANSFORM\r\n    vec4 sheenRoughnessSampler = texture2D(u_SheenRoughnessTexture, sheenRoughnessUV);\r\n    sheenRoughness *= sheenRoughnessSampler.a;\r\n    #endif // SHEEN_ROUGHNESSMAP\r\n\r\n    inputs.sheenColor = sheenColor;\r\n    inputs.sheenRoughness = sheenRoughness;\r\n#endif // SHEEN\r\n\r\n#ifdef CLEARCOAT\r\n    inputs.clearCoat = u_ClearCoatFactor;\r\n    inputs.clearCoatRoughness = u_ClearCoatRoughness;\r\n\r\n    #ifdef CLEARCOATMAP\r\n    vec2 clearCoatUV = uv;\r\n\t#ifdef CLEARCOATMAP_TRANSFORM\r\n    clearCoatUV = (u_ClearCoatMapTransform * vec3(clearCoatUV, 1.0)).xy;\r\n\t#endif // CLEARCOATMAP_TRANSFORM\r\n    vec4 clearCoatSampler = texture2D(u_ClearCoatTexture, clearCoatUV);\r\n    inputs.clearCoat *= clearCoatSampler.r;\r\n    #endif // CLEARCOATMAP\r\n\r\n    #ifdef CLEARCOAT_ROUGHNESSMAP\r\n    vec2 clearCoatRoughnessUV = uv;\r\n\t#ifdef CLEARCOAT_ROUGHNESSMAP_TRANSFORM\r\n    clearCoatRoughnessUV = (u_ClearCoatRoughnessMapTransform * vec3(uv, 1.0)).xy;\r\n\t#endif // CLEARCOAT_ROUGHNESSMAP_TRANSFORM\r\n    vec4 clearcoatSampleRoughness = texture2D(u_ClearCoatRoughnessTexture, clearCoatRoughnessUV);\r\n    inputs.clearCoatRoughness *= clearcoatSampleRoughness.g;\r\n    #endif // CLEARCOAT_ROUGHNESSMAP\r\n\r\n    #ifdef CLEARCOAT_NORMAL\r\n    vec2 clearCoatNormalUV = uv;\r\n\t#ifdef CLEARCOAT_NORMALMAP_TRANSFORM\r\n    clearCoatNormalUV = (u_ClearCoatNormalMapTransform * vec3(clearCoatNormalUV, 1.0)).xy;\r\n\t#endif // CLEARCOAT_NORMALMAP_TRANSFORM\r\n    vec3 clearCoatNormalSampler = texture2D(u_ClearCoatNormalTexture, clearCoatNormalUV).rgb;\r\n    clearCoatNormalSampler = normalize(clearCoatNormalSampler * 2.0 - 1.0);\r\n    clearCoatNormalSampler.y *= -1.0;\r\n    // todo scale\r\n    inputs.clearCoatNormalTS = normalScale(clearCoatNormalSampler, u_ClearCoatNormalScale);\r\n    #endif // CLEARCOAT_NORMAL\r\n#endif // CLEARCOAT\r\n\r\n#ifdef ANISOTROPIC\r\n    inputs.anisotropy = u_AnisotropyStrength;\r\n    vec2 direction = vec2(1.0, 0.0);\r\n\r\n    #ifdef ANISOTROPYMAP\r\n    vec2 anisotropyUV = uv;\r\n\t#ifdef ANISOTROPYMAP_TRANSFORM\r\n    anisotropyUV = (u_AnisotropyMapTransform * vec3(anisotropyUV, 1.0)).xy;\r\n\t#endif // ANISOTROPYMAP_TRANSFORM\r\n    vec3 anisotropySampler = texture2D(u_AnisotropyTexture, anisotropyUV).rgb;\r\n\r\n    inputs.anisotropy *= anisotropySampler.b;\r\n    direction = anisotropySampler.xy * 2.0 - 1.0;\r\n    #endif // ANISOTROPYMAP\r\n\r\n    vec2 anisotropyRotation = vec2(cos(u_AnisotropyRotation), sin(u_AnisotropyRotation));\r\n    mat2 rotationMatrix = mat2(anisotropyRotation.x, anisotropyRotation.y, -anisotropyRotation.y, anisotropyRotation.x);\r\n    inputs.anisotropyDirection = rotationMatrix * direction;\r\n\r\n#endif // ANISOTROPIC\r\n\r\n#ifdef TRANSMISSION\r\n    float transmission = u_TransmissionFactor;\r\n    #ifdef TRANSMISSIONMAP\r\n    vec2 transmissionUV = uv;\r\n\t#ifdef TRANSMISSIONMAP_TRANSFORM\r\n    transmissionUV = (u_TransmissionMapTransform * vec3(transmissionUV, 1.0)).xy;\r\n\t#endif // TRANSMISSIONMAP_TRANSFORM\r\n    vec4 transmissionSampler = texture2D(u_TransmissionTexture, transmissionUV);\r\n    transmission *= transmissionSampler.r;\r\n    #endif // TRANSMISSIONMAP\r\n    inputs.transmission = transmission;\r\n#endif // TRANSMISSION\r\n\r\n#ifdef THICKNESS\r\n\r\n    float thicknessFactor = u_VolumeThicknessFactor;\r\n    float attenuationDistance = u_VolumeAttenuationDistance;\r\n    vec3 attenuationColor = u_VolumeAttenuationColor.xyz;\r\n\r\n    #ifdef THICKNESSMAP\r\n    vec2 thicknessUV = uv;\r\n\t#ifdef THICKNESSMAP_TRANSFORM\r\n    thicknessUV = (u_VoluemThicknessMapTransform * vec3(thicknessUV, 1.0)).xy;\r\n\t#endif // THICKNESSMAP_TRANSFORM\r\n    vec4 thicknessSampler = texture2D(u_VolumeThicknessTexture, thicknessUV);\r\n    thicknessFactor *= thicknessSampler.g;\r\n    #endif // THICKNESSMAP\r\n\r\n    inputs.thickness = thicknessFactor;\r\n    inputs.attenuationColor = attenuationColor;\r\n    inputs.attenuationDistance = attenuationDistance;\r\n\r\n#endif // THICKNESS\r\n}\r\n\r\nvoid main()\r\n{\r\n\r\n#ifndef DEBUG\r\n    PixelParams pixel;\r\n    getPixelParams(pixel);\r\n\r\n    SurfaceInputs inputs;\r\n    initSurfaceInputs(inputs, pixel);\r\n\r\n    vec4 surfaceColor = glTFMetallicRoughness(inputs, pixel);\r\n\r\n    #ifdef FOG\r\n    surfaceColor.rgb = sceneLitFog(surfaceColor.rgb);\r\n    #endif // FOG\r\n\r\n    gl_FragColor = surfaceColor;\r\n\r\n#else DEBUG\r\n    // // debug\r\n    PixelParams pixel;\r\n    getPixelParams(pixel);\r\n\r\n    SurfaceInputs inputs;\r\n    initSurfaceInputs(inputs, pixel);\r\n\r\n    Surface surface;\r\n    initSurface(surface, inputs, pixel);\r\n\r\n    PixelInfo info;\r\n    getPixelInfo(info, pixel, surface);\r\n\r\n    vec3 debug = vec3(0.0);\r\n\r\n    #ifdef Debug_ShadingNormal\r\n    debug = vec3(info.normalWS * 0.5 + 0.5);\r\n    #endif // Debug_ShadingNormal\r\n\r\n    #ifdef Debug_GeometryNormal\r\n    debug = vec3(info.vertexNormalWS * 0.5 + 0.5);\r\n    #endif // Debug_GeometryNormal\r\n\r\n    #ifdef Debug_GeometryTangent\r\n    debug = vec3(pixel.tangentWS * 0.5 + 0.5);\r\n    #endif // Debug_GeometryTangent\r\n\r\n    #ifdef Debug_GeometryBiTangent\r\n    debug = vec3(pixel.biNormalWS * 0.5 + 0.5);\r\n    #endif // Debug_GeometryBiTangent\r\n\r\n    #ifdef Debug_Roughness\r\n    debug = vec3(surface.perceptualRoughness);\r\n    #endif // Debug_Roughness\r\n\r\n    #ifdef Debug_Alpha\r\n    debug = vec3(surface.alpha);\r\n    #endif // Debug_Alpha\r\n\r\n    #ifdef Debug_Occlusion\r\n    debug = vec3(surface.occlusion);\r\n    #endif // Debug_Occlusion\r\n\r\n    #ifdef Debug_BaseColor\r\n    debug = surface.diffuseColor;\r\n    #endif // Debug_BaseColor\r\n\r\n    #ifdef Debug_Metallic\r\n    debug = vec3(inputs.metallic);\r\n    #endif // Debug_Metallic\r\n\r\n    #ifdef THICKNESS\r\n\t#ifdef Debug_VolumeThickness\r\n    debug = vec3(surface.thickness);\r\n\t#endif // Debug_VolumeThickness\r\n\r\n\t#ifdef Debug_Attenuation\r\n    {\r\n\tvec3 scaleLength = vec3(0.0);\r\n\tscaleLength.x = length(vec3(u_WorldMat[0].xyz));\r\n\tscaleLength.y = length(vec3(u_WorldMat[1].xyz));\r\n\tscaleLength.z = length(vec3(u_WorldMat[2].xyz));\r\n\r\n\tvec3 n = info.normalWS;\r\n\tvec3 r = -info.viewDir;\r\n\tfloat airIor = 1.0;\r\n\r\n\tfloat ior = surface.ior;\r\n\tfloat etaIR = airIor / ior;\r\n\tfloat etaRI = ior / airIor;\r\n\tvec3 refractionVector = normalize(refract(r, n, etaIR)) * surface.thickness * scaleLength;\r\n\r\n\tvec3 absorption = -log((surface.attenuationColor)) / (surface.attenuationDistance);\r\n\tdebug = exp(-absorption);\r\n    }\r\n\t#endif // Debug_Attenuation\r\n\r\n    #endif // THICKNESS\r\n\r\n    #ifdef TRANSMISSION\r\n\t#ifdef Debug_Transmission\r\n    vec3 E = getE(surface, info);\r\n    debug = transmissionIBL(surface, info, E);\r\n\t#endif // Debug_Transmission\r\n    #endif // TRANSMISSION\r\n\r\n    #ifdef Debug_IOR\r\n    debug = vec3(surface.ior - 1.0);\r\n    #endif // Debug_IOR\r\n\r\n    #ifdef Debug_SpecularFactor\r\n    debug = vec3(inputs.specularFactor);\r\n    #endif // Debug_SpecularFactor\r\n\r\n    #ifdef Debug_SpecularColor\r\n    debug = vec3(inputs.specularColor);\r\n    #endif // DebugSpecularColor\r\n\r\n    #ifdef Debug_f0\r\n    debug = vec3(surface.f0);\r\n    #endif // Debug_f0\r\n\r\n    #ifdef Debug_f90\r\n    debug = vec3(surface.f90);\r\n    #endif // Debug_f90\r\n\r\n    #ifdef Debug_FrontFace\r\n    if (gl_FrontFacing)\r\n\t{\r\n\t    debug = vec3(1.0, 0.0, 0.0);\r\n\t}\r\n    else\r\n\t{\r\n\t    debug = vec3(0.0, 1.0, 0.0);\r\n\t}\r\n    #endif // Debug_FrontFace\r\n\r\n    #ifdef Debug_SpecularAO\r\n    float specularAO = saturate(pow(info.NoV + surface.occlusion, exp2(-16.0 * surface.roughness - 1.0)) - 1.0 + surface.occlusion);\r\n\r\n    float diffAO = specularAO - surface.occlusion;\r\n\r\n    debug = vec3(abs(diffAO));\r\n\r\n    if (diffAO < 0.0)\r\n\t{\r\n\t    debug *= vec3(1.0, 0.0, 0.0);\r\n\t}\r\n    else\r\n\t{\r\n\t    debug *= vec3(0.0, 1.0, 0.0);\r\n\t}\r\n    #endif // Debug_SpecularAO\r\n\r\n    // // #ifdef CLEARCOAT\r\n    // //     // debug = vec3(info.iridescenceFresnel);\r\n    // //     #ifdef CLEARCOAT_NORMAL\r\n    // //     debug = vec3(surface.clearCoatNormalTS * 0.5 + 0.5);\r\n    // //     #endif // CLEARCOAT_NORMAL\r\n    // //     // debug = vec3(surface.clearCoatRoughness);\r\n    // //     // debug = vec3(surface.clearCoat);\r\n    // // #endif // CLEARCOAT\r\n\r\n    // debug = vec3(info.normalWS * 0.5 + 0.5);\r\n\r\n    // // #ifdef SHEEN\r\n    // //     // debug = vec3(inputs.sheenColor);\r\n    // //     // debug = vec3(inputs.sheenRoughness);\r\n    // //     debug = vec3(info.sheenScaling);\r\n    // // #endif // SHEEN\r\n\r\n    // // #ifdef IRIDESCENCE\r\n    // //     // debug = vec3(surface.iridescenceIor - 1.0);\r\n    // //     // debug = vec3(surface.iridescenceThickness / 1200.0);\r\n    // //     debug = vec3(info.iridescenceFresnel);\r\n    // // #endif // IRIDESCENCE\r\n\r\n    // // #ifdef TRANSMISSION\r\n    // //     debug = vec3(surface.transmission);\r\n    // // #endif // TRANSMISSION\r\n\r\n    debug = gammaToLinear(debug);\r\n    gl_FragColor = vec4(debug, 1.0);\r\n\r\n#endif // DEBUG\r\n}","#define SHADER_NAME glTFDepthVS\r\n\r\n#include \"DepthVertex.glsl\";\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    mat4 worldMat = getWorldMatrix();\r\n    vec4 pos = (worldMat * vec4(vertex.positionOS, 1.0));\r\n    vec3 positionWS = pos.xyz / pos.w;\r\n\r\n    mat4 normalMat = transpose(inverse(worldMat));\r\n    vec3 normalWS = normalize((normalMat * vec4(vertex.normalOS, 0.0)).xyz);\r\n\r\n    vec4 positionCS = DepthPositionCS(positionWS, normalWS);\r\n    gl_Position = remapPositionZ(positionCS);\r\n}","#define SHADER_NAME glTFDepthFS\r\n\r\n#include \"DepthFrag.glsl\";\r\n\r\nvoid main()\r\n{\r\n    gl_FragColor = getDepthColor();\r\n}","#define SHADER_NAME glTFPBRDepthNormalVS\r\n\r\n#include \"Math.glsl\";\r\n\r\n#include \"Camera.glsl\";\r\n\r\n#include \"Sprite3DVertex.glsl\";\r\n\r\n#include \"VertexCommon.glsl\";\r\n\r\n#include \"PBRVertex.glsl\";\r\n\r\nvarying vec4 v_PositionCS;\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    PixelParams pixel;\r\n    initPixelParams(pixel, vertex);\r\n\r\n    sharePixelParams(pixel);\r\n\r\n    vec4 positionCS = getPositionCS(pixel.positionWS);\r\n    v_PositionCS = positionCS;\r\n    gl_Position = positionCS;\r\n    gl_Position = remapPositionZ(gl_Position);\r\n}","#define SHADER_NAME glTFPBRDepthNormalFS\r\n\r\n#include \"Color.glsl\";\r\n\r\n#include \"Scene.glsl\";\r\n#include \"SceneFog.glsl\";\r\n\r\n#include \"Camera.glsl\";\r\n#include \"Sprite3DFrag.glsl\";\r\n\r\n#include \"ShadingFrag.glsl\";\r\n\r\n#include \"DepthNormalFrag.glsl\";\r\n\r\nvarying vec4 v_PositionCS;\r\n\r\nvoid main()\r\n{\r\n    PixelParams pixel;\r\n    getPixelParams(pixel);\r\n\r\n    vec3 normalWS = pixel.normalWS;\r\n\r\n#ifdef NORMALMAP\r\n    #ifdef UV\r\n\r\n    vec2 uv = pixel.uv0;\r\n\r\n    vec3 normalSampler = texture2D(u_NormalTexture, uv).xyz;\r\n    normalSampler = normalize(normalSampler * 2.0 - 1.0);\r\n    normalSampler.y *= -1.0;\r\n    vec3 normalTS = normalScale(normalSampler, u_NormalScale);\r\n    normalWS = normalize(pixel.TBN * normalTS);\r\n\r\n    #endif UV\r\n#endif // NORMALMAP\r\n\r\n    vec4 positionCS = v_PositionCS;\r\n\r\n    vec4 dephtNormal = encodeDepthNormal(positionCS, normalWS);\r\n\r\n    gl_FragColor = dephtNormal;\r\n}","import { AnimationClip } from \"../d3/animation/AnimationClip\";\r\nimport { KeyframeNode } from \"../d3/animation/KeyframeNode\";\r\nimport { KeyframeNodeList } from \"../d3/animation/KeyframeNodeList\";\r\nimport { Material, MaterialRenderMode } from \"../d3/core/material/Material\";\r\nimport { PBRStandardMaterial } from \"../d3/core/material/PBRStandardMaterial\";\r\nimport { Mesh, skinnedMatrixCache } from \"../d3/resource/models/Mesh\";\r\nimport { URL } from \"../net/URL\";\r\nimport { Texture2D, TextureConstructParams, TexturePropertyParams } from \"../resource/Texture2D\";\r\nimport * as glTF from \"./glTFInterface\";\r\n\r\nimport { ILaya } from \"../../ILaya\";\r\nimport { BufferUsage } from \"../RenderEngine/RenderEnum/BufferTargetType\";\r\nimport { HDREncodeFormat } from \"../RenderEngine/RenderEnum/HDREncodeFormat\";\r\nimport { IndexFormat } from \"../RenderEngine/RenderEnum/IndexFormat\";\r\nimport { RenderState } from \"../RenderEngine/RenderShader/RenderState\";\r\nimport { VertexMesh } from \"../RenderEngine/RenderShader/VertexMesh\";\r\nimport { VertexDeclaration } from \"../RenderEngine/VertexDeclaration\";\r\nimport { Animator } from \"../d3/component/Animator/Animator\";\r\nimport { AnimatorControllerLayer } from \"../d3/component/Animator/AnimatorControllerLayer\";\r\nimport { AnimatorState } from \"../d3/component/Animator/AnimatorState\";\r\nimport { FloatKeyframe } from \"../d3/core/FloatKeyframe\";\r\nimport { MeshFilter } from \"../d3/core/MeshFilter\";\r\nimport { MeshSprite3D } from \"../d3/core/MeshSprite3D\";\r\nimport { QuaternionKeyframe } from \"../d3/core/QuaternionKeyframe\";\r\nimport { SkinnedMeshRenderer } from \"../d3/core/SkinnedMeshRenderer\";\r\nimport { SkinnedMeshSprite3D } from \"../d3/core/SkinnedMeshSprite3D\";\r\nimport { Sprite3D } from \"../d3/core/Sprite3D\";\r\nimport { Vector3Keyframe } from \"../d3/core/Vector3Keyframe\";\r\nimport { IndexBuffer3D } from \"../d3/graphics/IndexBuffer3D\";\r\nimport { VertexBuffer3D } from \"../d3/graphics/VertexBuffer3D\";\r\nimport { MorphTarget, MorphTargetChannel } from \"../d3/resource/models/MorphTarget\";\r\nimport { MorphTargetData } from \"../d3/resource/models/MorphTargetData\";\r\nimport { SubMesh } from \"../d3/resource/models/SubMesh\";\r\nimport { Node } from \"../display/Node\";\r\nimport { Matrix4x4 } from \"../maths/Matrix4x4\";\r\nimport { Quaternion } from \"../maths/Quaternion\";\r\nimport { Vector3 } from \"../maths/Vector3\";\r\nimport { Vector4 } from \"../maths/Vector4\";\r\nimport { IBatchProgress } from \"../net/BatchProgress\";\r\nimport { Loader } from \"../net/Loader\";\r\nimport { Prefab } from \"../resource/HierarchyResource\";\r\nimport { Base64Tool } from \"../utils/Base64Tool\";\r\nimport { Byte } from \"../utils/Byte\";\r\nimport { glTFExtension } from \"./extensions/glTFExtension\";\r\nimport { glTFShader } from \"./shader/glTFShader\";\r\nimport { PBRShaderLib } from \"../d3/shader/pbr/PBRShaderLib\";\r\nimport { Laya } from \"../../Laya\";\r\nimport { WrapMode } from \"../RenderEngine/RenderEnum/WrapMode\";\r\nimport { ShaderDefine } from \"../RenderEngine/RenderShader/ShaderDefine\";\r\nimport { Laya3DRender } from \"../d3/RenderObjs/Laya3DRender\";\r\n\r\nconst maxSubBoneCount = 24;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class glTFResource extends Prefab {\r\n\r\n    private static _Extensions: { [name: string]: (resource: glTFResource) => glTFExtension } = {};\r\n\r\n    static registerExtension(name: string, factory: (resource: glTFResource) => glTFExtension) {\r\n        this._Extensions[name] = factory;\r\n    }\r\n\r\n    protected _data: glTF.glTF;\r\n\r\n    get data(): Readonly<glTF.glTF> {\r\n        return this._data;\r\n    }\r\n\r\n    protected _buffers: Record<string, ArrayBuffer>;\r\n    protected _textures: Texture2D[];\r\n    protected _materials: Material[];\r\n    protected _meshes: Record<string, Mesh>;\r\n\r\n    protected _extensions: Map<string, glTFExtension>;\r\n\r\n    protected _pendingOps: Array<Promise<any>>;\r\n\r\n    private _scenes: Array<Sprite3D>;\r\n    private _nodes: Array<Sprite3D>;\r\n\r\n    /** @internal */\r\n    private _idCounter: Record<string, number>;\r\n\r\n    constructor() {\r\n        super(3);\r\n\r\n        this._buffers = {};\r\n        this._textures = [];\r\n        this._materials = [];\r\n        this._meshes = {};\r\n        this._extensions = new Map();\r\n        this._pendingOps = [];\r\n        this._scenes = [];\r\n        this._nodes = [];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @param basePath \r\n     * @param progress \r\n     * @returns \r\n     */\r\n    loadBinary(basePath: string, progress?: IBatchProgress) {\r\n        let data = this._data;\r\n        if (data.buffers) {\r\n            let promises: Array<Promise<any>> = [];\r\n            data.buffers.forEach((buffer, i) => {\r\n                if (Base64Tool.isBase64String(buffer.uri)) {\r\n                    let bin = Base64Tool.decode(buffer.uri.replace(Base64Tool.reghead, \"\"));\r\n                    this._buffers[i] = bin;\r\n                }\r\n                else {\r\n                    let j = i;\r\n                    promises.push(ILaya.loader.fetch(URL.join(basePath, buffer.uri), \"arraybuffer\", progress?.createCallback(0.2))\r\n                        .then(bin => {\r\n                            this._buffers[j] = bin;\r\n                        }));\r\n                }\r\n            });\r\n            return Promise.all(promises);\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n\r\n    loadTextureFromInfo(info: glTF.glTFTextureInfo, sRGB: boolean, basePath: string, progress?: IBatchProgress): Promise<Texture2D> {\r\n        let data = this._data;\r\n\r\n        let index = info.index;\r\n        let tex = data.textures[index];\r\n        let imgSource = tex.source;\r\n        let glTFImg = data.images[imgSource];\r\n        let samplerSource = tex.sampler;\r\n        let glTFSampler = data.samplers ? data.samplers[samplerSource] : undefined;\r\n\r\n        let constructParams = this.getTextureConstructParams(glTFImg, glTFSampler, sRGB);\r\n        let propertyParams = this.getTexturePropertyParams(glTFSampler);\r\n\r\n        if (glTFImg.bufferView != null) {\r\n            let bufferView = data.bufferViews[glTFImg.bufferView];\r\n            let buffer = this._buffers[bufferView.buffer];\r\n            let byteOffset = bufferView.byteOffset || 0;\r\n            let byteLength = bufferView.byteLength;\r\n\r\n            let arraybuffer = buffer.slice(byteOffset, byteOffset + byteLength);\r\n\r\n            return this.loadTextureFromBuffer(arraybuffer, glTFImg.mimeType, constructParams, propertyParams, progress).then(res => {\r\n                this._textures[index] = res;\r\n                this.addDep(res);\r\n                return res;\r\n            });\r\n        }\r\n        else {\r\n            return this.loadTexture(URL.join(basePath, glTFImg.uri), constructParams, propertyParams, progress).then(res => {\r\n                this._textures[index] = res;\r\n                this.addDep(res);\r\n                return res;\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @param basePath \r\n     * @param progress \r\n     * @returns \r\n     */\r\n    loadTextures(basePath: string, progress?: IBatchProgress): Promise<any> {\r\n        let data = this._data;\r\n        let materials = data.materials;\r\n        let textures = data.textures;\r\n        let promises: Array<Promise<Texture2D> | Promise<Texture2D[]>> = [];\r\n        if (materials && textures) {\r\n            for (let glTFMaterial of data.materials) {\r\n                let pbrMetallicRoughness = glTFMaterial.pbrMetallicRoughness;\r\n                if (pbrMetallicRoughness) {\r\n                    if (pbrMetallicRoughness.baseColorTexture) {\r\n                        let sRGB = true;\r\n                        let promise = this.loadTextureFromInfo(pbrMetallicRoughness.baseColorTexture, sRGB, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                    if (pbrMetallicRoughness.metallicRoughnessTexture) {\r\n                        let sRGB = false;\r\n                        let promise = this.loadTextureFromInfo(pbrMetallicRoughness.metallicRoughnessTexture, sRGB, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                }\r\n                if (glTFMaterial.normalTexture) {\r\n                    let sRGB = false;\r\n                    let promise = this.loadTextureFromInfo(glTFMaterial.normalTexture, sRGB, basePath, progress);\r\n                    promises.push(promise);\r\n                }\r\n                if (glTFMaterial.occlusionTexture) {\r\n                    let sRGB = false;\r\n                    let promise = this.loadTextureFromInfo(glTFMaterial.occlusionTexture, sRGB, basePath, progress);\r\n                    promises.push(promise);\r\n                }\r\n                if (glTFMaterial.emissiveTexture) {\r\n                    let sRGB = true;\r\n                    let promise = this.loadTextureFromInfo(glTFMaterial.emissiveTexture, sRGB, basePath, progress);\r\n                    promises.push(promise);\r\n                }\r\n            }\r\n        }\r\n        this._extensions.forEach(extension => {\r\n            if (extension.loadAdditionTextures) {\r\n                let promise = extension.loadAdditionTextures(basePath, progress);\r\n                promises.push(promise);\r\n            }\r\n\r\n        });\r\n        return Promise.all(promises);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @returns \r\n     */\r\n    importMaterials() {\r\n        return Promise.resolve().then(() => {\r\n            let data = this._data;\r\n            if (data.materials) {\r\n                data.materials.forEach((glTFMat, index) => {\r\n                    let mat = this.createMaterial(glTFMat);\r\n                    this._materials[index++] = mat;\r\n                    this.addDep(mat);\r\n                })\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @returns \r\n     */\r\n    importMeshes() {\r\n        return Promise.resolve().then(() => {\r\n            let data = this._data;\r\n            if (data.meshes && data.nodes) {\r\n                data.nodes.forEach((glTFNode) => {\r\n                    if (glTFNode.mesh != null) {\r\n                        let glTFMesh = this._data.meshes[glTFNode.mesh];\r\n                        let glTFSkin = this._data.skins?.[glTFNode.skin];\r\n                        let key = glTFNode.mesh + (glTFNode.skin != null ? (\"_\" + glTFNode.skin) : \"\");\r\n                        let mesh = this._meshes[key];\r\n                        if (!mesh) {\r\n                            mesh = this.createMesh(glTFMesh, glTFSkin);\r\n                            this._meshes[key] = mesh;\r\n                            this.addDep(mesh);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @param data \r\n     * @param createURL \r\n     * @param progress \r\n     * @returns \r\n     */\r\n    _parse(data: glTF.glTF, createURL: string, progress?: IBatchProgress): Promise<void> {\r\n        if (!data.asset || data.asset.version !== \"2.0\") {\r\n            throw new Error(\"glTF version wrong!\");\r\n        }\r\n\r\n        this._data = data;\r\n        let basePath = URL.getPath(createURL);\r\n        this._idCounter = {};\r\n\r\n        data.extensionsUsed?.forEach(value => {\r\n            let extensionFactory = glTFResource._Extensions[value];\r\n            if (!extensionFactory) {\r\n                console.warn(`glTF: unsupported used extension: ${value}`);\r\n            }\r\n            else {\r\n                this._extensions.set(value, extensionFactory(this));\r\n            }\r\n        });\r\n\r\n        data.extensionsRequired?.forEach(value => {\r\n            let extensionFactory = glTFResource._Extensions[value];\r\n            if (!extensionFactory) {\r\n                console.warn(`glTF: unsupported required extension: ${value}`);\r\n            }\r\n        });\r\n\r\n        let promise: Promise<any> = this.loadBinary(basePath, progress);\r\n\r\n        promise = promise.then(() => {\r\n            return this.loadTextures(basePath, progress);\r\n        });\r\n\r\n        promise = promise.then(() => {\r\n            return this.importMeshes();\r\n        });\r\n\r\n        promise = promise.then(() => {\r\n            return this.importMaterials();\r\n        });\r\n\r\n        return promise.then(() => {\r\n            if (this._pendingOps.length > 0) {\r\n                return Promise.all(this._pendingOps).then(() => {\r\n                    this._idCounter = null;\r\n                });\r\n            }\r\n            else {\r\n                this._idCounter = null;\r\n                return Promise.resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param data \r\n     * @param createURL \r\n     * @param progress \r\n     */\r\n    _parseglb(data: ArrayBuffer, createURL: string, progress?: IBatchProgress): Promise<void> {\r\n        let basePath = URL.getPath(createURL);\r\n        // let promise: Promise<any>;\r\n        this._idCounter = {};\r\n\r\n        let byte = new Byte(data);\r\n        let magic = byte.readUint32();\r\n        //  ASCII string glTF\r\n        if (magic != 0x46546C67) {\r\n            throw new Error(\"glb fromat wrong!\");\r\n        }\r\n\r\n        let version = byte.readUint32();\r\n        if (version != 2) {\r\n            throw new Error(\"glb version wrong!\");\r\n        }\r\n\r\n        // total length of the Binary glTF, including header and all chunks, in bytes.\r\n        let length = byte.readUint32();\r\n\r\n        /**\r\n         * first chunk: json \r\n         * second chunk: buffer\r\n         * other chunk: ignore\r\n         */\r\n\r\n        // first chunk json\r\n        let firstChunkLength = byte.readUint32();\r\n        let firstChunkType = byte.readUint32();\r\n        if (firstChunkType != 0x4E4F534A) {\r\n            throw new Error(\"glb json chunk data wrong!\");\r\n        }\r\n\r\n        let firstChunkData = byte.readArrayBuffer(firstChunkLength);\r\n        let texDecoder = new TextDecoder();\r\n        let jsonStr = texDecoder.decode(firstChunkData);\r\n        let glTFObj: glTF.glTF = JSON.parse(jsonStr);\r\n        this._data = glTFObj;\r\n\r\n        // binary data json\r\n        let chunkLength = byte.readUint32();\r\n        let chunkType = byte.readUint32();\r\n        if (chunkType != 0x004E4942) {\r\n            throw new Error(\"glb bin chunk data wrong!\");\r\n        }\r\n        let firstBuffer = glTFObj.buffers?.[0];\r\n        firstBuffer.byteLength = firstBuffer.byteLength ? (Math.min(firstBuffer.byteLength, chunkLength)) : chunkLength;\r\n\r\n        this._buffers[0] = byte.readArrayBuffer(firstBuffer.byteLength);\r\n\r\n        glTFObj.extensionsUsed?.forEach(value => {\r\n            let extensionFactory = glTFResource._Extensions[value];\r\n            if (!extensionFactory) {\r\n                console.warn(`glTF: unsupported used extension: ${value}`);\r\n            }\r\n            else {\r\n                this._extensions.set(value, extensionFactory(this));\r\n            }\r\n            // this._extensions.sort((a, b) => )\r\n        });\r\n\r\n        glTFObj.extensionsRequired?.forEach(value => {\r\n            let extensionFactory = glTFResource._Extensions[value];\r\n            if (!extensionFactory) {\r\n                console.warn(`glTF: unsupported required extension: ${value}`);\r\n            }\r\n        });\r\n\r\n        let promise: Promise<any> = this.loadTextures(basePath, progress);\r\n        promise = promise.then(() => {\r\n            return this.importMeshes();\r\n        });\r\n\r\n        promise = promise.then(() => {\r\n            return this.importMaterials();\r\n        });\r\n\r\n        return promise.then(() => {\r\n            if (this._pendingOps.length > 0) {\r\n                return Promise.all(this._pendingOps).then(() => {\r\n                    this._idCounter = null;\r\n                });\r\n            }\r\n            else {\r\n                this._idCounter = null;\r\n                return Promise.resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    public create(): Node {\r\n        let data = this._data;\r\n\r\n        this._scenes.length = 0;\r\n        this._nodes.length = 0;\r\n        this._idCounter = {};\r\n\r\n        this.loadNodes(data.nodes);\r\n        this.buildHierarchy(data.nodes);\r\n        this.loadScenes(data.scenes);\r\n        this.loadAnimations(data.animations);\r\n\r\n        let defaultSceneIndex = (data.scene != undefined) ? data.scene : 0;\r\n        let defaultScene: Sprite3D = this._scenes[defaultSceneIndex];\r\n        this._scenes.length = 0;\r\n        this._nodes.length = 0;\r\n        this._idCounter = null;\r\n\r\n        return defaultScene;\r\n    }\r\n\r\n    protected loadTextureFromBuffer(buffer: ArrayBuffer, mimeType: glTF.glTFImageMimeType, constructParams: TextureConstructParams, propertyParams: TexturePropertyParams, progress?: IBatchProgress): Promise<Texture2D> {\r\n        let base64: string = Base64Tool.encode(buffer);\r\n        let url: string = `data:${mimeType};base64,${base64}`;\r\n\r\n        return ILaya.loader.load({ url: url, constructParams: constructParams, propertyParams: propertyParams },\r\n            Loader.TEXTURE2D, progress?.createCallback());\r\n    }\r\n\r\n    protected loadTexture(url: string, constructParams: TextureConstructParams, propertyParams: TexturePropertyParams, progress?: IBatchProgress): Promise<Texture2D> {\r\n        return ILaya.loader.load({ url: url, constructParams: constructParams, propertyParams: propertyParams },\r\n            Loader.TEXTURE2D, progress?.createCallback());\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 node name\r\n     */\r\n    protected generateId(context: string): string {\r\n        let i = this._idCounter[context];\r\n        if (i == null)\r\n            i = 0;\r\n        else\r\n            i++;\r\n        this._idCounter[context] = i;\r\n        return i.toString();\r\n    }\r\n\r\n    /**\r\n     * 根据数据类型获取分量\r\n     * @param type \r\n     */\r\n    private getAccessorComponentsNum(type: glTF.glTFAccessorType): number {\r\n        switch (type) {\r\n            case \"SCALAR\": return 1;\r\n            case \"VEC2\": return 2;\r\n            case \"VEC3\": return 3;\r\n            case \"VEC4\": return 4;\r\n            case \"MAT2\": return 4;\r\n            case \"MAT3\": return 9;\r\n            case \"MAT4\": return 16;\r\n            default: return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取 attribute 分量\r\n     * @param attriStr \r\n     */\r\n    private getAttributeNum(attriStr: string): number {\r\n        switch (attriStr) {\r\n            case \"POSITION\": return 3;\r\n            case \"NORMAL\": return 3;\r\n            case \"COLOR\": return 4;\r\n            case \"UV\": return 2;\r\n            case \"UV1\": return 2;\r\n            case \"BLENDWEIGHT\": return 4;\r\n            case \"BLENDINDICES\": return 4;\r\n            case \"TANGENT\": return 4;\r\n            default: return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 buffer constructor\r\n     * @param componentType \r\n     */\r\n    private _getTypedArrayConstructor(componentType: glTF.glTFAccessorComponentType) {\r\n        switch (componentType) {\r\n            case glTF.glTFAccessorComponentType.BYTE: return Int8Array;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_BYTE: return Uint8Array;\r\n            case glTF.glTFAccessorComponentType.SHORT: return Int16Array;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_SHORT: return Uint16Array;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_INT: return Uint32Array;\r\n            case glTF.glTFAccessorComponentType.FLOAT: return Float32Array;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 accessor data Type byte stride\r\n     * @param componentType \r\n     */\r\n    _getAccessorDateByteStride(componentType: glTF.glTFAccessorComponentType) {\r\n        switch (componentType) {\r\n            case glTF.glTFAccessorComponentType.BYTE: return 1;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_BYTE: return 1;\r\n            case glTF.glTFAccessorComponentType.SHORT: return 2;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_SHORT: return 2;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_INT: return 4;\r\n            case glTF.glTFAccessorComponentType.FLOAT: return 4;\r\n        }\r\n    }\r\n\r\n    private getBufferFormBufferView(bufferView: glTF.glTFBufferView, byteOffset: number, accessorType: glTF.glTFAccessorType, componentType: glTF.glTFAccessorComponentType, count: number) {\r\n        let buffer: ArrayBuffer = this._buffers[bufferView.buffer];\r\n\r\n        const constructor = this._getTypedArrayConstructor(componentType);\r\n        let componentCount: number = this.getAccessorComponentsNum(accessorType);\r\n        let res;\r\n        if (bufferView.byteStride) {\r\n            let vertexStride = bufferView.byteStride;\r\n            let dataByteStride = this._getAccessorDateByteStride(componentType);\r\n            let dataStride = vertexStride / dataByteStride;\r\n\r\n            let elementByteOffset = byteOffset || 0;\r\n            let elementOffset = elementByteOffset / dataByteStride;\r\n\r\n            // let d = new ArrayBuffer(dataStride * accessorDataCount);\r\n            let dataReader = new constructor(buffer, bufferView.byteOffset || 0, bufferView.byteLength / dataByteStride);\r\n            res = new constructor(count);\r\n            let resIndex = 0;\r\n            for (let index = 0; index < count; index++) {\r\n                let componentOffset = index * dataStride;\r\n                for (let i = 0; i < componentCount; i++) {\r\n                    res[resIndex++] = dataReader[componentOffset + elementOffset + i];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            let bufferOffset: number = (bufferView.byteOffset || 0) + (byteOffset || 0);\r\n            res = new constructor(buffer, bufferOffset, count);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * 获取 accessor buffer 数据\r\n     * @param accessorIndex \r\n     */\r\n    private getBufferwithAccessorIndex(accessorIndex: number) {\r\n        let accessor: glTF.glTFAccessor = this._data.accessors[accessorIndex];\r\n        if (!accessor)\r\n            return null;\r\n\r\n        let count: number = accessor.count;\r\n        let componentCount: number = this.getAccessorComponentsNum(accessor.type);\r\n        let accessorDataCount: number = count * componentCount;\r\n\r\n        let res;\r\n\r\n        let bufferView: glTF.glTFBufferView = this._data.bufferViews[accessor.bufferView];\r\n        if (bufferView) {\r\n            res = this.getBufferFormBufferView(bufferView, accessor.byteOffset, accessor.type, accessor.componentType, accessorDataCount);\r\n        }\r\n        else {\r\n            const constructor = this._getTypedArrayConstructor(accessor.componentType);\r\n            res = new constructor(accessorDataCount).fill(0);\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            let sparseCount = accessor.sparse.count;\r\n            let sparseIndices = accessor.sparse.indices;\r\n            let sparseIndicesBufferView = this._data.bufferViews[sparseIndices.bufferView];\r\n            let sparseIndicesData = this.getBufferFormBufferView(sparseIndicesBufferView, sparseIndices.byteOffset, accessor.type, sparseIndices.componentType, sparseCount);\r\n\r\n            let sparseValues = accessor.sparse.values;\r\n            let sparseValuesBufferView = this._data.bufferViews[sparseValues.bufferView];\r\n            let sparseValuesData = this.getBufferFormBufferView(sparseValuesBufferView, sparseValues.byteOffset, accessor.type, accessor.componentType, sparseCount * componentCount);\r\n\r\n            for (let index = 0; index < sparseCount; index++) {\r\n                let i = sparseIndicesData[index];\r\n                for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\r\n                    res[i * componentCount + componentIndex] = sparseValuesData[index * componentCount + componentIndex];\r\n                }\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * 判断 Texture 是否需要 mipmap\r\n     * @param glTFImage \r\n     * @param glTFSampler \r\n     */\r\n    private getTextureMipmap(glTFSampler: glTF.glTFSampler): boolean {\r\n        if (glTFSampler)\r\n            return glTFSampler.minFilter != glTF.glTFTextureMinFilter.LINEAR &&\r\n                glTFSampler.minFilter != glTF.glTFTextureMinFilter.NEAREST;\r\n        else\r\n            return true;\r\n    }\r\n\r\n    /**\r\n     * 获取 Texture format\r\n     * @param glTFImage \r\n     */\r\n    private getTextureFormat(glTFImage: glTF.glTFImage): number {\r\n        if (glTFImage.mimeType === glTF.glTFImageMimeType.JPEG) {\r\n            return 0;   // R8G8B8\r\n        }\r\n        else {\r\n            return 1;   // R8G8B8A8\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取 Texture filter mode\r\n     * @param glTFSampler \r\n     */\r\n    private getTextureFilterMode(glTFSampler: glTF.glTFSampler): number {\r\n\r\n        if (!glTFSampler) {\r\n            return 1;\r\n        }\r\n\r\n        if (glTFSampler.magFilter === glTF.glTFTextureMagFilter.NEAREST) {\r\n            return 0;   // FilterMode.Point\r\n        }\r\n        else if (this.getTextureMipmap(glTFSampler)) {\r\n            if (glTFSampler.minFilter === glTF.glTFTextureMinFilter.LINEAR_MIPMAP_LINEAR)\r\n                return 2;   // FilterMode.Trilinear\r\n\r\n            return 1;   // FilterMode.Bilinear\r\n        }\r\n\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * 获取 Texture warp mode\r\n     * @param mode \r\n     */\r\n    private getTextureWrapMode(mode: glTF.glTFTextureWrapMode): number {\r\n        mode = mode ?? glTF.glTFTextureWrapMode.REPEAT;\r\n        switch (mode) {\r\n            case glTF.glTFTextureWrapMode.REPEAT:\r\n                return WrapMode.Repeat;\r\n            case glTF.glTFTextureWrapMode.CLAMP_TO_EDGE:\r\n                return WrapMode.Clamp;\r\n            case glTF.glTFTextureWrapMode.MIRRORED_REPEAT:\r\n                return WrapMode.Mirrored;\r\n            default:\r\n                return WrapMode.Repeat;\r\n        }\r\n\r\n        if (mode === glTF.glTFTextureWrapMode.CLAMP_TO_EDGE) {\r\n            return 1;   // WrapMode.Clamp\r\n        }\r\n        return 0;   // WrapMode.Repeat\r\n    }\r\n\r\n    /**\r\n    * 获取 Texture 初始化参数\r\n    * @param glTFImage \r\n    * @param glTFSampler \r\n    */\r\n    private getTextureConstructParams(glTFImage: glTF.glTFImage, glTFSampler: glTF.glTFSampler, sRGB: boolean): ConstructorParameters<typeof Texture2D> {\r\n        let constructParams: ConstructorParameters<typeof Texture2D> = [\r\n            0, // width\r\n            0, // height\r\n            this.getTextureFormat(glTFImage), // format\r\n            this.getTextureMipmap(glTFSampler),  // mipmap\r\n            false, //can read\r\n            sRGB // sRGB\r\n\r\n        ];\r\n        return constructParams;\r\n    }\r\n\r\n    /**\r\n     * 获取 Texture 属性参数\r\n     * @param glTFImage \r\n     * @param glTFSampler \r\n     */\r\n    private getTexturePropertyParams(glTFSampler: glTF.glTFSampler): TexturePropertyParams {\r\n        if (!glTFSampler) {\r\n            return null;\r\n        }\r\n\r\n        let propertyParams: TexturePropertyParams = {\r\n            filterMode: this.getTextureFilterMode(glTFSampler),\r\n            wrapModeU: this.getTextureWrapMode(glTFSampler.wrapS),\r\n            wrapModeV: this.getTextureWrapMode(glTFSampler.wrapT),\r\n            anisoLevel: 1,\r\n            hdrEncodeFormat: HDREncodeFormat.NONE\r\n        };\r\n        return propertyParams;\r\n    }\r\n\r\n    /**\r\n     * 根据 glTFTextureInfo 获取 Texture2D\r\n     * @param glTFTextureInfo \r\n     */\r\n    getTextureWithInfo(glTFTextureInfo: glTF.glTFTextureInfo): Texture2D {\r\n        // uv 非 0 \r\n        if (glTFTextureInfo.texCoord) {\r\n            // todo 非0 uv \r\n            console.warn(\"glTF Loader: non 0 uv channel unsupported.\");\r\n        }\r\n\r\n        return this._textures[glTFTextureInfo.index];\r\n    }\r\n\r\n    getExtensionTextureInfo(info: glTF.glTFTextureInfo, extensionName: string): any {\r\n        let extension = this._extensions.get(extensionName);\r\n        if (info.extensions && info.extensions[extensionName] && extension) {\r\n            if (extension.loadExtensionTextureInfo) {\r\n                return extension.loadExtensionTextureInfo(info);\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param glTFMaterial \r\n     * @param material \r\n     */\r\n    applyMaterialRenderState(glTFMaterial: glTF.glTFMaterial, material: Material) {\r\n        // material render state\r\n        let renderMode: glTF.glTFMaterialAlphaMode = glTFMaterial.alphaMode || glTF.glTFMaterialAlphaMode.OPAQUE;\r\n        switch (renderMode) {\r\n            case glTF.glTFMaterialAlphaMode.OPAQUE: {\r\n                material.materialRenderMode = MaterialRenderMode.RENDERMODE_OPAQUE;\r\n                break;\r\n            }\r\n            case glTF.glTFMaterialAlphaMode.BLEND: {\r\n                material.materialRenderMode = MaterialRenderMode.RENDERMODE_TRANSPARENT;\r\n                break;\r\n            }\r\n            case glTF.glTFMaterialAlphaMode.MASK: {\r\n                material.materialRenderMode = MaterialRenderMode.RENDERMODE_CUTOUT;\r\n                break;\r\n            }\r\n            default: {\r\n                break;\r\n            }\r\n        }\r\n\r\n        material.alphaTestValue = glTFMaterial.alphaCutoff ?? 0.5;\r\n\r\n        if (glTFMaterial.doubleSided) {\r\n            material.cull = RenderState.CULL_NONE;\r\n        }\r\n\r\n    }\r\n\r\n    setMaterialTextureProperty(material: Material, texInfo: glTF.glTFTextureInfo, name: string, define: ShaderDefine, transformName: string, transformDefine: ShaderDefine) {\r\n        let tex = this.getTextureWithInfo(texInfo);\r\n        material.setTexture(name, tex);\r\n        if (define) {\r\n            material.setDefine(define, true);\r\n        }\r\n\r\n        // transform info\r\n        if (transformDefine) {\r\n            let transformInfo = this.getExtensionTextureInfo(texInfo, \"KHR_texture_transform\");\r\n            if (transformInfo) {\r\n                material.setDefine(transformDefine, true);\r\n                material.setMatrix3x3(transformName, transformInfo.transform);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param glTFMaterial \r\n     * @param material \r\n     */\r\n    applyDefaultMaterialProperties(glTFMaterial: glTF.glTFMaterial, material: Material) {\r\n        let pbrMetallicRoughness = glTFMaterial.pbrMetallicRoughness;\r\n        if (pbrMetallicRoughness) {\r\n            if (pbrMetallicRoughness.baseColorFactor) {\r\n                let baseColorFactor = material.getVector4(\"u_BaseColorFactor\");\r\n                baseColorFactor.fromArray(pbrMetallicRoughness.baseColorFactor);\r\n                material.setVector4(\"u_BaseColorFactor\", baseColorFactor);\r\n            }\r\n            if (pbrMetallicRoughness.baseColorTexture) {\r\n                this.setMaterialTextureProperty(material, pbrMetallicRoughness.baseColorTexture, \"u_BaseColorTexture\", glTFShader.Define_BaseColorMap, \"u_BaseColorMapTransform\", glTFShader.Define_BaseColorMapTransform);\r\n            }\r\n\r\n            let metallicFactor = pbrMetallicRoughness.metallicFactor ?? 1.0;\r\n            material.setFloat(\"u_MetallicFactor\", metallicFactor);\r\n\r\n            let roughnessFactor = pbrMetallicRoughness.roughnessFactor ?? 1.0;\r\n            material.setFloat(\"u_RoughnessFactor\", roughnessFactor);\r\n\r\n            if (pbrMetallicRoughness.metallicRoughnessTexture) {\r\n                this.setMaterialTextureProperty(material, pbrMetallicRoughness.metallicRoughnessTexture, \"u_MetallicRoughnessTexture\", glTFShader.Define_MetallicRoughnessMap, \"u_MetallicRoughnessMapTransform\", glTFShader.Define_MetallicRoughnessMapTransform);\r\n            }\r\n        }\r\n\r\n        if (glTFMaterial.normalTexture) {\r\n            this.setMaterialTextureProperty(material, glTFMaterial.normalTexture, \"u_NormalTexture\", glTFShader.Define_NormalMap, \"u_NormalMapTransform\", glTFShader.Define_NormalMapTransform);\r\n\r\n            let normalScale = glTFMaterial.normalTexture.scale ?? 1.0;\r\n            material.setFloat(\"u_NormalScale\", normalScale);\r\n        }\r\n\r\n        if (glTFMaterial.occlusionTexture) {\r\n            this.setMaterialTextureProperty(material, glTFMaterial.occlusionTexture, \"u_OcclusionTexture\", glTFShader.Define_OcclusionMap, \"u_OcclusionMapTransform\", glTFShader.Define_OcclusionMapTransform);\r\n\r\n            let strength = glTFMaterial.occlusionTexture.strength ?? 1.0;\r\n            material.setFloat(\"u_OcclusionStrength\", strength);\r\n        }\r\n\r\n        if (glTFMaterial.emissiveFactor) {\r\n            let emissionFactor = material.getVector3(\"u_EmissionFactor\");\r\n            emissionFactor.fromArray(glTFMaterial.emissiveFactor);\r\n            material.setVector3(\"u_EmissionFactor\", emissionFactor);\r\n            material.setDefine(PBRShaderLib.DEFINE_EMISSION, true);\r\n        }\r\n\r\n        if (glTFMaterial.emissiveTexture) {\r\n            material.setDefine(PBRShaderLib.DEFINE_EMISSION, true);\r\n\r\n            this.setMaterialTextureProperty(material, glTFMaterial.emissiveTexture, \"u_EmissionTexture\", glTFShader.Define_EmissionMap, \"u_EmissionMapTransform\", glTFShader.Define_EmissionMapTransform);\r\n        }\r\n\r\n        this.applyMaterialRenderState(glTFMaterial, material);\r\n\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * 根据 glTFMaterial 节点数据创建 default Material\r\n     * @param glTFMaterial \r\n     */\r\n    createDefaultMaterial(glTFMaterial: glTF.glTFMaterial): Material {\r\n        let material = new Material();\r\n        material.setShaderName(glTFShader.ShaderName);\r\n\r\n        // apply glTF Material property\r\n        material.name = glTFMaterial.name ? glTFMaterial.name : \"\";\r\n\r\n        this.applyDefaultMaterialProperties(glTFMaterial, material);\r\n\r\n        return material;\r\n    }\r\n\r\n    protected createMaterial(glTFMaterial: glTF.glTFMaterial) {\r\n        let mat: Material = null;\r\n        let propertiesExts = [];\r\n        for (const key in glTFMaterial.extensions) {\r\n            let extension = this._extensions.get(key);\r\n            if (extension) {\r\n                if (extension.createMaterial) {\r\n                    mat = extension.createMaterial(glTFMaterial);\r\n                }\r\n                if (extension.additionMaterialProperties) {\r\n                    propertiesExts.push(extension);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!mat) {\r\n            mat = this.createDefaultMaterial(glTFMaterial);\r\n        }\r\n        propertiesExts.forEach(extension => {\r\n            extension.additionMaterialProperties(glTFMaterial, mat);\r\n        });\r\n\r\n        return mat;\r\n    }\r\n\r\n    /**\r\n     * 获取 gltf mesh 中 material \r\n     * @param glTFMesh \r\n     */\r\n    private pickMeshMaterials(glTFMesh: glTF.glTFMesh): Material[] {\r\n        let materials: Material[] = [];\r\n\r\n        glTFMesh.primitives.forEach(primitive => {\r\n            if (primitive.material != undefined) {\r\n                let material: Material = this._materials[primitive.material];\r\n                materials.push(material);\r\n            }\r\n            else {\r\n                let material: Material = new PBRStandardMaterial();\r\n                materials.push(material);\r\n                this._materials.push(material);\r\n                primitive.material = this._materials.indexOf(material);\r\n            }\r\n        });\r\n\r\n        return materials;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载场景节点\r\n     * @param glTFScene \r\n     */\r\n    private loadScenes(glTFScenes?: glTF.glTFScene[]): void {\r\n        if (!glTFScenes)\r\n            return;\r\n\r\n        glTFScenes.forEach((glTFScene, index) => {\r\n            this._scenes[index] = this._loadScene(glTFScene);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载场景节点\r\n     * @param glTFScene \r\n     */\r\n    private _loadScene(glTFScene: glTF.glTFScene): Sprite3D {\r\n        // todo extension and extra\r\n\r\n        return this._createSceneNode(glTFScene);\r\n    }\r\n\r\n    /**\r\n     * 创建 glTFScene 节点\r\n     * @param glTFScene \r\n     */\r\n    private _createSceneNode(glTFScene: glTF.glTFScene): Sprite3D {\r\n        let glTFSceneNode: Sprite3D = new Sprite3D(glTFScene.name || \"Scene\");\r\n        glTFScene.nodes.forEach(nodeIndex => {\r\n            let sprite: Sprite3D = this._nodes[nodeIndex];\r\n            glTFSceneNode.addChild(sprite);\r\n        });\r\n\r\n        return glTFSceneNode;\r\n    }\r\n\r\n    /**\r\n     * 应用 Transform 信息\r\n     * @param glTFNode \r\n     * @param sprite \r\n     */\r\n    private applyTransform(glTFNode: glTF.glTFNode, sprite: Sprite3D): void {\r\n        if (glTFNode.matrix) {\r\n            let localMatrix: Matrix4x4 = sprite.transform.localMatrix;\r\n            localMatrix.elements.set(glTFNode.matrix);\r\n            sprite.transform.localMatrix = localMatrix;\r\n        }\r\n        else {\r\n            let localPosition: Vector3 = sprite.transform.localPosition;\r\n            let localRotation: Quaternion = sprite.transform.localRotation;\r\n            let localScale: Vector3 = sprite.transform.localScale;\r\n            glTFNode.translation && localPosition.fromArray(glTFNode.translation);\r\n            glTFNode.rotation && localRotation.fromArray(glTFNode.rotation);\r\n            glTFNode.scale && localScale.fromArray(glTFNode.scale);\r\n            sprite.transform.localPosition = localPosition;\r\n            sprite.transform.localRotation = localRotation;\r\n            sprite.transform.localScale = localScale;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 构建 当前 glTF 对象 节点树\r\n     * @param glTFNodes \r\n     */\r\n    private buildHierarchy(glTFNodes: glTF.glTFNode[]): void {\r\n        glTFNodes.forEach((glTFNode: glTF.glTFNode, index: number) => {\r\n            let sprite: Sprite3D = this._nodes[index];\r\n            if (glTFNode.children) {\r\n                glTFNode.children.forEach((childIndex: number) => {\r\n                    let child: Sprite3D = this._nodes[childIndex];\r\n                    sprite.addChild(child);\r\n                });\r\n            }\r\n        });\r\n\r\n        glTFNodes.forEach((glTFNode: glTF.glTFNode, index: number) => {\r\n            let sprite: Sprite3D = this._nodes[index];\r\n            if (sprite instanceof SkinnedMeshSprite3D) {\r\n                this.fixSkinnedSprite(glTFNode, sprite);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载 glTF 节点\r\n     * @param glTFNodes \r\n     */\r\n    private loadNodes(glTFNodes?: glTF.glTFNode[]): void {\r\n        if (!glTFNodes)\r\n            return;\r\n\r\n        glTFNodes.forEach((glTFNode: glTF.glTFNode, index: number) => {\r\n            this._nodes[index] = this.loadNode(glTFNode);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载 glTF 节点\r\n     * @param glTFNode \r\n     */\r\n    private loadNode(glTFNode: glTF.glTFNode): Sprite3D {\r\n        // todo extension and extra\r\n\r\n        return this.createSprite3D(glTFNode);\r\n    }\r\n\r\n    /**\r\n     * 创建 节点对象\r\n     * @param glTFNode \r\n     */\r\n    private createSprite3D(glTFNode: glTF.glTFNode): Sprite3D {\r\n        let sprite: Sprite3D;\r\n        if (glTFNode.skin != null) {\r\n            sprite = this.createSkinnedMeshSprite3D(glTFNode);\r\n            this.applyTransform(glTFNode, sprite);\r\n        }\r\n        else if (glTFNode.mesh != null) {\r\n            sprite = this.createMeshSprite3D(glTFNode);\r\n            this.applyTransform(glTFNode, sprite);\r\n        }\r\n        else {\r\n            sprite = new Sprite3D(glTFNode.name);\r\n            this.applyTransform(glTFNode, sprite);\r\n        }\r\n\r\n        let storeId = this.generateId(\"node\");\r\n        sprite.name = glTFNode.name || `node_${storeId}`;\r\n        (<any>sprite._extra).storeId = \"#\" + storeId;\r\n\r\n        return sprite;\r\n    }\r\n\r\n    /**\r\n     * 创建 MeshSprite3D 对象\r\n     * @param glTFNode \r\n     */\r\n    private createMeshSprite3D(glTFNode: glTF.glTFNode): MeshSprite3D {\r\n        let glTFMesh: glTF.glTFMesh = this._data.meshes[glTFNode.mesh];\r\n        let mesh = this._meshes[glTFNode.mesh];\r\n        let materials: Material[] = this.pickMeshMaterials(glTFMesh);\r\n        let sprite: MeshSprite3D = new MeshSprite3D(mesh, glTFNode.name);\r\n        sprite.meshRenderer.sharedMaterials = materials;\r\n        sprite.meshRenderer.receiveShadow = true;\r\n        sprite.meshRenderer.castShadow = true;\r\n\r\n        if (glTFMesh.weights) {\r\n            let render = sprite.meshRenderer;\r\n            glTFMesh.weights.forEach((weight, index) => {\r\n                let target = mesh.morphTargetData.getMorphChannelbyIndex(index);\r\n                render.setMorphChannelWeight(target.name, weight);\r\n            });\r\n        }\r\n\r\n        return sprite;\r\n    }\r\n\r\n    /**\r\n     * 创建 MeshSprite3D 对象\r\n     * @param glTFNode \r\n     */\r\n    private createSkinnedMeshSprite3D(glTFNode: glTF.glTFNode): SkinnedMeshSprite3D {\r\n        let glTFMesh: glTF.glTFMesh = this._data.meshes[glTFNode.mesh];\r\n        let mesh: Mesh = this._meshes[glTFNode.mesh + \"_\" + glTFNode.skin];\r\n        let materials: Material[] = this.pickMeshMaterials(glTFMesh);\r\n        let sprite: SkinnedMeshSprite3D = new SkinnedMeshSprite3D(mesh, glTFNode.name);\r\n        sprite.skinnedMeshRenderer.sharedMaterials = materials;\r\n        sprite.skinnedMeshRenderer.receiveShadow = true;\r\n        sprite.skinnedMeshRenderer.castShadow = true;\r\n\r\n        if (glTFMesh.weights) {\r\n            let render = sprite.skinnedMeshRenderer;\r\n            glTFMesh.weights.forEach((weight, index) => {\r\n                let target = mesh.morphTargetData.getMorphChannelbyIndex(index);\r\n                render.setMorphChannelWeight(target.name, weight);\r\n            });\r\n        }\r\n\r\n        return sprite;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 attribute buffer 数据\r\n     * @param attributeAccessorIndex \r\n     * @param layaDeclarStr \r\n     * @param attributes \r\n     * @param vertexDeclarArr \r\n     * @param func \r\n     */\r\n    private getArrributeBuffer(attributeAccessorIndex: number, layaDeclarStr: string, attributeMap: Map<string, Float32Array>, vertexDeclarArr: string[]): Float32Array {\r\n        let attributeBuffer: Float32Array = <Float32Array>this.getBufferwithAccessorIndex(attributeAccessorIndex);\r\n        if (!attributeBuffer)\r\n            return null;\r\n        vertexDeclarArr.push(layaDeclarStr);\r\n        let res: Float32Array = attributeBuffer;\r\n        attributeMap.set(layaDeclarStr, res);\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 glTFMeshPrimitive index buffer\r\n     * @param attributeAccessorIndex \r\n     * @param vertexCount \r\n     */\r\n    private getIndexBuffer(attributeAccessorIndex: number, vertexCount: number): Uint32Array {\r\n        let indexBuffer: Uint32Array = <Uint32Array>this.getBufferwithAccessorIndex(attributeAccessorIndex);\r\n        if (indexBuffer) {\r\n            return new Uint32Array(indexBuffer).reverse();\r\n            // return indexBuffer;\r\n        }\r\n        else {\r\n            let indices: Uint32Array = new Uint32Array(vertexCount);\r\n            for (let i = 0; i < vertexCount; i++) {\r\n                indices[i] = vertexCount - 1 - i;\r\n            }\r\n            return indices;\r\n        }\r\n    }\r\n\r\n    private calculateFlatNormal(positions: Float32Array, indexArray: Uint32Array): Float32Array {\r\n        let normal = new Float32Array(positions.length);\r\n\r\n        for (let index = 0; index < indexArray.length; index += 3) {\r\n            // todo\r\n            let i0 = indexArray[index];\r\n            let i1 = indexArray[index + 1];\r\n            let i2 = indexArray[index + 2];\r\n\r\n            let p0x = positions[i0 * 3];\r\n            let p0y = positions[i0 * 3 + 1];\r\n            let p0z = positions[i0 * 3 + 2];\r\n\r\n            let p1x = positions[i1 * 3];\r\n            let p1y = positions[i1 * 3 + 1];\r\n            let p1z = positions[i1 * 3 + 2];\r\n\r\n            let p2x = positions[i2 * 3];\r\n            let p2y = positions[i2 * 3 + 1];\r\n            let p2z = positions[i2 * 3 + 2];\r\n\r\n            let x1 = p1x - p0x;\r\n            let y1 = p1y - p0y;\r\n            let z1 = p1z - p0z;\r\n\r\n            let x2 = p2x - p0x;\r\n            let y2 = p2y - p0y;\r\n            let z2 = p2z - p0z;\r\n\r\n            let yz = y1 * z2 - z1 * y2;\r\n            let xz = z1 * x2 - x1 * z2;\r\n            let xy = x1 * y2 - y1 * x2;\r\n\r\n            let invPyth = -1.0 / (Math.sqrt((yz * yz) + (xz * xz) + (xy * xy)));\r\n            let nx = yz * invPyth;\r\n            let ny = xz * invPyth;\r\n            let nz = xy * invPyth;\r\n\r\n            normal[i0 * 3] = nx;\r\n            normal[i1 * 3] = nx;\r\n            normal[i2 * 3] = nx;\r\n\r\n            normal[i0 * 3 + 1] = ny;\r\n            normal[i1 * 3 + 1] = ny;\r\n            normal[i2 * 3 + 1] = ny;\r\n\r\n            normal[i0 * 3 + 2] = nz;\r\n            normal[i1 * 3 + 2] = nz;\r\n            normal[i2 * 3 + 2] = nz;\r\n        }\r\n\r\n        return normal;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 解析 subData 记录数据\r\n     * @param subDatas \r\n     * @param layaMesh \r\n     */\r\n    private parseMeshwithSubMeshData(subDatas: PrimitiveSubMesh[], layaMesh: Mesh): void {\r\n        let vertexCount: number = 0;\r\n        let indexCount: number = 0;\r\n        let vertexDecler: string = undefined;\r\n        subDatas.forEach(subData => {\r\n            vertexCount += subData.vertexCount;\r\n            indexCount += subData.indices.length;\r\n\r\n            vertexDecler = vertexDecler || subData.vertexDecler;\r\n        });\r\n\r\n        let vertexDeclaration: VertexDeclaration = VertexMesh.getVertexDeclaration(vertexDecler, false);\r\n        let vertexByteStride: number = vertexDeclaration.vertexStride;\r\n        let vertexFloatStride: number = vertexByteStride / 4;\r\n\r\n        let vertexArray: Float32Array = new Float32Array(vertexFloatStride * vertexCount);\r\n        let indexArray: Uint16Array | Uint32Array;\r\n        let ibFormat: IndexFormat = IndexFormat.UInt32;\r\n        if (vertexCount < 65536) {\r\n            indexArray = new Uint16Array(indexCount);\r\n            ibFormat = IndexFormat.UInt16;\r\n        }\r\n        else {\r\n            indexArray = new Uint32Array(indexCount);\r\n        }\r\n\r\n        this.fillMeshBuffers(subDatas, vertexArray, indexArray, vertexFloatStride);\r\n        this.generateMesh(vertexArray, indexArray, vertexDeclaration, ibFormat, subDatas, layaMesh);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 填充 mesh buffer 数据\r\n     * @param subDatas \r\n     * @param vertexArray \r\n     * @param indexArray \r\n     * @param vertexFloatStride \r\n     */\r\n    private fillMeshBuffers(subDatas: PrimitiveSubMesh[], vertexArray: Float32Array, indexArray: Uint16Array | Uint32Array, vertexFloatStride: number) {\r\n        let ibPosOffset: number = 0;\r\n        let ibVertexOffset: number = 0;\r\n        let vbPosOffset: number = 0;\r\n        subDatas.forEach((subData) => {\r\n\r\n            let iAOffset: number = ibPosOffset;\r\n\r\n            let vertexCount: number = subData.vertexCount;\r\n\r\n            let subIb: Uint32Array = subData.indices;\r\n            for (let index = 0; index < subIb.length; index++) {\r\n                indexArray[iAOffset + index] = subIb[index] + ibVertexOffset;\r\n            }\r\n            ibPosOffset += subIb.length;\r\n            ibVertexOffset += vertexCount;\r\n\r\n            const fillAttributeBuffer = (value: Float32Array, attriOffset: number, attriFloatCount: number = 0) => {\r\n                let startOffset: number = vbPosOffset + attriOffset;\r\n                for (let index = 0; index < vertexCount; index++) {\r\n                    for (let ac = 0; ac < attriFloatCount; ac++) {\r\n                        vertexArray[startOffset + index * vertexFloatStride + ac] = value[index * attriFloatCount + ac];\r\n                    }\r\n                }\r\n            };\r\n\r\n            let attriOffset: number = 0;\r\n            let attributeMap: Map<string, Float32Array> = subData.attributeMap;\r\n            let position: Float32Array = attributeMap.get(\"POSITION\");\r\n            (position) && (fillAttributeBuffer(position, attriOffset, 3), attriOffset += 3);\r\n            let normal: Float32Array = attributeMap.get(\"NORMAL\");\r\n            (normal) && (fillAttributeBuffer(normal, attriOffset, 3), attriOffset += 3);\r\n            let color: Float32Array = attributeMap.get(\"COLOR\");\r\n            (color) && (fillAttributeBuffer(color, attriOffset, 4), attriOffset += 4);\r\n            let uv: Float32Array = attributeMap.get(\"UV\");\r\n            (uv) && (fillAttributeBuffer(uv, attriOffset, 2), attriOffset += 2);\r\n            let uv1: Float32Array = attributeMap.get(\"UV1\");\r\n            (uv1) && (fillAttributeBuffer(uv1, attriOffset, 2), attriOffset += 2);\r\n            let blendWeight: Float32Array = attributeMap.get(\"BLENDWEIGHT\");\r\n            (blendWeight) && (fillAttributeBuffer(blendWeight, attriOffset, 4), attriOffset += 4);\r\n            let blendIndices: Float32Array = attributeMap.get(\"BLENDINDICES\");\r\n            if (blendIndices) {\r\n                let blendIndicesUint8: Uint8Array = new Uint8Array(blendIndices);\r\n                let blendIndicesFloat32: Float32Array = new Float32Array(blendIndicesUint8.buffer);\r\n                fillAttributeBuffer(blendIndicesFloat32, attriOffset, 1), attriOffset += 1;\r\n            }\r\n            let tangent: Float32Array = attributeMap.get(\"TANGENT\");\r\n            (tangent) && (fillAttributeBuffer(tangent, attriOffset, 4), attriOffset += 4);\r\n\r\n            vbPosOffset += vertexCount * vertexFloatStride;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 根据 单次提交最大骨骼数量 划分 submesh 提交队列\r\n     * @param attributeMap \r\n     * @param indexArray \r\n     * @param boneIndicesList \r\n     * @param subIndexStartArray \r\n     * @param subIndexCountArray \r\n     */\r\n    private splitSubMeshByBonesCount(attributeMap: Map<string, Float32Array>, morphtargets: SubMorphData, indexArray: Uint32Array, boneIndicesList: Array<Uint16Array>, subIndexStartArray: number[], subIndexCountArray: number[]): void {\r\n        let start: number = 0;\r\n        let subIndexSet: Set<number> = new Set();\r\n        let boneIndexArray: Float32Array = attributeMap.get(\"BLENDINDICES\");\r\n\r\n        let vertexCount: number = boneIndexArray.length / 4;\r\n\r\n        let resArray: Float32Array = new Float32Array(boneIndexArray.length);\r\n\r\n        let flagArray: Array<boolean> = new Array(vertexCount).fill(false);\r\n\r\n        // 遍历 ib\r\n        for (let i: number = 0, n: number = indexArray.length; i < n; i += 3) {\r\n            // 每三个顶点 一个三角形 一起判断\r\n            // 三个顶点 ，12 个 bone index\r\n            let triangleSet: Set<number> = new Set();\r\n            for (let j: number = i; j < i + 3; j++) {\r\n                let ibIndex: number = indexArray[j];\r\n                let boneIndexOffset: number = ibIndex * 4;\r\n                for (let k: number = 0; k < 4; k++) {\r\n                    triangleSet.add(boneIndexArray[boneIndexOffset + k]);\r\n                }\r\n            }\r\n            // 判断当前\r\n            let tempSet: Set<number> = new Set([...subIndexSet, ...triangleSet]);\r\n            if (tempSet.size > maxSubBoneCount) {\r\n                // 当前批次不能加 添加 下一三角形\r\n                // 保存当前数据\r\n                let count: number = i - start;\r\n                subIndexStartArray.push(start);\r\n                subIndexCountArray.push(count);\r\n\r\n                let curBoneList: number[] = Array.from(subIndexSet);\r\n                boneIndicesList.push(new Uint16Array(curBoneList));\r\n                // 更新 起始位置\r\n                start = i;\r\n                // 新建数据集， 添加未能添加到上一个节点的数据\r\n                subIndexSet = new Set(triangleSet);\r\n            }\r\n            else {\r\n                // 添加数据 到当前数据集\r\n                subIndexSet = tempSet;\r\n            }\r\n            // 结尾 添加剩余数据\r\n            if (i == n - 3) {\r\n                let count: number = i - start + 3;\r\n                subIndexStartArray.push(start);\r\n                subIndexCountArray.push(count);\r\n                start = i;\r\n                let curBoneList: number[] = Array.from(subIndexSet);\r\n                boneIndicesList.push(new Uint16Array(curBoneList));\r\n            }\r\n        }\r\n\r\n        //根据分离出的范围 更改 biarray\r\n        let drawCount: number = boneIndicesList.length;\r\n        let newAttributeMap: Map<string, Array<number>> = new Map();\r\n        attributeMap.forEach((value, key) => {\r\n            let array: Array<number> = new Array();\r\n            newAttributeMap.set(key, array);\r\n        });\r\n\r\n        let newTargetMap: { [name: string]: Map<string, Array<number>> } = {};\r\n        for (const key in morphtargets.targets) {\r\n            let newMap = newTargetMap[key] = new Map();\r\n\r\n            let target = morphtargets.targets[key];\r\n            target.forEach((value, attri) => {\r\n                newMap.set(attri, new Array<number>());\r\n            });\r\n        }\r\n\r\n        let curMaxIndex: number = vertexCount - 1;\r\n        for (let d: number = 0; d < drawCount; d++) {\r\n            let k: number = subIndexStartArray[d];\r\n            let l: number = subIndexCountArray[d];\r\n            let bl: Uint16Array = boneIndicesList[d];\r\n\r\n            let batchFlag: Array<boolean> = new Array(vertexCount).fill(false);\r\n            let batchMap: Map<number, number> = new Map();\r\n            for (let area: number = 0; area < l; area++) {\r\n                let ci: number = indexArray[area + k];\r\n                let biStart: number = 4 * ci;\r\n                for (let cbi: number = biStart; cbi < biStart + 4; cbi++) {\r\n                    let oldBoneIndex: number = boneIndexArray[cbi];\r\n                    let newBoneIndex: number = bl.indexOf(oldBoneIndex);\r\n                    newBoneIndex = newBoneIndex == -1 ? 0 : newBoneIndex;\r\n                    // 其他batch 出现， 此batch 未出现 新增点数据\r\n                    if (flagArray[ci] && !batchFlag[ci]) {\r\n                        newAttributeMap.get(\"BLENDINDICES\").push(newBoneIndex);\r\n                    }\r\n                    // 其他batch 出现， 此batch 出现, 修改过 跳过\r\n                    else if (flagArray[ci] && batchFlag[ci]) {\r\n\r\n                    }\r\n                    else {\r\n                        resArray[cbi] = newBoneIndex;\r\n                    }\r\n                }\r\n                // 其他batch 未出现， 此batch 未出现 不处理\r\n                if (!flagArray[ci] && !batchFlag[ci]) {\r\n                    batchFlag[ci] = true;\r\n                    batchMap.set(ci, ci);\r\n                }\r\n                // 其他btach 未出现， 此batch 已经出现 index 改为上次更新index\r\n                else if (!flagArray[ci] && batchFlag[ci]) {\r\n                    indexArray[area + k] = batchMap.get(ci);\r\n                }\r\n                //其他batch 出现， 此batch 未出现 新增点数据  更新index\r\n                else if (flagArray[ci] && !batchFlag[ci]) {\r\n                    batchFlag[ci] = true;\r\n                    curMaxIndex++;\r\n                    batchMap.set(ci, curMaxIndex);\r\n                    indexArray[area + k] = curMaxIndex;\r\n                    newAttributeMap.forEach((value: number[], key: string) => {\r\n                        let attOffset: number = this.getAttributeNum(key);\r\n                        let oldArray: Float32Array = attributeMap.get(key);\r\n                        if (key !== \"BLENDINDICES\") {\r\n                            for (let index = 0; index < attOffset; index++) {\r\n                                value.push(oldArray[index + ci * attOffset]);\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                    for (const key in newTargetMap) {\r\n                        let newMap = newTargetMap[key];\r\n                        let oldMap = morphtargets.targets[key];\r\n                        newMap.forEach((value, attri) => {\r\n                            let attOffset = this.getAttributeNum(attri);\r\n                            let oldArray = oldMap.get(attri);\r\n\r\n                            for (let index = 0; index < attOffset; index++) {\r\n                                value.push(oldArray[index + ci * attOffset]);\r\n                            }\r\n\r\n                        });\r\n                    }\r\n\r\n\r\n                }\r\n                //其他batch 出现， 此batch 出现\r\n                else if (flagArray[ci] && batchFlag[ci]) {\r\n                    indexArray[area + k] = batchMap.get(ci);\r\n                }\r\n            }\r\n            // 将此batch 出现的index更新到flagarray\r\n            batchFlag.forEach((value, index) => {\r\n                flagArray[index] = value || flagArray[index];\r\n            });\r\n        }\r\n\r\n        newAttributeMap.forEach((value: number[], key: string) => {\r\n            let oldFloatArray: Float32Array = attributeMap.get(key);\r\n            if (key == \"BLENDINDICES\") {\r\n                oldFloatArray = resArray;\r\n            }\r\n            let newLength: number = oldFloatArray.length + value.length;\r\n            let newFloatArray: Float32Array = new Float32Array(newLength);\r\n            newFloatArray.set(oldFloatArray, 0);\r\n            newFloatArray.set(value, oldFloatArray.length);\r\n            attributeMap.set(key, newFloatArray);\r\n        });\r\n\r\n        for (const key in newTargetMap) {\r\n            let newMap = newTargetMap[key];\r\n            let oldMap = morphtargets.targets[key];\r\n\r\n            newMap.forEach((value, attri) => {\r\n                let oldArray = oldMap.get(attri);\r\n                let newLength = value.length + oldArray.length;\r\n\r\n                let newFloatArray = new Float32Array(newLength);\r\n                newFloatArray.set(oldArray, 0);\r\n                newFloatArray.set(value, oldArray.length);\r\n                oldMap.set(attri, newFloatArray);\r\n            });\r\n        }\r\n\r\n        boneIndexArray = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 生成 mesh\r\n     * @param vertexArray \r\n     * @param indexArray \r\n     * @param vertexDeclaration \r\n     * @param ibFormat \r\n     * @param subDatas \r\n     * @param layaMesh \r\n     */\r\n    private generateMesh(vertexArray: Float32Array, indexArray: Uint16Array | Uint32Array, vertexDeclaration: VertexDeclaration, ibFormat: IndexFormat, subDatas: PrimitiveSubMesh[], layaMesh: Mesh): void {\r\n        let vertexBuffer: VertexBuffer3D = Laya3DRender.renderOBJCreate.createVertexBuffer3D(vertexArray.byteLength, BufferUsage.Static, true);\r\n        vertexBuffer.vertexDeclaration = vertexDeclaration;\r\n        vertexBuffer.setData(vertexArray.buffer);\r\n\r\n        let indexBuffer: IndexBuffer3D = Laya3DRender.renderOBJCreate.createIndexBuffer3D(ibFormat, indexArray.length, BufferUsage.Static, true);\r\n        indexBuffer.setData(indexArray);\r\n\r\n        layaMesh._indexFormat = ibFormat;\r\n        layaMesh._indexBuffer = indexBuffer;\r\n        layaMesh._vertexBuffer = vertexBuffer;\r\n        layaMesh._setBuffer(vertexBuffer, indexBuffer);\r\n        layaMesh._vertexCount = vertexBuffer._byteLength / vertexDeclaration.vertexStride;\r\n\r\n        let reCalculateBounds = false;\r\n        let min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        let max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        // subMesh\r\n        let subMeshOffset: number = 0;\r\n        let subMeshCount: number = subDatas.length;\r\n        let subMeshes: SubMesh[] = new Array<SubMesh>(subMeshCount);\r\n        for (let index = 0; index < subMeshCount; index++) {\r\n            let subData: PrimitiveSubMesh = subDatas[index];\r\n\r\n            let subMesh: SubMesh = new SubMesh(layaMesh);\r\n            subMeshes[index] = subMesh;\r\n\r\n            subMesh._vertexBuffer = vertexBuffer;\r\n            subMesh._indexBuffer = indexBuffer;\r\n\r\n            let subIndexStart: number = subMeshOffset;\r\n            subMeshOffset += subData.indices.length;\r\n            let subIndexCount: number = subData.indices.length;\r\n            subMesh._setIndexRange(subIndexStart, subIndexCount, ibFormat);\r\n\r\n            subMesh._boneIndicesList = subData.boneIndicesList;\r\n            subMesh._subIndexBufferStart = subData.subIndexStartArray;\r\n            subMesh._subIndexBufferCount = subData.subIndexCountArray;\r\n\r\n            for (let subIndex = 0; subIndex < subMesh._subIndexBufferStart.length; subIndex++) {\r\n                subMesh._subIndexBufferStart[subIndex] += subIndexStart;\r\n            }\r\n\r\n            if (subData.boundMax && subData.boundMin) {\r\n                min.x = Math.min(subData.boundMin[0], min.x);\r\n                min.y = Math.min(subData.boundMin[1], min.y);\r\n                min.z = Math.min(subData.boundMin[2], min.z);\r\n\r\n                max.x = Math.max(subData.boundMax[0], max.x);\r\n                max.y = Math.max(subData.boundMax[1], max.y);\r\n                max.z = Math.max(subData.boundMax[2], max.z);\r\n            }\r\n            else {\r\n                reCalculateBounds = true;\r\n            }\r\n        }\r\n\r\n        layaMesh._setSubMeshes(subMeshes);\r\n        if (reCalculateBounds) {\r\n            layaMesh.calculateBounds();\r\n        }\r\n        else {\r\n            layaMesh.bounds.setMin(min);\r\n            layaMesh.bounds.setMax(max);\r\n        }\r\n\r\n        //layaMesh._setInstanceBuffer(Mesh.MESH_INSTANCEBUFFER_TYPE_NORMAL);\r\n\r\n        // 资源面板\r\n        // todo mesh.read = flase ? \r\n        let memorySize: number = vertexBuffer._byteLength + indexBuffer._byteLength;\r\n        layaMesh._setCPUMemory(memorySize);\r\n        layaMesh._setGPUMemory(memorySize);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * mesh 应用蒙皮数据\r\n     * @param mesh \r\n     * @param glTFSkin \r\n     */\r\n    private applyglTFSkinData(mesh: Mesh, subDatas: PrimitiveSubMesh[], glTFSkin?: glTF.glTFSkin): void {\r\n        if (!glTFSkin)\r\n            return;\r\n\r\n        let joints: number[] = glTFSkin.joints;\r\n\r\n        let inverseBindMatricesArray: Float32Array = new Float32Array(this.getBufferwithAccessorIndex(glTFSkin.inverseBindMatrices));\r\n\r\n        let boneCount: number = joints.length;\r\n        let boneNames: string[] = mesh._boneNames = [];\r\n        joints.forEach(nodeIndex => {\r\n            let node: glTF.glTFNode = this._data.nodes[nodeIndex];\r\n            boneNames.push(node.name);\r\n        })\r\n\r\n        mesh._inverseBindPoses = [];\r\n        mesh._inverseBindPosesBuffer = inverseBindMatricesArray.buffer;\r\n        for (let index = 0; index < boneCount; index++) {\r\n            let bindPosesArrayOffset: number = 16 * index;\r\n            let matElement: Float32Array = inverseBindMatricesArray.slice(bindPosesArrayOffset, bindPosesArrayOffset + 16);\r\n            mesh._inverseBindPoses[index] = new Matrix4x4(\r\n                matElement[0], matElement[1], matElement[2], matElement[3],\r\n                matElement[4], matElement[5], matElement[6], matElement[7],\r\n                matElement[8], matElement[9], matElement[10], matElement[11],\r\n                matElement[12], matElement[13], matElement[14], matElement[15],\r\n                matElement\r\n            );\r\n        }\r\n\r\n        let subCount: number = subDatas.length;\r\n        let skinnedCache: skinnedMatrixCache[] = mesh._skinnedMatrixCaches;\r\n        skinnedCache.length = mesh._inverseBindPoses.length;\r\n        for (let subIndex: number = 0; subIndex < subCount; subIndex++) {\r\n            let submesh: SubMesh = mesh.getSubMesh(subIndex);\r\n            let drawCount: number = submesh._subIndexBufferStart.length;\r\n            for (let drawIndex: number = 0; drawIndex < drawCount; drawIndex++) {\r\n                let boneIndices: Uint16Array = submesh._boneIndicesList[drawIndex];\r\n                for (let bni: number = 0; bni < boneIndices.length; bni++) {\r\n                    let bn: number = boneIndices[bni];\r\n                    skinnedCache[bn] || (skinnedCache[bn] = new skinnedMatrixCache(subIndex, drawIndex, bni));\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let index = 0; index < skinnedCache.length; index++) {\r\n            if (!skinnedCache[index]) {\r\n                skinnedCache[index] = new skinnedMatrixCache(0, 0, 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    private applyMorphTarget(mesh: Mesh, subDatas: PrimitiveSubMesh[]) {\r\n\r\n        let hasPosition = false;\r\n        let hasNormal = false;\r\n        let hasTangent = false;\r\n\r\n        subDatas.forEach(subData => {\r\n            hasPosition = subData.morphtargets.position || hasPosition;\r\n            hasNormal = subData.morphtargets.normal || hasNormal;\r\n            hasTangent = subData.morphtargets.tangent || hasTangent;\r\n        });\r\n\r\n        if (!(hasPosition || hasTangent || hasTangent)) {\r\n            return;\r\n        }\r\n\r\n        let vertexCount = mesh.vertexCount;\r\n\r\n        let morphData = new MorphTargetData();\r\n        morphData.vertexCount = vertexCount;\r\n\r\n        let decStr = [];\r\n        if (hasPosition)\r\n            decStr.push(\"POSITION\");\r\n        if (hasNormal)\r\n            decStr.push(\"NORMAL\");\r\n        if (hasTangent)\r\n            decStr.push(\"TANGENT\");\r\n\r\n        let morphVertexDec = VertexMesh.getVertexDeclaration(decStr.toLocaleString());\r\n        let targetVertexFloatStride = morphVertexDec.vertexStride / 4;\r\n\r\n        morphData.vertexDec = morphVertexDec;\r\n\r\n        let bounds = morphData.bounds;\r\n        let min = bounds.getMin();\r\n        let max = bounds.getMax();\r\n        min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        let subVertexOffset = 0;\r\n        for (let index = 0; index < subDatas.length; index++) {\r\n            let subData = subDatas[index];\r\n\r\n            min.x = Math.min(min.x, subData.morphtargets.boundMin[0]);\r\n            min.y = Math.min(min.y, subData.morphtargets.boundMin[1]);\r\n            min.z = Math.min(min.z, subData.morphtargets.boundMin[2]);\r\n\r\n            max.x = Math.max(max.x, subData.morphtargets.boundMax[0]);\r\n            max.y = Math.max(max.y, subData.morphtargets.boundMax[1]);\r\n            max.z = Math.max(max.z, subData.morphtargets.boundMax[2]);\r\n\r\n            let targets = subData.morphtargets.targets;\r\n            // glTF do not support in-between blendshape\r\n            for (const targetName in targets) {\r\n\r\n                let channel = morphData.getMorphChannel(targetName);\r\n                if (!channel) {\r\n                    channel = new MorphTargetChannel();\r\n                    channel.name = targetName;\r\n\r\n                    let target = new MorphTarget();\r\n                    target.name = targetName;\r\n                    target.data = new Float32Array(vertexCount * targetVertexFloatStride).fill(0);\r\n\r\n                    channel.addTarget(target);\r\n                    morphData.addMorphChannel(channel);\r\n                }\r\n\r\n                let target = channel.getTargetByIndex(0);\r\n                let morphMap = targets[targetName];\r\n\r\n                for (let vertexIndex = 0; vertexIndex < subData.vertexCount; vertexIndex++) {\r\n                    let morphPosition = morphMap.get(\"POSITION\");\r\n                    if (morphPosition) {\r\n                        let posElement = morphVertexDec.getVertexElementByUsage(VertexMesh.MESH_POSITION0);\r\n                        let offset = posElement.offset / 4;\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset] = morphPosition[vertexIndex * 3];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 1] = morphPosition[vertexIndex * 3 + 1];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 2] = morphPosition[vertexIndex * 3 + 2];\r\n                    }\r\n\r\n                    let morphNormal = morphMap.get(\"NORMAL\");\r\n                    if (morphNormal) {\r\n                        let normalElement = morphVertexDec.getVertexElementByUsage(VertexMesh.MESH_NORMAL0);\r\n                        let offset = normalElement.offset / 4;\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset] = morphNormal[vertexIndex * 3];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 1] = morphNormal[vertexIndex * 3 + 1];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 2] = morphNormal[vertexIndex * 3 + 2];\r\n                    }\r\n                    let morphTangent = morphMap.get(\"TANGENT\");\r\n                    if (morphTangent) {\r\n                        let tangentElement = morphVertexDec.getVertexElementByUsage(VertexMesh.MESH_TANGENT0);\r\n                        let offset = tangentElement.offset / 4;\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset] = morphTangent[vertexIndex * 3];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 1] = morphTangent[vertexIndex * 3 + 1];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 2] = morphTangent[vertexIndex * 3 + 2];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 3] = subData.attributeMap.get(\"TANGENT\")[vertexIndex * 4 + 3];\r\n                    }\r\n                }\r\n            }\r\n\r\n            subVertexOffset += subData.vertexCount;\r\n        }\r\n\r\n        bounds.setMin(min);\r\n        bounds.setMax(max);\r\n\r\n        mesh.morphTargetData = morphData;\r\n        morphData.initData();\r\n    }\r\n\r\n    /**\r\n     * 创建 Mesh\r\n     * @param mesh \r\n     */\r\n    protected createMesh(glTFMesh: glTF.glTFMesh, glTFSkin?: glTF.glTFSkin): Mesh {\r\n        let layaMesh: Mesh = new Mesh();\r\n\r\n        let glTFMeshPrimitives: glTF.glTFMeshPrimitive[] = glTFMesh.primitives;\r\n        let morphWeights: number[] = glTFMesh.weights;\r\n\r\n        let boneCount: number = (glTFSkin) ? glTFSkin.joints.length : 0;\r\n        let subDatas: PrimitiveSubMesh[] = [];\r\n\r\n        glTFMeshPrimitives.forEach((glTFMeshPrimitive: glTF.glTFMeshPrimitive) => {\r\n\r\n            let mode: glTF.glTFMeshPrimitiveMode = glTFMeshPrimitive.mode;\r\n            if (mode == undefined)\r\n                mode = glTF.glTFMeshPrimitiveMode.TRIANGLES;\r\n            if (glTF.glTFMeshPrimitiveMode.TRIANGLES != mode) {\r\n                // todo  只支持 gl.TRIANGLES 模式\r\n                console.warn(\"glTF Loader: only support gl.TRIANGLES.\");\r\n                debugger;\r\n            }\r\n\r\n            let vertexDeclarArr: string[] = [];\r\n            let attributeMap: Map<string, Float32Array> = new Map();\r\n            let attributes: { [name: string]: number } = glTFMeshPrimitive.attributes;\r\n\r\n            let position: Float32Array = this.getArrributeBuffer(attributes.POSITION, \"POSITION\", attributeMap, vertexDeclarArr);\r\n            let vertexCount: number = position.length / 3;\r\n            let indexArray: Uint32Array = this.getIndexBuffer(glTFMeshPrimitive.indices, vertexCount);\r\n            let positionAccessor = this._data.accessors[attributes.POSITION];\r\n\r\n            let normal: Float32Array = this.getArrributeBuffer(attributes.NORMAL, \"NORMAL\", attributeMap, vertexDeclarArr);\r\n            /**\r\n             * When normals are not specified, client implementations MUST calculate flat normals and the provided tangents (if present) MUST be ignored.\r\n             */\r\n            if (!normal) {\r\n                normal = this.calculateFlatNormal(position, indexArray);\r\n                vertexDeclarArr.push(\"NORMAL\");\r\n                attributeMap.set(\"NORMAL\", normal);\r\n            }\r\n\r\n            let color: Float32Array = this.getArrributeBuffer(attributes.COLOR_0, \"COLOR\", attributeMap, vertexDeclarArr);\r\n            let uv: Float32Array = this.getArrributeBuffer(attributes.TEXCOORD_0, \"UV\", attributeMap, vertexDeclarArr);\r\n            let uv1: Float32Array = this.getArrributeBuffer(attributes.TEXCOORD_1, \"UV1\", attributeMap, vertexDeclarArr);\r\n            let blendWeight: Float32Array = this.getArrributeBuffer(attributes.WEIGHTS_0, \"BLENDWEIGHT\", attributeMap, vertexDeclarArr);\r\n            let blendIndices: Float32Array = this.getArrributeBuffer(attributes.JOINTS_0, \"BLENDINDICES\", attributeMap, vertexDeclarArr);\r\n\r\n            let tangent: Float32Array;\r\n            tangent = this.getArrributeBuffer(attributes.TANGENT, \"TANGENT\", attributeMap, vertexDeclarArr);\r\n            // :(\r\n            if (tangent) {\r\n                for (let tangentIndex = 0; tangentIndex < tangent.length; tangentIndex += 4) {\r\n                    tangent[tangentIndex + 3] *= -1;\r\n                }\r\n            }\r\n\r\n            // todo  vertex color\r\n            // if (color) {\r\n            //     let material = glTFUtils._glTFMaterials[glTFMeshPrimitive.material];\r\n            //     material.enableVertexColor = true;\r\n            // }\r\n\r\n            let targets: { [name: string]: number }[] = glTFMeshPrimitive.targets;\r\n            let morphtargets: SubMorphData = { weights: morphWeights, position: false, normal: false, tangent: false, targets: {}, boundMin: [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], boundMax: [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE] };\r\n            if (targets) {\r\n\r\n                let morphtargetMap: { [name: string]: Map<string, Float32Array> };\r\n                let targetNames = glTFMesh.extras?.targetNames || [];\r\n                morphtargetMap = morphtargets.targets;\r\n\r\n                targets.forEach((target, index) => {\r\n                    let targetName = targetNames[index] || `target_${index}`;\r\n                    let morph = new Map<string, Float32Array>();\r\n                    morphtargetMap[targetName] = morph;\r\n\r\n                    let morphPosition = <Float32Array>this.getBufferwithAccessorIndex(target.POSITION);\r\n                    let morphNormal = <Float32Array>this.getBufferwithAccessorIndex(target.NORMAL);\r\n                    let morphTangent = <Float32Array>this.getBufferwithAccessorIndex(target.TANGENT);\r\n\r\n                    if (morphPosition) {\r\n                        morph.set(\"POSITION\", morphPosition);\r\n                        morphtargets.position = true;\r\n\r\n                        if (position) {\r\n                            let vertexCount: number = position.length / 3;\r\n\r\n                            for (let i = 0; i < vertexCount; i++) {\r\n                                let offset = i * 3;\r\n\r\n                                let morphX = position[offset] + morphPosition[offset];\r\n                                let morphY = position[offset + 1] + morphPosition[offset + 1];\r\n                                let morphZ = position[offset + 2] + morphPosition[offset + 2];\r\n\r\n                                morphtargets.boundMin[0] = Math.min(morphX, morphtargets.boundMin[0]);\r\n                                morphtargets.boundMin[1] = Math.min(morphY, morphtargets.boundMin[1]);\r\n                                morphtargets.boundMin[2] = Math.min(morphZ, morphtargets.boundMin[2]);\r\n\r\n                                morphtargets.boundMax[0] = Math.max(morphX, morphtargets.boundMax[0]);\r\n                                morphtargets.boundMax[1] = Math.max(morphY, morphtargets.boundMax[1]);\r\n                                morphtargets.boundMax[2] = Math.max(morphZ, morphtargets.boundMax[2]);\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                    if (morphNormal) {\r\n                        morph.set(\"NORMAL\", morphNormal);\r\n                        morphtargets.normal = true;\r\n                    }\r\n                    if (morphTangent) {\r\n                        morph.set(\"TANGENT\", morphTangent);\r\n                        morphtargets.tangent = true;\r\n                    }\r\n                });\r\n            }\r\n\r\n            let boneIndicesList: Array<Uint16Array> = new Array<Uint16Array>();\r\n            let subIndexStartArray: number[] = [];\r\n            let subIndexCountArray: number[] = [];\r\n\r\n            if (glTFSkin) {\r\n                if (boneCount > maxSubBoneCount) {\r\n                    // todo 划分 subMesh\r\n                    this.splitSubMeshByBonesCount(attributeMap, morphtargets, indexArray, boneIndicesList, subIndexStartArray, subIndexCountArray);\r\n                    vertexCount = attributeMap.get(\"POSITION\").length / 3;\r\n                }\r\n                else {\r\n                    subIndexStartArray[0] = 0;\r\n                    subIndexCountArray[0] = indexArray.length;\r\n                    boneIndicesList[0] = new Uint16Array(boneCount);\r\n                    for (let bi = 0; bi < boneCount; bi++) {\r\n                        boneIndicesList[0][bi] = bi;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                subIndexStartArray[0] = 0;\r\n                subIndexCountArray[0] = indexArray.length;\r\n            }\r\n            let vertexDeclaration: string = vertexDeclarArr.toString();\r\n\r\n            let subData: PrimitiveSubMesh = new PrimitiveSubMesh();\r\n            subDatas.push(subData);\r\n\r\n            subData.attributeMap = attributeMap;\r\n            subData.boundMax = positionAccessor.max;\r\n            subData.boundMin = positionAccessor.min;\r\n            subData.morphtargets = morphtargets;\r\n            subData.indices = indexArray;\r\n            subData.vertexCount = vertexCount;\r\n            subData.vertexDecler = vertexDeclaration;\r\n            subData.boneIndicesList = boneIndicesList;\r\n            subData.subIndexStartArray = subIndexStartArray;\r\n            subData.subIndexCountArray = subIndexCountArray;\r\n        });\r\n\r\n        this.parseMeshwithSubMeshData(subDatas, layaMesh);\r\n        this.applyglTFSkinData(layaMesh, subDatas, glTFSkin);\r\n        this.applyMorphTarget(layaMesh, subDatas);\r\n        return layaMesh;\r\n    }\r\n\r\n    /**\r\n     * 计算 SkinnedMeshSprite3D local bounds\r\n     * @param skinned \r\n     */\r\n    private calSkinnedSpriteLocalBounds(skinned: SkinnedMeshSprite3D): void {\r\n        let render: SkinnedMeshRenderer = skinned.skinnedMeshRenderer;\r\n        let mesh: Mesh = skinned.meshFilter.sharedMesh;\r\n        let rootBone: Sprite3D = render.rootBone;\r\n\r\n        let oriRootMatrix: Matrix4x4 = rootBone.transform.worldMatrix;\r\n        let invertRootMatrix: Matrix4x4 = new Matrix4x4();\r\n        oriRootMatrix.invert(invertRootMatrix);\r\n\r\n        let indices = mesh.getIndices();\r\n\r\n        let positions: Vector3[] = [];\r\n        let boneIndices: Vector4[] = [];\r\n        let boneWeights: Vector4[] = [];\r\n        mesh.getPositions(positions);\r\n        mesh.getBoneIndices(boneIndices);\r\n        mesh.getBoneWeights(boneWeights);\r\n\r\n        let oriBoneIndeices: Vector4[] = [];\r\n        mesh._subMeshes.forEach((subMesh: SubMesh, index: number) => {\r\n            let bonelists: Uint16Array[] = subMesh._boneIndicesList;\r\n            bonelists.forEach((bonelist: Uint16Array, listIndex: number) => {\r\n                let start: number = subMesh._subIndexBufferStart[listIndex];\r\n                let count: number = subMesh._subIndexBufferCount[listIndex];\r\n                let endIndex: number = count + start;\r\n                for (let iindex = start; iindex < endIndex; iindex++) {\r\n                    let ii: number = indices[iindex];\r\n                    let boneIndex: Vector4 = boneIndices[ii];\r\n                    let x: number = bonelist[boneIndex.x];\r\n                    let y: number = bonelist[boneIndex.y];\r\n                    let z: number = bonelist[boneIndex.z];\r\n                    let w: number = bonelist[boneIndex.w];\r\n                    oriBoneIndeices[ii] = new Vector4(x, y, z, w);\r\n                }\r\n            });\r\n        });\r\n\r\n        let inverseBindPoses: Matrix4x4[] = mesh._inverseBindPoses;\r\n        let bones: Sprite3D[] = render.bones;\r\n        let ubones: Matrix4x4[] = [];\r\n        let tempMat: Matrix4x4 = new Matrix4x4();\r\n        bones.forEach((bone, index) => {\r\n            ubones[index] = new Matrix4x4();\r\n            Matrix4x4.multiply(invertRootMatrix, bone.transform.worldMatrix, tempMat);\r\n            Matrix4x4.multiply(tempMat, inverseBindPoses[index], ubones[index]);\r\n        });\r\n\r\n        let skinTransform: Matrix4x4 = new Matrix4x4;\r\n        let resPos: Vector3 = new Vector3();\r\n        let min: Vector3 = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        let max: Vector3 = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        for (let index = 0; index < positions.length; index++) {\r\n            let pos: Vector3 = positions[index];\r\n            let boneIndex: Vector4 = oriBoneIndeices[index];\r\n            let boneWeight: Vector4 = boneWeights[index];\r\n\r\n            if (!(boneIndex && boneWeight)) {\r\n                continue;\r\n            }\r\n\r\n            for (let ei = 0; ei < 16; ei++) {\r\n                skinTransform.elements[ei] = ubones[boneIndex.x].elements[ei] * boneWeight.x;\r\n                skinTransform.elements[ei] += ubones[boneIndex.y].elements[ei] * boneWeight.y;\r\n                skinTransform.elements[ei] += ubones[boneIndex.z].elements[ei] * boneWeight.z;\r\n                skinTransform.elements[ei] += ubones[boneIndex.w].elements[ei] * boneWeight.w;\r\n            }\r\n            Vector3.transformV3ToV3(pos, skinTransform, resPos);\r\n            Vector3.min(min, resPos, min);\r\n            Vector3.max(max, resPos, max);\r\n\r\n        }\r\n\r\n        // positions.forEach((pos: Vector3, index: number) => {\r\n        //     let boneIndex: Vector4 = oriBoneIndeices[index];\r\n        //     let boneWeight: Vector4 = boneWeights[index];\r\n\r\n        //     for (let ei = 0; ei < 16; ei++) {\r\n        //         skinTransform.elements[ei] = ubones[boneIndex.x].elements[ei] * boneWeight.x;\r\n        //         skinTransform.elements[ei] += ubones[boneIndex.y].elements[ei] * boneWeight.y;\r\n        //         skinTransform.elements[ei] += ubones[boneIndex.z].elements[ei] * boneWeight.z;\r\n        //         skinTransform.elements[ei] += ubones[boneIndex.w].elements[ei] * boneWeight.w;\r\n        //     }\r\n        //     Vector3.transformV3ToV3(pos, skinTransform, resPos);\r\n        //     Vector3.min(min, resPos, min);\r\n        //     Vector3.max(max, resPos, max);\r\n        // });\r\n\r\n        positions = null;\r\n        boneIndices = boneWeights = oriBoneIndeices = null;\r\n        indices = null;\r\n        ubones = null;\r\n\r\n        render.localBounds.setMin(min);\r\n        render.localBounds.setMax(max);\r\n        render.localBounds = render.localBounds;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 补全 skinnedMeshSprite 所需数据\r\n     * @param glTFNode \r\n     * @param skinned \r\n     */\r\n    private fixSkinnedSprite(glTFNode: glTF.glTFNode, skinned: SkinnedMeshSprite3D): void {\r\n        let skin: glTF.glTFSkin = this._data.skins[glTFNode.skin];\r\n        let skinnedMeshRenderer: SkinnedMeshRenderer = skinned.skinnedMeshRenderer;\r\n        skin.joints.forEach(nodeIndex => {\r\n            let bone: Sprite3D = this._nodes[nodeIndex];\r\n            skinnedMeshRenderer.bones.push(bone);\r\n        });\r\n        if (skin.skeleton == undefined) {\r\n            skin.skeleton = skin.joints[0];\r\n        }\r\n        skinnedMeshRenderer.rootBone = this._nodes[skin.skeleton];\r\n\r\n        this.calSkinnedSpriteLocalBounds(skinned);\r\n    }\r\n\r\n    /**\r\n     * @interna\r\n     * 获取 Animator 根节点\r\n     */\r\n    private getAnimationRoot(channels: glTF.glTFAnimationChannel[]): Sprite3D {\r\n        const isContainNode = (nodeArr: number[], findNodeIndex: number): boolean => {\r\n            if (!nodeArr)\r\n                return false;\r\n            if (nodeArr.indexOf(findNodeIndex) == -1) {\r\n                for (let index = 0; index < nodeArr.length; index++) {\r\n                    let glTFNode: glTF.glTFNode = this._data.nodes[nodeArr[index]];\r\n                    if (isContainNode(glTFNode.children, findNodeIndex)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        let target: glTF.glTFAnimationChannelTarget = channels[0].target;\r\n        let spriteIndex: number = target.node;\r\n        for (let index = 0; index < this._data.scenes.length; index++) {\r\n            let glTFScene: glTF.glTFScene = this._data.scenes[index];\r\n            if (isContainNode(glTFScene.nodes, spriteIndex)) {\r\n                return this._scenes[index];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 动画路径信息\r\n     * @param root \r\n     * @param curSprite \r\n     */\r\n    private getAnimationPath(root: Sprite3D, curSprite: Sprite3D): string[] {\r\n        let paths: string[] = [];\r\n        if (root == curSprite)\r\n            return paths;\r\n\r\n        let sprite: Sprite3D = curSprite;\r\n        while (sprite.parent != root) {\r\n            sprite = <Sprite3D>sprite.parent;\r\n            paths.push(sprite.name);\r\n        }\r\n        paths = paths.reverse();\r\n        paths.push(curSprite.name);\r\n        return paths;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载 Animation\r\n     * @param animations \r\n     */\r\n    private loadAnimations(animations?: glTF.glTFAnimation[]): void {\r\n        if (!animations)\r\n            return;\r\n\r\n        animations.forEach((animation: glTF.glTFAnimation, index: number) => {\r\n            // todo \r\n            this.loadAnimation(animation);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载 Animation\r\n     * @param animation \r\n     */\r\n    private loadAnimation(animation: glTF.glTFAnimation): Animator {\r\n        // todo extension and extra\r\n\r\n        return this.createAnimator(animation);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 创建 Animator 组件\r\n     * @param animation \r\n     */\r\n    private createAnimator(animation: glTF.glTFAnimation): Animator {\r\n\r\n        let channels: glTF.glTFAnimationChannel[] = animation.channels;\r\n        let samplers: glTF.glTFAnimationSampler[] = animation.samplers;\r\n\r\n        let animatorRoot: Sprite3D = this.getAnimationRoot(channels);\r\n\r\n        if (!animatorRoot) {\r\n            return null;\r\n        }\r\n\r\n        let animator: Animator = animatorRoot.getComponent(Animator);\r\n        if (!animator) {\r\n            animator = animatorRoot.addComponent(Animator);\r\n            let animatorLayer: AnimatorControllerLayer = new AnimatorControllerLayer(\"AnimatorLayer\");\r\n            animator.addControllerLayer(animatorLayer);\r\n            animatorLayer.defaultWeight = 1.0;\r\n        }\r\n\r\n        let clip: AnimationClip = this.createAnimatorClip(animation, animatorRoot);\r\n        let animatorLayer: AnimatorControllerLayer = animator.getControllerLayer();\r\n\r\n        let animationName: string = clip.name;\r\n\r\n        if (animatorLayer.getAnimatorState(animationName)) {\r\n            animationName = clip.name = `${animationName}_${this.generateId(animationName)}`;\r\n        }\r\n\r\n        let animatorState: AnimatorState = new AnimatorState();\r\n        // todo  state name\r\n        animatorState.name = animationName;\r\n        animatorState.clip = clip;\r\n        animatorLayer.addState(animatorState);\r\n        animatorLayer.defaultState = animatorState;\r\n        animatorLayer.playOnWake = true;\r\n\r\n        return animator;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 创建 AnimationClip\r\n     * @param animation \r\n     * @param animatorRoot \r\n     * @returns \r\n     */\r\n    protected createAnimatorClip(animation: glTF.glTFAnimation, animatorRoot: Sprite3D): AnimationClip {\r\n        let clip: AnimationClip = new AnimationClip();\r\n\r\n        let duration: number = 0;\r\n\r\n        let channels: glTF.glTFAnimationChannel[] = animation.channels;\r\n        let samplers: glTF.glTFAnimationSampler[] = animation.samplers;\r\n\r\n        let clipNodes: ClipNode[] = [];\r\n        channels.forEach((channel: glTF.glTFAnimationChannel, index: number) => {\r\n            let target: glTF.glTFAnimationChannelTarget = channel.target;\r\n            let sampler: glTF.glTFAnimationSampler = samplers[channel.sampler];\r\n            let targetPath: glTF.glTFAnimationChannelTargetPath = target.path;\r\n\r\n            let timeBuffer = this.getBufferwithAccessorIndex(sampler.input);\r\n            let outBuffer = this.getBufferwithAccessorIndex(sampler.output);\r\n\r\n            let timeArray = new Float32Array(timeBuffer);\r\n            let outArray = new Float32Array(outBuffer);\r\n\r\n            let sprite: Sprite3D = this._nodes[target.node];\r\n\r\n            let animaPaths = this.getAnimationPath(animatorRoot, sprite);\r\n\r\n            if (targetPath == glTF.glTFAnimationChannelTargetPath.WEIGHTS) {\r\n\r\n                let mesh = sprite.getComponent(MeshFilter)?.sharedMesh;\r\n                if (mesh && mesh.morphTargetData) {\r\n\r\n                    let ownerStr = sprite.getComponent(SkinnedMeshRenderer) ? \"SkinnedMeshRenderer\" : \"MeshRenderer\";\r\n\r\n                    let morphData = mesh.morphTargetData;\r\n                    let channelCount = morphData.channelCount;\r\n                    // check data \r\n                    if (outArray.length / timeArray.length == channelCount) {\r\n                        for (let channelIndex = 0; channelIndex < channelCount; channelIndex++) {\r\n                            let morphChannel = morphData.getMorphChannelbyIndex(channelIndex);\r\n                            let channelName = morphChannel.name;\r\n\r\n                            let clipNode: ClipNode = {};\r\n                            clipNodes.push(clipNode);\r\n                            clipNode.paths = animaPaths;\r\n                            clipNode.interpolation = sampler.interpolation;\r\n                            clipNode.timeArray = timeArray;\r\n                            clipNode.valueArray = new Float32Array(timeArray.length);\r\n                            for (let i = 0; i < timeArray.length; i++) {\r\n                                clipNode.valueArray[i] = outArray[i * channelCount + channelIndex];\r\n                            }\r\n\r\n                            clipNode.propertyOwner = ownerStr;\r\n                            clipNode.propertise = [];\r\n                            clipNode.propertise.push(\"morphTargetValues\");\r\n                            clipNode.propertise.push(channelName);\r\n                            clipNode.propertyLength = clipNode.propertise.length;\r\n                            clipNode.type = 0;\r\n                            clipNode.callbackFunc = \"_changeMorphTargetValue\";\r\n                            clipNode.callbackParams = [channelName];\r\n                            clipNode.propertyChangePath = \"morphTargetValues\";\r\n\r\n                            clipNode.duration = clipNode.timeArray[clipNode.timeArray.length - 1];\r\n                            duration = Math.max(duration, clipNode.duration);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                let clipNode: ClipNode = {};\r\n                clipNodes.push(clipNode);\r\n                clipNode.timeArray = timeArray;\r\n                clipNode.valueArray = outArray;\r\n                let interpolation = sampler.interpolation;\r\n                clipNode.interpolation = interpolation;\r\n\r\n                clipNode.paths = animaPaths;\r\n\r\n                switch (targetPath) {\r\n                    case glTF.glTFAnimationChannelTargetPath.TRANSLATION:\r\n                        clipNode.propertyOwner = \"transform\";\r\n                        clipNode.propertyLength = 1;\r\n                        clipNode.propertise = [];\r\n                        clipNode.propertise.push(\"localPosition\");\r\n                        clipNode.type = 1;\r\n                        break;\r\n                    case glTF.glTFAnimationChannelTargetPath.ROTATION:\r\n                        clipNode.propertyOwner = \"transform\";\r\n                        clipNode.propertyLength = 1;\r\n                        clipNode.propertise = [];\r\n                        clipNode.propertise.push(\"localRotation\");\r\n                        clipNode.type = 2;\r\n                        break;\r\n                    case glTF.glTFAnimationChannelTargetPath.SCALE:\r\n                        clipNode.propertyOwner = \"transform\";\r\n                        clipNode.propertyLength = 1;\r\n                        clipNode.propertise = [];\r\n                        clipNode.propertise.push(\"localScale\");\r\n                        clipNode.type = 3;\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n\r\n                clipNode.duration = clipNode.timeArray[clipNode.timeArray.length - 1];\r\n                duration = Math.max(duration, clipNode.duration);\r\n            }\r\n        });\r\n\r\n        clip.name = animation.name ? animation.name : `Animation_${this.generateId(\"Animation\")}`;\r\n        clip._duration = duration;\r\n        clip.islooping = true;\r\n        clip._frameRate = 30;\r\n        let nodeCount: number = clipNodes.length;\r\n        let nodes: KeyframeNodeList = clip._nodes;\r\n        nodes.count = nodeCount;\r\n        let nodesMap: any = clip._nodesMap = {};\r\n        let nodesDic: any = clip._nodesDic = {};\r\n        for (let i: number = 0; i < nodeCount; i++) {\r\n            let node: KeyframeNode = new KeyframeNode();\r\n\r\n            let glTFClipNode: ClipNode = clipNodes[i];\r\n\r\n            nodes.setNodeByIndex(i, node);\r\n            node._indexInList = i;\r\n            // todo type\r\n            let type: number = node.type = glTFClipNode.type;\r\n            let pathLength: number = glTFClipNode.paths.length;\r\n            node._setOwnerPathCount(pathLength);\r\n            let tempPath: string[] = glTFClipNode.paths;\r\n            for (let j: number = 0; j < pathLength; j++) {\r\n                node._setOwnerPathByIndex(j, tempPath[j]);\r\n            }\r\n            let nodePath: string = node._joinOwnerPath(\"/\");\r\n            let mapArray: KeyframeNode[] = nodesMap[nodePath];\r\n            (mapArray) || (nodesMap[nodePath] = mapArray = []);\r\n            mapArray.push(node);\r\n            node.propertyOwner = glTFClipNode.propertyOwner;\r\n            let propertyLength: number = glTFClipNode.propertyLength;\r\n            node._setPropertyCount(propertyLength);\r\n            for (let j: number = 0; j < propertyLength; j++) {\r\n                node._setPropertyByIndex(j, glTFClipNode.propertise[j]);\r\n            }\r\n            let fullPath: string = nodePath + \".\" + node.propertyOwner + \".\" + node._joinProperty(\".\");\r\n            nodesDic[fullPath] = fullPath;\r\n            node.fullPath = fullPath;\r\n\r\n            node.callbackFunData = glTFClipNode.callbackFunc;\r\n            node.callParams = glTFClipNode.callbackParams;\r\n            node.propertyChangePath = glTFClipNode.propertyChangePath;\r\n\r\n            let keyframeCount: number = glTFClipNode.timeArray.length;\r\n\r\n            // laya animation version \"LAYAANIMATION:04\"\r\n            for (let j: number = 0; j < keyframeCount; j++) {\r\n                switch (type) {\r\n                    case 0:\r\n                        let floatKeyFrame = new FloatKeyframe();\r\n                        node._setKeyframeByIndex(j, floatKeyFrame);\r\n                        floatKeyFrame.time = glTFClipNode.timeArray[j];\r\n\r\n                        switch (glTFClipNode.interpolation) {\r\n                            case glTF.glTFAnimationSamplerInterpolation.CUBICSPLINE:\r\n                                {\r\n                                    floatKeyFrame.value = glTFClipNode.valueArray[3 * j + 1];\r\n                                    // todo\r\n                                    floatKeyFrame.inTangent = glTFClipNode.valueArray[3 * j + 0];\r\n                                    floatKeyFrame.outTangent = glTFClipNode.valueArray[3 * j + 2];\r\n                                }\r\n                                break;\r\n                            case glTF.glTFAnimationSamplerInterpolation.STEP:\r\n                                floatKeyFrame.value = glTFClipNode.valueArray[j];\r\n                                floatKeyFrame.inTangent = Infinity;\r\n                                floatKeyFrame.outTangent = Infinity;\r\n                                break;\r\n                            case glTF.glTFAnimationSamplerInterpolation.LINEAR:\r\n                            default:\r\n                                {\r\n                                    floatKeyFrame.value = glTFClipNode.valueArray[j];\r\n\r\n                                    let lastI = j == 0 ? j : j - 1;\r\n                                    let lastTime = glTFClipNode.timeArray[lastI];\r\n                                    let lastValue = glTFClipNode.valueArray[lastI];\r\n                                    let lastTimeDet = lastI == j ? 1 : (floatKeyFrame.time - lastTime);\r\n\r\n                                    floatKeyFrame.inTangent = (floatKeyFrame.value - lastValue) / lastTimeDet;\r\n\r\n                                    let nextI = j == keyframeCount - 1 ? j : j + 1;\r\n                                    let nextTime = glTFClipNode.timeArray[nextI];\r\n                                    let nextValue = glTFClipNode.valueArray[nextI];\r\n                                    let nextTimeDet = nextI == j ? 1 : (nextTime - floatKeyFrame.time);\r\n\r\n                                    floatKeyFrame.outTangent = (nextValue - floatKeyFrame.value) / nextTimeDet;\r\n\r\n                                    if (lastI == j) {\r\n                                        floatKeyFrame.inTangent = floatKeyFrame.outTangent;\r\n                                    }\r\n                                    if (nextI == j) {\r\n                                        floatKeyFrame.outTangent = floatKeyFrame.inTangent;\r\n                                    }\r\n                                }\r\n                                break;\r\n                        }\r\n\r\n                        break;\r\n                    case 1: // local position\r\n                    case 3: // local scale\r\n                    case 4: // local euler angler raw\r\n                        let floatArrayKeyframe: Vector3Keyframe = new Vector3Keyframe();\r\n                        node._setKeyframeByIndex(j, floatArrayKeyframe);\r\n                        let startTimev3: number = floatArrayKeyframe.time = glTFClipNode.timeArray[j];\r\n                        let inTangent: Vector3 = floatArrayKeyframe.inTangent;\r\n                        let outTangent: Vector3 = floatArrayKeyframe.outTangent;\r\n                        let value: Vector3 = floatArrayKeyframe.value;\r\n\r\n                        switch (glTFClipNode.interpolation) {\r\n                            case glTF.glTFAnimationSamplerInterpolation.CUBICSPLINE:\r\n                                value.setValue(glTFClipNode.valueArray[9 * j + 3], glTFClipNode.valueArray[9 * j + 4], glTFClipNode.valueArray[9 * j + 5]);\r\n                                inTangent.setValue(glTFClipNode.valueArray[9 * j + 0], glTFClipNode.valueArray[9 * j + 1], glTFClipNode.valueArray[9 * j + 2]);\r\n                                outTangent.setValue(glTFClipNode.valueArray[9 * j + 6], glTFClipNode.valueArray[9 * j + 7], glTFClipNode.valueArray[9 * j + 8]);\r\n                                break;\r\n                            case glTF.glTFAnimationSamplerInterpolation.STEP:\r\n                                value.setValue(glTFClipNode.valueArray[3 * j], glTFClipNode.valueArray[3 * j + 1], glTFClipNode.valueArray[3 * j + 2]);\r\n                                inTangent.setValue(Infinity, Infinity, Infinity);\r\n                                outTangent.setValue(Infinity, Infinity, Infinity);\r\n                                break;\r\n                            case glTF.glTFAnimationSamplerInterpolation.LINEAR:\r\n                            default:\r\n                                {\r\n                                    value.setValue(glTFClipNode.valueArray[3 * j], glTFClipNode.valueArray[3 * j + 1], glTFClipNode.valueArray[3 * j + 2]);\r\n\r\n                                    let lastI = j == 0 ? j : j - 1;\r\n                                    let lastTime = glTFClipNode.timeArray[lastI];\r\n                                    let lastX = glTFClipNode.valueArray[3 * lastI];\r\n                                    let lastY = glTFClipNode.valueArray[3 * lastI + 1];\r\n                                    let lastZ = glTFClipNode.valueArray[3 * lastI + 2];\r\n\r\n                                    let lastTimeDet = lastI == j ? 1 : startTimev3 - lastTime;\r\n                                    inTangent.x = (value.x - lastX) / lastTimeDet;\r\n                                    inTangent.y = (value.y - lastY) / lastTimeDet;\r\n                                    inTangent.z = (value.z - lastZ) / lastTimeDet;\r\n\r\n                                    let nextI = j == keyframeCount - 1 ? j : j + 1;\r\n                                    let nextTime = glTFClipNode.timeArray[nextI];\r\n                                    let nextX = glTFClipNode.valueArray[3 * nextI];\r\n                                    let nextY = glTFClipNode.valueArray[3 * nextI + 1];\r\n                                    let nextZ = glTFClipNode.valueArray[3 * nextI + 2];\r\n\r\n                                    let nestTimeDet = nextI == j ? 1 : nextTime - startTimev3;\r\n                                    outTangent.x = (nextX - value.x) / nestTimeDet;\r\n                                    outTangent.y = (nextY - value.y) / nestTimeDet;\r\n                                    outTangent.z = (nextZ - value.z) / nestTimeDet;\r\n\r\n                                    if (lastI == j) {\r\n                                        outTangent.cloneTo(inTangent);\r\n                                    }\r\n                                    if (nextI == j) {\r\n                                        inTangent.cloneTo(outTangent);\r\n                                    }\r\n                                }\r\n                                break;\r\n                        }\r\n                        break;\r\n                    case 2: // local rotation\r\n                        let quaternionKeyframe: QuaternionKeyframe = new QuaternionKeyframe();\r\n                        node._setKeyframeByIndex(j, quaternionKeyframe);\r\n                        let startTimeQu: number = quaternionKeyframe.time = glTFClipNode.timeArray[j];\r\n                        let inTangentQua: Vector4 = quaternionKeyframe.inTangent;\r\n                        let outTangentQua: Vector4 = quaternionKeyframe.outTangent;\r\n                        let valueQua: Quaternion = quaternionKeyframe.value;\r\n                        switch (glTFClipNode.interpolation) {\r\n                            case glTF.glTFAnimationSamplerInterpolation.CUBICSPLINE:\r\n                                valueQua.set(glTFClipNode.valueArray[12 * j + 4], glTFClipNode.valueArray[12 * j + 5], glTFClipNode.valueArray[12 * j + 6], glTFClipNode.valueArray[12 * j + 7]);\r\n                                inTangentQua.setValue(glTFClipNode.valueArray[12 * j + 0], glTFClipNode.valueArray[12 * j + 1], glTFClipNode.valueArray[12 * j + 2], glTFClipNode.valueArray[12 * j + 3]);\r\n                                outTangentQua.setValue(glTFClipNode.valueArray[12 * j + 8], glTFClipNode.valueArray[12 * j + 9], glTFClipNode.valueArray[12 * j + 10], glTFClipNode.valueArray[12 * j + 11]);\r\n                                break;\r\n                            case glTF.glTFAnimationSamplerInterpolation.STEP:\r\n                                valueQua.set(glTFClipNode.valueArray[4 * j + 0], glTFClipNode.valueArray[4 * j + 1], glTFClipNode.valueArray[4 * j + 2], glTFClipNode.valueArray[4 * j + 3]);\r\n                                inTangentQua.setValue(Infinity, Infinity, Infinity, Infinity);\r\n                                outTangentQua.setValue(Infinity, Infinity, Infinity, Infinity);\r\n                                break;\r\n\r\n                            case glTF.glTFAnimationSamplerInterpolation.LINEAR:\r\n                            default:\r\n                                {\r\n                                    valueQua.set(glTFClipNode.valueArray[4 * j + 0], glTFClipNode.valueArray[4 * j + 1], glTFClipNode.valueArray[4 * j + 2], glTFClipNode.valueArray[4 * j + 3]);\r\n\r\n                                    let lastI = j == 0 ? j : j - 1;\r\n                                    let lastTime = glTFClipNode.timeArray[lastI];\r\n                                    let lastX = glTFClipNode.valueArray[4 * lastI];\r\n                                    let lastY = glTFClipNode.valueArray[4 * lastI + 1];\r\n                                    let lastZ = glTFClipNode.valueArray[4 * lastI + 2];\r\n                                    let lastW = glTFClipNode.valueArray[4 * lastI + 3];\r\n\r\n                                    let lastTimeDet = lastI == j ? 1 : startTimeQu - lastTime;\r\n                                    inTangentQua.x = (valueQua.x - lastX) / lastTimeDet;\r\n                                    inTangentQua.y = (valueQua.y - lastY) / lastTimeDet;\r\n                                    inTangentQua.z = (valueQua.z - lastZ) / lastTimeDet;\r\n                                    inTangentQua.w = (valueQua.w - lastW) / lastTimeDet;\r\n\r\n                                    let nextI = j == keyframeCount - 1 ? j : j + 1;\r\n                                    let nextTime = glTFClipNode.timeArray[nextI];\r\n                                    let nextX = glTFClipNode.valueArray[4 * nextI];\r\n                                    let nextY = glTFClipNode.valueArray[4 * nextI + 1];\r\n                                    let nextZ = glTFClipNode.valueArray[4 * nextI + 2];\r\n                                    let nextW = glTFClipNode.valueArray[4 * nextI + 3];\r\n\r\n                                    if ((valueQua.x * nextX + valueQua.y * nextY + valueQua.z * nextZ + valueQua.w * nextW) < 0) {\r\n                                        nextX *= -1;\r\n                                        nextY *= -1;\r\n                                        nextZ *= -1;\r\n                                        nextW *= -1;\r\n                                        glTFClipNode.valueArray[4 * nextI] = nextX;\r\n                                        glTFClipNode.valueArray[4 * nextI + 1] = nextY;\r\n                                        glTFClipNode.valueArray[4 * nextI + 2] = nextZ;\r\n                                        glTFClipNode.valueArray[4 * nextI + 3] = nextW;\r\n                                    }\r\n\r\n                                    let nestTimeDet = nextI == j ? 1 : nextTime - startTimeQu;\r\n                                    outTangentQua.x = (nextX - valueQua.x) / nestTimeDet;\r\n                                    outTangentQua.y = (nextY - valueQua.y) / nestTimeDet;\r\n                                    outTangentQua.z = (nextZ - valueQua.z) / nestTimeDet;\r\n                                    outTangentQua.w = (nextW - valueQua.w) / nestTimeDet;\r\n\r\n                                    if (lastI == j) {\r\n                                        outTangentQua.cloneTo(inTangentQua);\r\n                                    }\r\n                                    if (nextI == j) {\r\n                                        inTangentQua.cloneTo(outTangentQua);\r\n                                    }\r\n\r\n                                }\r\n                                break;\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        clipNodes = null;\r\n\r\n        return clip;\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * 辅助记录 sub morph data 所需数据\r\n */\r\nclass SubMorphData {\r\n    weights: number[];\r\n    position: boolean;\r\n    boundMin: number[];\r\n    boundMax: number[];\r\n    normal: boolean;\r\n    tangent: boolean;\r\n    targets: { [name: string]: Map<string, Float32Array> }\r\n}\r\n\r\n/**\r\n * @internal\r\n * 辅助记录 submesh 所需数据\r\n */\r\nclass PrimitiveSubMesh {\r\n\r\n    attributeMap: Map<string, Float32Array>;\r\n    boundMin: number[];\r\n    boundMax: number[];\r\n    indices: Uint32Array;\r\n    vertexDecler: string;\r\n    vertexCount: number;\r\n    boneIndicesList: Uint16Array[];\r\n    subIndexStartArray: number[];\r\n    subIndexCountArray: number[];\r\n\r\n    morphtargets: SubMorphData;\r\n\r\n    constructor() {\r\n\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * 辅助记录 animator clip 所需数据\r\n */\r\ninterface ClipNode {\r\n    paths?: string[];\r\n    propertyOwner?: string;\r\n    propertyLength?: number;\r\n    propertise?: string[];\r\n    timeArray?: Float32Array;\r\n    valueArray?: Float32Array;\r\n    interpolation?: glTF.glTFAnimationSamplerInterpolation;\r\n    duration?: number;\r\n    type?: number;\r\n    callbackFunc?: string;\r\n    callbackParams?: any[];\r\n    propertyChangePath?: string;\r\n}\r\n\r\nLaya.onInitModule(() => {\r\n    glTFShader.init();\r\n});\r\n","import * as glTF from \"../glTFInterface\";\r\n\r\nimport { Material } from \"../../d3/core/material/Material\";\r\nimport { IBatchProgress } from \"../../net/BatchProgress\";\r\nimport { glTFMaterial } from \"../glTFInterface\";\r\nimport { glTFResource } from \"../glTFResource\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\nimport { Matrix3x3 } from \"../../maths/Matrix3x3\";\r\nimport { Vector2 } from \"../../maths/Vector2\";\r\n\r\nconst ExtensionName = \"KHR_texture_transform\";\r\n\r\ndeclare module \"../glTFInterface\" {\r\n\r\n    export interface glTFTextureTransform {\r\n        /** The offset of the UV coordinate origin as a factor of the texture dimensions. default: [0, 0] */\r\n        offset: number[];\r\n        /** Rotate the UVs by this many radians counter-clockwise around the origin. This is equivalent to a similar rotation of the image clockwise. default: 0.0 */\r\n        rotation: number;\r\n        /** The scale factor applied to the components of the UV coordinates. default: [1, 1] */\r\n        scale: number[];\r\n        /** Overrides the textureInfo texCoord value if supplied, and if this extension is supported. */\r\n        texCoord: number;\r\n    }\r\n\r\n}\r\n\r\nconst translation = new Matrix3x3();\r\nconst rotation = new Matrix3x3();\r\n\r\nconst offset = new Vector2;\r\nconst scale = new Vector2;\r\n\r\n// todo\r\nexport class KHR_texture_transform implements glTFExtension {\r\n\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    createTransform(extension: glTF.glTFTextureTransform) {\r\n        offset.setValue(0, 0);\r\n        if (extension.offset) {\r\n            offset.fromArray(extension.offset);\r\n        }\r\n        Matrix3x3.createFromTranslation(offset, translation);\r\n\r\n        let rot = extension.rotation ?? 0;\r\n        Matrix3x3.createFromRotation(-rot, rotation);\r\n\r\n        scale.setValue(1, 1);\r\n        if (extension.scale) {\r\n            scale.fromArray(extension.scale);\r\n        }\r\n\r\n        let trans = new Matrix3x3();\r\n        Matrix3x3.multiply(translation, rotation, trans);\r\n        trans.scale(scale, trans);\r\n        return trans;\r\n    }\r\n\r\n    loadExtensionTextureInfo(info: glTF.glTFTextureInfo) {\r\n        let extension: glTF.glTFTextureTransform = info.extensions?.KHR_texture_transform;\r\n\r\n        let trans = this.createTransform(extension);\r\n        let texCoord = extension.texCoord;\r\n\r\n        return {\r\n            transform: trans,\r\n            texCoord: texCoord\r\n        }\r\n    }\r\n\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_texture_transform(resource));","import { IBatchProgress } from \"../../net/BatchProgress\";\r\nimport { Texture2D } from \"../../resource/Texture2D\";\r\nimport { glTFResource } from \"../glTFResource\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\n\r\nimport { Material } from \"../../d3/core/material/Material\";\r\nimport { PBRMaterial } from \"../../d3/core/material/PBRMaterial\";\r\nimport * as glTF from \"../glTFInterface\";\r\nimport { PBRShaderLib } from \"../../d3/shader/pbr/PBRShaderLib\";\r\nimport { glTFShader } from \"../shader/glTFShader\";\r\n\r\nconst ExtensionName = \"KHR_materials_anisotropy\";\r\n\r\ndeclare module \"../glTFInterface\" {\r\n\r\n    export interface glTFMaterialAnisotropy {\r\n        /** The anisotropy strength. When anisotropyTexture is present, this value is multiplied by the blue channel. default: 0.0 */\r\n        anisotropyStrength: number;\r\n        /** The rotation of the anisotropy in tangent, bitangent space, measured in radians counter-clockwise from the tangent. When anisotropyTexture is present, anisotropyRotation provides additional rotation to the vectors in the texture. default: 0.0 */\r\n        anisotropyRotation: number;\r\n        /** The anisotropy texture. Red and green channels represent the anisotropy direction in [-1, 1] tangent, bitangent space, to be rotated by anisotropyRotation. The blue channel contains strength as [0, 1] to be multiplied by anisotropyStrength. */\r\n        anisotropyTexture: glTFTextureInfo;\r\n    }\r\n\r\n}\r\n\r\nexport class KHR_materials_anisotropy implements glTFExtension {\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    loadAdditionTextures(basePath: string, progress?: IBatchProgress): Promise<any> {\r\n        let materials = this._resource.data.materials;\r\n        let textures = this._resource.data.textures;\r\n\r\n        if (materials && textures) {\r\n            let promises: Array<Promise<Texture2D>> = [];\r\n            materials.forEach(material => {\r\n                let extension: glTF.glTFMaterialAnisotropy = material.extensions?.KHR_materials_anisotropy;\r\n                if (extension) {\r\n                    if (extension.anisotropyTexture) {\r\n                        let promise = this._resource.loadTextureFromInfo(extension.anisotropyTexture, false, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                }\r\n            });\r\n            return Promise.all(promises);\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n\r\n    additionMaterialProperties(glTFMaterial: glTF.glTFMaterial, material: Material): void {\r\n        let extension: glTF.glTFMaterialAnisotropy = glTFMaterial.extensions.KHR_materials_anisotropy;\r\n\r\n        let anisotropy = extension.anisotropyStrength ?? 0.0;\r\n        let rotation = extension.anisotropyRotation ?? 0.0;\r\n\r\n        material.setDefine(PBRShaderLib.DEFINE_ANISOTROPY, true);\r\n        material.setFloat(\"u_AnisotropyStrength\", anisotropy);\r\n        material.setFloat(\"u_AnisotropyRotation\", rotation);\r\n\r\n        if (extension.anisotropyTexture) {\r\n            let tex = this._resource.getTextureWithInfo(extension.anisotropyTexture);\r\n            material.setTexture(\"u_AnisotropyTexture\", tex);\r\n            material.setDefine(glTFShader.Define_AnisotropyMap, true);\r\n        }\r\n    }\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_anisotropy(resource));","import { Material } from \"../../d3/core/material/Material\";\r\nimport { PBRMaterial } from \"../../d3/core/material/PBRMaterial\";\r\nimport { PBRShaderLib } from \"../../d3/shader/pbr/PBRShaderLib\";\r\nimport { IBatchProgress } from \"../../net/BatchProgress\";\r\nimport { Texture2D } from \"../../resource/Texture2D\";\r\nimport * as glTF from \"../glTFInterface\";\r\n\r\nimport { glTFResource } from \"../glTFResource\";\r\nimport { glTFShader } from \"../shader/glTFShader\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\n\r\nconst ExtensionName = \"KHR_materials_clearcoat\";\r\n\r\ndeclare module \"../glTFInterface\" {\r\n\r\n    export interface glTFMaterialClearCoat {\r\n        /** The clearcoat layer intensity. default: 0.0*/\r\n        clearcoatFactor?: number;\r\n        /** The base color texture */\r\n        clearcoatTexture?: glTFTextureInfo;\r\n        /** The clearcoat layer roughness.  default: 0.0*/\r\n        clearcoatRoughnessFactor?: number;\r\n        /** The clearcoat layer roughness texture.*/\r\n        clearcoatRoughnessTexture?: glTFTextureInfo;\r\n        /** The clearcoat normal map texture. */\r\n        clearcoatNormalTexture?: glTFMaterialNormalTextureInfo;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @internal\r\n * https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat\r\n * \r\n * exclusions: KHR_materials_pbrSpecularGlossiness, KHR_materials_unlit\r\n */\r\nexport class KHR_materials_clearcoat implements glTFExtension {\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    loadAdditionTextures(basePath: string, progress?: IBatchProgress): Promise<any> {\r\n        let materials = this._resource.data.materials;\r\n        let textures = this._resource.data.textures;\r\n\r\n        if (materials && textures) {\r\n            let promises: Array<Promise<Texture2D>> = [];\r\n            materials.forEach(material => {\r\n                let extension: glTF.glTFMaterialClearCoat = material.extensions?.KHR_materials_clearcoat;\r\n                if (extension) {\r\n                    if (extension.clearcoatTexture) {\r\n                        let promise = this._resource.loadTextureFromInfo(extension.clearcoatTexture, false, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                    if (extension.clearcoatRoughnessTexture) {\r\n                        let promise = this._resource.loadTextureFromInfo(extension.clearcoatRoughnessTexture, false, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                    if (extension.clearcoatNormalTexture) {\r\n                        let promise = this._resource.loadTextureFromInfo(extension.clearcoatNormalTexture, false, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                }\r\n            });\r\n            return Promise.all(promises);\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n\r\n    additionMaterialProperties(glTFMaterial: glTF.glTFMaterial, material: Material): void {\r\n        let extension: glTF.glTFMaterialClearCoat = glTFMaterial.extensions.KHR_materials_clearcoat;\r\n        let clearCoat = extension.clearcoatFactor ?? 0.0;\r\n        let clearCoatRoughness = extension.clearcoatRoughnessFactor ?? 0.0;\r\n\r\n        material.setDefine(PBRShaderLib.DEFINE_CLEARCOAT, true);\r\n\r\n        material.setFloat(\"u_ClearCoatFactor\", clearCoat);\r\n        if (extension.clearcoatTexture) {\r\n            this._resource.setMaterialTextureProperty(material, extension.clearcoatTexture, \"u_ClearCoatTexture\", glTFShader.Define_ClearCoatMap, \"u_ClearCoatMapTransform\", glTFShader.Define_ClearCoatMapTransform);\r\n        }\r\n\r\n        material.setFloat(\"u_ClearCoatRoughness\", clearCoatRoughness);\r\n        if (extension.clearcoatRoughnessTexture) {\r\n            this._resource.setMaterialTextureProperty(material, extension.clearcoatRoughnessTexture, \"u_ClearCoatRoughnessTexture\", glTFShader.Define_ClearCoatRoughnessMap, \"u_ClearCoatRoughnessMapTransform\", glTFShader.Define_ClearCoatRoughnessMapTransform);\r\n        }\r\n\r\n        if (extension.clearcoatNormalTexture) {\r\n            material.setDefine(PBRShaderLib.DEFINE_CLEARCOAT_NORMAL, true);\r\n\r\n            this._resource.setMaterialTextureProperty(material, extension.clearcoatNormalTexture, \"u_ClearCoatNormalTexture\", null, \"u_ClearCoatNormalMapTransform\", glTFShader.Define_ClearCoatNormalMapTransform);\r\n\r\n            let scale = extension.clearcoatNormalTexture.scale ?? 1.0;\r\n            material.setFloat(\"u_ClearCoatNormalScale\", scale);\r\n\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_clearcoat(resource));","import { Material } from \"../../d3/core/material/Material\";\r\nimport { IBatchProgress } from \"../../net/BatchProgress\";\r\nimport { glTFMaterial } from \"../glTFInterface\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\n\r\nimport * as glTF from \"../glTFInterface\";\r\nimport { glTFResource } from \"../glTFResource\";\r\nimport { PBRStandardMaterial } from \"../../d3/core/material/PBRStandardMaterial\";\r\n\r\nconst ExtensionName = \"KHR_materials_emissive_strength\";\r\n\r\ndeclare module \"../glTFInterface\" {\r\n\r\n    export interface glTFMaterialEmissionStrength {\r\n        /** The strength adjustment to be multiplied with the material's emissive value. default: 1.0 */\r\n        emissiveStrength: number;\r\n    }\r\n\r\n}\r\n\r\nexport class KHR_materials_emissive_strength implements glTFExtension {\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    additionMaterialProperties(glTFMaterial: glTFMaterial, material: Material): void {\r\n\r\n        let extension: glTF.glTFMaterialEmissionStrength = glTFMaterial.extensions.KHR_materials_emissive_strength;\r\n\r\n        let emissionStrength = extension.emissiveStrength ?? 1.0;\r\n\r\n        material.setFloat(\"u_EmissionStrength\", emissionStrength);\r\n    }\r\n\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_emissive_strength(resource));","import * as glTF from \"../glTFInterface\";\r\n\r\nimport { Material } from \"../../d3/core/material/Material\";\r\nimport { PBRShaderLib } from \"../../d3/shader/pbr/PBRShaderLib\";\r\nimport { glTFResource } from \"../glTFResource\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\n\r\nconst ExtensionName = \"KHR_materials_ior\";\r\n\r\ndeclare module \"../glTFInterface\" {\r\n\r\n    export interface glTFMaterialIOR {\r\n        /** The index of refraction. default: 1.5 */\r\n        ior: number;\r\n    }\r\n\r\n}\r\n\r\nexport class KHR_materials_ior implements glTFExtension {\r\n\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    additionMaterialProperties(glTFMaterial: glTF.glTFMaterial, material: Material): void {\r\n        let extension: glTF.glTFMaterialIOR = glTFMaterial.extensions.KHR_materials_ior;\r\n\r\n        let ior = extension.ior ?? 1.5;\r\n\r\n        material.setDefine(PBRShaderLib.DEFINE_IOR, true);\r\n        material.setFloat(\"u_Ior\", ior);\r\n    }\r\n\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_ior(resource));","import * as glTF from \"../glTFInterface\";\r\n\r\nimport { IBatchProgress } from \"../../net/BatchProgress\";\r\nimport { Texture2D } from \"../../resource/Texture2D\";\r\nimport { glTFResource } from \"../glTFResource\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\nimport { Material } from \"../../d3/core/material/Material\";\r\nimport { PBRShaderLib } from \"../../d3/shader/pbr/PBRShaderLib\";\r\nimport { glTFShader } from \"../shader/glTFShader\";\r\n\r\nconst ExtensionName = \"KHR_materials_iridescence\";\r\n\r\ndeclare module \"../glTFInterface\" {\r\n\r\n    export interface glTFMaterialIridescence {\r\n        /** The iridescence intensity factor. default: 0.0 */\r\n        iridescenceFactor: number;\r\n        /** The iridescence intensity texture. */\r\n        iridescenceTexture: glTFTextureInfo;\r\n        /** The index of refraction of the dielectric thin-film layer. default: 1.3 */\r\n        iridescenceIor: number;\r\n        /** The minimum thickness of the thin-film layer given in nanometers. default: 100.0 */\r\n        iridescenceThicknessMinimum: number;\r\n        /** The maximum thickness of the thin-film layer given in nanometers. default: 400.0 */\r\n        iridescenceThicknessMaximum: number;\r\n        /** The thickness texture of the thin-film layer. */\r\n        iridescenceThicknessTexture: glTFTextureInfo;\r\n    }\r\n\r\n}\r\n\r\nexport class KHR_materials_iridescence implements glTFExtension {\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n\r\n    loadAdditionTextures(basePath: string, progress?: IBatchProgress): Promise<any> {\r\n        let materials = this._resource.data.materials;\r\n        let textures = this._resource.data.textures;\r\n\r\n        if (materials && textures) {\r\n            let promises: Array<Promise<Texture2D>> = [];\r\n            materials.forEach(material => {\r\n                let extension: glTF.glTFMaterialIridescence = material.extensions?.KHR_materials_iridescence;\r\n                if (extension) {\r\n                    if (extension.iridescenceTexture) {\r\n                        let promise = this._resource.loadTextureFromInfo(extension.iridescenceTexture, false, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                    if (extension.iridescenceThicknessTexture) {\r\n                        let promise = this._resource.loadTextureFromInfo(extension.iridescenceThicknessTexture, false, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                }\r\n            });\r\n\r\n            return Promise.all(promises);\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n\r\n    additionMaterialProperties(glTFMaterial: glTF.glTFMaterial, material: Material): void {\r\n        let extension: glTF.glTFMaterialIridescence = glTFMaterial.extensions.KHR_materials_iridescence;\r\n\r\n        let factor = extension.iridescenceFactor ?? 0.0;\r\n        let ior = extension.iridescenceIor ?? 1.3;\r\n        let thicknessMin = extension.iridescenceThicknessMinimum ?? 100;\r\n        let thicknessMax = extension.iridescenceThicknessMaximum ?? 400;\r\n\r\n        material.setDefine(PBRShaderLib.DEFINE_IRIDESCENCE, true);\r\n        material.setFloat(\"u_IridescenceFactor\", factor);\r\n        material.setFloat(\"u_IridescenceIor\", ior);\r\n        material.setFloat(\"u_IridescenceThicknessMinimum\", thicknessMin);\r\n        material.setFloat(\"u_IridescenceThicknessMaximum\", thicknessMax);\r\n\r\n        if (extension.iridescenceTexture) {\r\n            this._resource.setMaterialTextureProperty(material, extension.iridescenceTexture, \"u_IridescenceTexture\", glTFShader.Define_IridescenceMap, \"u_IridescenceMapTransform\", glTFShader.Define_IridescenceMapTransform);\r\n        }\r\n\r\n        if (extension.iridescenceThicknessTexture) {\r\n            this._resource.setMaterialTextureProperty(material, extension.iridescenceThicknessTexture, \"u_IridescenceThicknessTexture\", glTFShader.Define_IridescenceThicknessMap, \"u_IridescenceThicknessMapTransform\", glTFShader.Define_IridescenceThicknessMapTransform);\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_iridescence(resource));\r\n","import * as glTF from \"../glTFInterface\";\r\n\r\nimport { Material } from \"../../d3/core/material/Material\";\r\nimport { IBatchProgress } from \"../../net/BatchProgress\";\r\nimport { glTFMaterial } from \"../glTFInterface\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\nimport { glTFResource } from \"../glTFResource\";\r\nimport { Texture2D } from \"../../resource/Texture2D\";\r\nimport { Vector3 } from \"../../maths/Vector3\";\r\nimport { PBRShaderLib } from \"../../d3/shader/pbr/PBRShaderLib\";\r\nimport { glTFShader } from \"../shader/glTFShader\";\r\n\r\nconst ExtensionName = \"KHR_materials_sheen\";\r\n\r\ndeclare module \"../glTFInterface\" {\r\n\r\n    export interface glTFMaterialSheen {\r\n        /** The sheen color in linear space. default: [0, 0, 0] */\r\n        sheenColorFactor: number[];\r\n        /** The sheen color (RGB) in sRGB transfer function. */\r\n        sheenColorTexture: glTFTextureInfo;\r\n        /** The sheen roughness. default: 0.0 */\r\n        sheenRoughnessFactor: number;\r\n        /** The sheen roughness (Alpha) texture. */\r\n        sheenRoughnessTexture: glTFTextureInfo;\r\n    }\r\n\r\n}\r\n\r\n\r\nexport class KHR_materials_sheen implements glTFExtension {\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    loadAdditionTextures(basePath: string, progress?: IBatchProgress): Promise<any> {\r\n        let materials = this._resource.data.materials;\r\n        let textures = this._resource.data.textures;\r\n\r\n        if (materials && textures) {\r\n            let promises: Array<Promise<Texture2D>> = [];\r\n            materials.forEach(material => {\r\n                let extension: glTF.glTFMaterialSheen = material.extensions?.KHR_materials_sheen;\r\n                if (extension) {\r\n                    if (extension.sheenColorTexture) {\r\n                        let sRGB = false;\r\n                        let promise = this._resource.loadTextureFromInfo(extension.sheenColorTexture, sRGB, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                    if (extension.sheenRoughnessTexture) {\r\n                        let sRGB = false;\r\n                        let promise = this._resource.loadTextureFromInfo(extension.sheenRoughnessTexture, sRGB, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                }\r\n            });\r\n\r\n            return Promise.all(promises);\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n    additionMaterialProperties(glTFMaterial: glTFMaterial, material: Material): void {\r\n        let extension: glTF.glTFMaterialSheen = glTFMaterial.extensions.KHR_materials_sheen;\r\n\r\n        material.setDefine(PBRShaderLib.DEFINE_SHEEN, true);\r\n\r\n        let sheenColorFactor = new Vector3(0, 0, 0);\r\n        if (extension.sheenColorFactor) {\r\n            sheenColorFactor.fromArray(extension.sheenColorFactor);\r\n        }\r\n        let sheenRoughnessFactor = extension.sheenRoughnessFactor ?? 0.0;\r\n\r\n        material.setVector3(\"u_SheenColorFactor\", sheenColorFactor);\r\n        material.setFloat(\"u_SheenRoughness\", sheenRoughnessFactor);\r\n\r\n        if (extension.sheenColorTexture) {\r\n            this._resource.setMaterialTextureProperty(material, extension.sheenColorTexture, \"u_SheenColorTexture\", glTFShader.Define_SheenColorMap, \"u_SheenColorMapTransform\", glTFShader.Define_SheenColorMapTransform);\r\n        }\r\n\r\n        if (extension.sheenRoughnessTexture) {\r\n            this._resource.setMaterialTextureProperty(material, extension.sheenRoughnessTexture, \"u_SheenRoughnessTexture\", glTFShader.Define_SheenRoughnessMap, \"u_SheenRoughnessMapTransform\", glTFShader.Define_SheenRoughnessMapTransform);\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_sheen(resource));","import * as glTF from \"../glTFInterface\";\r\n\r\nimport { Material, MaterialRenderMode } from \"../../d3/core/material/Material\";\r\nimport { IBatchProgress } from \"../../net/BatchProgress\";\r\nimport { Texture2D } from \"../../resource/Texture2D\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\nimport { glTFResource } from \"../glTFResource\";\r\nimport { PBRShaderLib } from \"../../d3/shader/pbr/PBRShaderLib\";\r\nimport { glTFShader } from \"../shader/glTFShader\";\r\n\r\nconst ExtensionName = \"KHR_materials_transmission\";\r\n\r\ndeclare module \"../glTFInterface\" {\r\n\r\n    export interface glTFMaterialTransmission {\r\n        /** The base percentage of light that is transmitted through the surface. default: 0 */\r\n        transmissionFactor: number;\r\n        /** A texture that defines the transmission percentage of the surface, stored in the R channel. */\r\n        transmissionTexture: glTFTextureInfo;\r\n    }\r\n\r\n}\r\n\r\nexport class KHR_materials_transmission implements glTFExtension {\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    loadAdditionTextures(basePath: string, progress?: IBatchProgress): Promise<any> {\r\n        let materials = this._resource.data.materials;\r\n        let textures = this._resource.data.textures;\r\n\r\n        if (materials && textures) {\r\n            let promises: Array<Promise<Texture2D>> = [];\r\n            materials.forEach(material => {\r\n                let extension: glTF.glTFMaterialTransmission = material.extensions?.KHR_materials_transmission;\r\n                if (extension) {\r\n                    if (extension.transmissionTexture) {\r\n                        let sRGB = false;\r\n                        let promise = this._resource.loadTextureFromInfo(extension.transmissionTexture, sRGB, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                }\r\n            });\r\n            return Promise.all(promises);\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n\r\n    additionMaterialProperties(glTFMaterial: glTF.glTFMaterial, material: Material): void {\r\n        let extension: glTF.glTFMaterialTransmission = glTFMaterial.extensions.KHR_materials_transmission;\r\n\r\n        let transmissionFactor = extension.transmissionFactor ?? 0.0;\r\n        material.materialRenderMode = MaterialRenderMode.RENDERMODE_CUSTOME;\r\n        material.renderQueue = 3000;\r\n\r\n        material.setDefine(PBRShaderLib.DEFINE_TRANSMISSION, true);\r\n\r\n        material.setFloat(\"u_TransmissionFactor\", transmissionFactor);\r\n\r\n        if (extension.transmissionTexture) {\r\n            this._resource.setMaterialTextureProperty(material, extension.transmissionTexture, \"u_TransmissionTexture\", glTFShader.Define_TransmissionMap, \"u_TransmissionMapTransform\", glTFShader.Define_TransmissionMapTransform);\r\n        }\r\n    }\r\n\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_transmission(resource));","import * as glTF from \"../glTFInterface\";\r\n\r\nimport { Material } from \"../../d3/core/material/Material\";\r\nimport { IBatchProgress } from \"../../net/BatchProgress\";\r\nimport { Texture2D } from \"../../resource/Texture2D\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\nimport { glTFResource } from \"../glTFResource\";\r\nimport { glTFShader } from \"../shader/glTFShader\";\r\nimport { Vector3 } from \"../../maths/Vector3\";\r\nimport { PBRShaderLib } from \"../../d3/shader/pbr/PBRShaderLib\";\r\n\r\nconst ExtensionName = \"KHR_materials_volume\";\r\n\r\ndeclare module \"../glTFInterface\" {\r\n\r\n    export interface glTFMaterialVolume {\r\n        /** The thickness of the volume beneath the surface. default: 0.0 */\r\n        thicknessFactor: number;\r\n        /** A texture that defines the thickness, stored in the G channel. */\r\n        thicknessTexture: glTFTextureInfo;\r\n        /** Density of the medium given as the average distance that light travels in the medium before interacting with a particle. default: +Infinity */\r\n        attenuationDistance: number;\r\n        /** The color that white light turns into due to absorption when reaching the attenuation distance. default: [1, 1, 1] */\r\n        attenuationColor: number[];\r\n    }\r\n\r\n}\r\n\r\nexport class KHR_materials_volume implements glTFExtension {\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    loadAdditionTextures(basePath: string, progress?: IBatchProgress): Promise<any> {\r\n        let materials = this._resource.data.materials;\r\n        let textures = this._resource.data.textures;\r\n\r\n        if (materials && textures) {\r\n            let promises: Array<Promise<Texture2D>> = [];\r\n\r\n            materials.forEach(material => {\r\n                let extension: glTF.glTFMaterialVolume = material.extensions?.KHR_materials_volume;\r\n                if (extension) {\r\n                    if (extension.thicknessTexture) {\r\n                        let sRGB = false;\r\n                        let promise = this._resource.loadTextureFromInfo(extension.thicknessTexture, sRGB, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                }\r\n            });\r\n\r\n            return Promise.all(promises);\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n\r\n    additionMaterialProperties(glTFMaterial: glTF.glTFMaterial, material: Material): void {\r\n        let extension: glTF.glTFMaterialVolume = glTFMaterial.extensions.KHR_materials_volume;\r\n\r\n        material.setDefine(PBRShaderLib.DEFINE_THICKNESS, true);\r\n\r\n        let thicknessFactor = extension.thicknessFactor ?? 0.0;\r\n        let attenuationDistance = extension.attenuationDistance ?? 65504.0;\r\n\r\n        material.setFloat(\"u_VolumeThicknessFactor\", thicknessFactor);\r\n        material.setFloat(\"u_VolumeAttenuationDistance\", attenuationDistance);\r\n\r\n        let attenuationColor = new Vector3(1, 1, 1);\r\n        if (extension.attenuationColor) {\r\n            attenuationColor.fromArray(extension.attenuationColor);\r\n        }\r\n\r\n        material.setVector3(\"u_VolumeAttenuationColor\", attenuationColor);\r\n\r\n        if (extension.thicknessTexture) {\r\n            this._resource.setMaterialTextureProperty(material, extension.thicknessTexture, \"u_VolumeThicknessTexture\", glTFShader.Define_VolumeThicknessMap, \"u_VoluemThicknessMapTransform\", glTFShader.Define_VolumeThicknessMapTransform);\r\n        }\r\n    }\r\n\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_volume(resource));\r\n\r\n","import * as glTF from \"../glTFInterface\";\r\n\r\nimport { Material } from \"../../d3/core/material/Material\";\r\nimport { IBatchProgress } from \"../../net/BatchProgress\";\r\nimport { Texture2D } from \"../../resource/Texture2D\";\r\nimport { glTFResource } from \"../glTFResource\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\nimport { Vector3 } from \"../../maths/Vector3\";\r\nimport { glTFShader } from \"../shader/glTFShader\";\r\nimport { Shader3D } from \"../../RenderEngine/RenderShader/Shader3D\";\r\n\r\nconst ExtensionName = \"KHR_materials_specular\";\r\n\r\ndeclare module \"../glTFInterface\" {\r\n\r\n    export interface glTFMaterialSpecular {\r\n        /** The strength of the specular reflection. default: 1.0 */\r\n        specularFactor: number;\r\n        /** A texture that defines the strength of the specular reflection, stored in the alpha (A) channel. This will be multiplied by specularFactor. */\r\n        specularTexture: glTFTextureInfo;\r\n        /** The F0 color of the specular reflection (linear RGB). default: [1.0, 1.0, 1.0] */\r\n        specularColorFactor: number[];\r\n        /** A texture that defines the F0 color of the specular reflection, stored in the RGB channels and encoded in sRGB. This texture will be multiplied by specularColorFactor. */\r\n        specularColorTexture: glTFTextureInfo;\r\n    }\r\n\r\n}\r\n\r\nexport class KHR_materials_specular implements glTFExtension {\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    loadAdditionTextures(basePath: string, progress?: IBatchProgress): Promise<Texture2D[]> {\r\n        let promises: Array<Promise<Texture2D>> = [];\r\n\r\n        let materials = this._resource.data.materials;\r\n        let textures = this._resource.data.textures;\r\n        if (materials && textures) {\r\n            materials.forEach(material => {\r\n                let extension: glTF.glTFMaterialSpecular = material.extensions?.KHR_materials_specular;\r\n                if (extension) {\r\n                    if (extension.specularTexture) {\r\n                        let sRGB = false;\r\n                        let promise = this._resource.loadTextureFromInfo(extension.specularTexture, sRGB, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                    if (extension.specularColorTexture) {\r\n                        let sRGB = true;\r\n                        let promise = this._resource.loadTextureFromInfo(extension.specularColorTexture, sRGB, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        return Promise.all(promises);\r\n    }\r\n\r\n    additionMaterialProperties(glTFMaterial: glTF.glTFMaterial, material: Material): void {\r\n        let extension: glTF.glTFMaterialSpecular = glTFMaterial.extensions.KHR_materials_specular;\r\n\r\n        let specularFactor = extension.specularFactor ?? 1.0;\r\n        let specularColorFactor = new Vector3(1.0, 1.0, 1.0);\r\n        if (extension.specularColorFactor) {\r\n            specularColorFactor.fromArray(extension.specularColorFactor);\r\n        }\r\n\r\n        material.setDefine(Shader3D.getDefineByName(\"SPECULAR\"), true);\r\n\r\n        material.setFloat(\"u_SpecularFactor\", specularFactor);\r\n        material.setVector3(\"u_SpecularColorFactor\", specularColorFactor);\r\n\r\n        if (extension.specularTexture) {\r\n            this._resource.setMaterialTextureProperty(material, extension.specularTexture, \"u_SpecularFactorTexture\", glTFShader.Define_SpecularFactorMap, \"u_SpecularFactorMapTransfrom\", glTFShader.Define_SpecularFactorMapTransform);\r\n        }\r\n\r\n        if (extension.specularColorTexture) {\r\n            this._resource.setMaterialTextureProperty(material, extension.specularColorTexture, \"u_SpecularColorTexture\", glTFShader.Define_SpecularColorMap, \"u_SpecularColorMapTransform\", glTFShader.Define_SpecularColorMapTransform);\r\n        }\r\n    }\r\n\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_specular(resource));","import * as glTF from \"../glTFInterface\";\r\n\r\nimport { Material } from \"../../d3/core/material/Material\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\nimport { UnlitMaterial } from \"../../d3/core/material/UnlitMaterial\";\r\nimport { glTFResource } from \"../glTFResource\";\r\n\r\nconst ExtensionName = \"KHR_materials_unlit\";\r\n\r\n/**\r\n * @internal\r\n * https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/README.md\r\n */\r\nexport class KHR_materials_unlit implements glTFExtension {\r\n\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    createMaterial(glTFMaterial: glTF.glTFMaterial): Material {\r\n        let unlit = new UnlitMaterial();\r\n\r\n        let pbrMetallicRoughness = glTFMaterial.pbrMetallicRoughness;\r\n        if (pbrMetallicRoughness) {\r\n            if (pbrMetallicRoughness.baseColorFactor) {\r\n                let color = unlit.albedoColor;\r\n                color.fromArray(pbrMetallicRoughness.baseColorFactor);\r\n                color.toGamma(color);\r\n                unlit.albedoColor = color;\r\n            }\r\n\r\n            if (pbrMetallicRoughness.baseColorTexture) {\r\n                unlit.albedoTexture = this._resource.getTextureWithInfo(pbrMetallicRoughness.baseColorTexture);\r\n            }\r\n        }\r\n\r\n        this._resource.applyMaterialRenderState(glTFMaterial, unlit);\r\n\r\n        return unlit;\r\n    }\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_unlit(resource));\r\n","import { ILoadTask, IResourceLoader, Loader } from \"../net/Loader\";\r\nimport * as glTF from \"./glTFInterface\";\r\nimport { glTFResource } from \"./glTFResource\";\r\n\r\nimport \"./extensions/KHR_texture_transform\";\r\nimport \"./extensions/KHR_materials_anisotropy\";\r\nimport \"./extensions/KHR_materials_clearcoat\";\r\nimport \"./extensions/KHR_materials_emissive_strength\";\r\nimport \"./extensions/KHR_materials_ior\";\r\nimport \"./extensions/KHR_materials_iridescence\";\r\nimport \"./extensions/KHR_materials_sheen\";\r\nimport \"./extensions/KHR_materials_transmission\";\r\nimport \"./extensions/KHR_materials_volume\";\r\nimport \"./extensions/KHR_materials_specular\";\r\nimport \"./extensions/KHR_materials_unlit\";\r\n\r\nclass glTFLoader implements IResourceLoader {\r\n    load(task: ILoadTask) {\r\n        return task.loader.fetch(task.url, \"json\", task.progress.createCallback(0.5), task.options).then((data: glTF.glTF) => {\r\n            let glTF = new glTFResource();\r\n            return glTF._parse(data, task.url, task.progress).then(() => glTF);\r\n        });\r\n    }\r\n}\r\n\r\nLoader.registerLoader([\"gltf\"], glTFLoader);\r\n\r\nclass glbLoader implements IResourceLoader {\r\n    load(task: ILoadTask): Promise<any> {\r\n        return task.loader.fetch(task.url, \"arraybuffer\", task.progress.createCallback(0.5), task.options).then((data: ArrayBuffer) => {\r\n            let glTF = new glTFResource();\r\n            return glTF._parseglb(data, task.url, task.progress).then(() => glTF);\r\n        });\r\n    }\r\n}\r\n\r\nLoader.registerLoader([\"glb\"], glbLoader);\r\n"],"mappings":"kCAoBaA,WAyDTC,cAEIC,KAAKC,oBAAsBC,WAASC,gBAAgB,gBACpDH,KAAKI,6BAA+BF,WAASC,gBAAgB,0BAE7DH,KAAKK,4BAA8BH,WAASC,gBAAgB,wBAC5DH,KAAKM,qCAAuCJ,WAASC,gBAAgB,kCACrEH,KAAKO,iBAAmBL,WAASC,gBAAgB,aACjDH,KAAKQ,0BAA4BN,WAASC,gBAAgB,uBAC1DH,KAAKS,oBAAsBP,WAASC,gBAAgB,gBACpDH,KAAKU,6BAA+BR,WAASC,gBAAgB,0BAC7DH,KAAKW,mBAAqBT,WAASC,gBAAgB,eACnDH,KAAKY,4BAA8BV,WAASC,gBAAgB,yBAE5DH,KAAKa,oBAAsBX,WAASC,gBAAgB,gBACpDH,KAAKc,6BAA+BZ,WAASC,gBAAgB,0BAC7DH,KAAKe,6BAA+Bb,WAASC,gBAAgB,0BAC7DH,KAAKgB,sCAAwCd,WAASC,gBAAgB,oCACtEH,KAAKiB,mCAAqCf,WAASC,gBAAgB,iCAEnEH,KAAKkB,qBAAuBhB,WAASC,gBAAgB,iBACrDH,KAAKmB,8BAAgCjB,WAASC,gBAAgB,2BAE9DH,KAAKoB,sBAAwBlB,WAASC,gBAAgB,kBACtDH,KAAKqB,+BAAiCnB,WAASC,gBAAgB,4BAC/DH,KAAKsB,+BAAiCpB,WAASC,gBAAgB,4BAC/DH,KAAKuB,wCAA0CrB,WAASC,gBAAgB,sCAExEH,KAAKwB,qBAAuBtB,WAASC,gBAAgB,iBACrDH,KAAKyB,8BAAgCvB,WAASC,gBAAgB,2BAC9DH,KAAK0B,yBAA2BxB,WAASC,gBAAgB,sBACzDH,KAAK2B,kCAAoCzB,WAASC,gBAAgB,gCAElEH,KAAK4B,uBAAyB1B,WAASC,gBAAgB,mBACvDH,KAAK6B,gCAAkC3B,WAASC,gBAAgB,6BAEhEH,KAAK8B,0BAA4B5B,WAASC,gBAAgB,gBAC1DH,KAAK+B,mCAAqC7B,WAASC,gBAAgB,0BAEnEH,KAAKgC,yBAA2B9B,WAASC,gBAAgB,qBACzDH,KAAKiC,kCAAoC/B,WAASC,gBAAgB,+BAClEH,KAAKkC,wBAA0BhC,WAASC,gBAAgB,oBACxDH,KAAKmC,iCAAmCjC,WAASC,gBAAgB,8BAGjE,IAAIiC,EAASlC,WAASmC,KAAKvC,WAAWwC,MACtC,GAAIF,EACA,OAGJlC,WAASqC,WAAW,6BC/Hb,w9IDgIP,IAAIC,EAAa,CAEbC,iBAAoBC,iBAAeC,MAGnCC,kBAAqBF,iBAAeG,QACpCC,mBAAsBJ,iBAAeK,UACrCC,wBAA2BN,iBAAeO,UAC1CC,WAAcR,iBAAeC,MAC7BQ,iBAAoBT,iBAAeC,MACnCS,kBAAqBV,iBAAeC,MACpCU,2BAA8BX,iBAAeK,UAC7CO,gCAAmCZ,iBAAeO,UAElDM,gBAAmBb,iBAAeK,UAClCS,qBAAwBd,iBAAeO,UACvCQ,cAAiBf,iBAAeC,MAEhCe,mBAAsBhB,iBAAeK,UACrCY,wBAA2BjB,iBAAeO,UAC1CW,oBAAuBlB,iBAAeC,MAEtCkB,iBAAoBnB,iBAAeoB,QACnCC,kBAAqBrB,iBAAeK,UACpCiB,uBAA0BtB,iBAAeO,UACzCgB,mBAAsBvB,iBAAeC,MAGrCuB,kBAAqBxB,iBAAeC,MACpCwB,mBAAsBzB,iBAAeK,UACrCqB,wBAA2B1B,iBAAeO,UAC1CoB,qBAAwB3B,iBAAeC,MACvC2B,4BAA+B5B,iBAAeK,UAC9CwB,iCAAoC7B,iBAAeO,UACnDuB,yBAA4B9B,iBAAeK,UAC3C0B,8BAAiC/B,iBAAeO,UAChDyB,uBAA0BhC,iBAAeC,MAGzCgC,qBAAwBjC,iBAAeC,MACvCiC,qBAAwBlC,iBAAeC,MACvCkC,oBAAuBnC,iBAAeK,UACtC+B,yBAA4BpC,iBAAeO,UAG3C8B,MAASrC,iBAAeC,MAGxBqC,oBAAuBtC,iBAAeC,MACtCsC,qBAAwBvC,iBAAeK,UACvCmC,0BAA6BxC,iBAAeO,UAC5CkC,iBAAoBzC,iBAAeC,MACnCyC,8BAAiC1C,iBAAeC,MAChD0C,8BAAiC3C,iBAAeC,MAChD2C,8BAAiC5C,iBAAeK,UAChDwC,mCAAsC7C,iBAAeO,UAGrDuC,mBAAsB9C,iBAAeoB,QACrC2B,oBAAuB/C,iBAAeK,UACtC2C,yBAA4BhD,iBAAeO,UAC3C0C,iBAAoBjD,iBAAeC,MACnCiD,wBAA2BlD,iBAAeK,UAC1C8C,6BAAgCnD,iBAAeO,UAG/C6C,qBAAwBpD,iBAAeC,MACvCoD,sBAAyBrD,iBAAeK,UACxCiD,2BAA8BtD,iBAAeO,UAG7CgD,wBAA2BvD,iBAAeC,MAC1CuD,yBAA4BxD,iBAAeK,UAC3CoD,8BAAiCzD,iBAAeO,UAChDmD,4BAA+B1D,iBAAeC,MAC9C0D,yBAA4B3D,iBAAeoB,QAG3CwC,iBAAoB5D,iBAAeC,MACnC4D,wBAA2B7D,iBAAeK,UAC1CyD,6BAAgC9D,iBAAeO,UAE/CwD,sBAAyB/D,iBAAeoB,QACxC4C,uBAA0BhE,iBAAeK,UACzC4D,4BAA+BjE,iBAAeO,WAI9C2D,EAAe,CAEfnE,iBAAoB,GAEpBG,kBAAqBC,UAAQgE,IAC7B7D,wBAA2BC,YAAU6D,QACrC5D,WAAc,GACdC,iBAAoB,EACpBC,kBAAqB,EACrBE,gCAAmCL,YAAU6D,QAE7CtD,qBAAwBP,YAAU6D,QAClCrD,cAAiB,EACjBE,wBAA2BV,YAAU6D,QACrClD,oBAAuB,EAEvBC,iBAAoBC,UAAQiD,KAC5B/C,uBAA0Bf,YAAU6D,QACpC7C,mBAAsB,EAGtBqC,iBAAoB,EACpBE,6BAAgCvD,YAAU6D,QAC1CL,sBAAyB3C,UAAQ+C,IACjCF,4BAA+B1D,YAAU6D,QAEzC/B,MAAS,IAGTb,kBAAqB,EACrBE,wBAA2BnB,YAAU6D,QACrCzC,qBAAwB,EACxBE,iCAAoCtB,YAAU6D,QAC9CrC,8BAAiCxB,YAAU6D,QAC3CpC,uBAA0B,EAG1BC,qBAAwB,EACxBC,qBAAwB,EACxBE,yBAA4B7B,YAAU6D,QAGtC9B,oBAAuB,EACvBE,0BAA6BjC,YAAU6D,QACvC3B,iBAAoB,KACpBC,8BAAiC,IACjCC,8BAAiC,IACjCE,mCAAsCtC,YAAU6D,QAGhDtB,mBAAsB1B,UAAQiD,KAC9BrB,yBAA4BzC,YAAU6D,QACtCnB,iBAAoB,EACpBE,6BAAgC5C,YAAU6D,QAG1ChB,qBAAwB,EACxBE,2BAA8B/C,YAAU6D,SAG5C1E,EAASlC,WAAS8G,IAAI,WAAW,GAAM,GACvC,IAAIC,EAAY,IAAIC,YAAUA,YAAUC,oBAAqB3E,EAAYoE,GACzExE,EAAOgF,aAAaH,GAEFA,EAAUI,cExRrB,2kBCAA,w0fHyRSJ,EAAUI,cIzRnB,4iBCAA,wILyRmD,gBACpCJ,EAAUI,cM1RzB,smBCAA,s9BP0RqE,c,EApQzEvH,WAAUwH,WAAW,UQkC1B,MAAOC,qBAAqBC,SA6B9BC,cACIC,MAAM,GAEN1H,KAAK2H,SAAW,GAChB3H,KAAK4H,UAAY,GACjB5H,KAAK6H,WAAa,GAClB7H,KAAK8H,QAAU,GACf9H,KAAK+H,YAAc,IAAIC,IACvBhI,KAAKiI,YAAc,GACnBjI,KAAKkI,QAAU,GACflI,KAAKmI,OAAS,E,CAnClBpI,yBAAyBuC,EAAc8F,GACnCpI,KAAKqI,YAAY/F,GAAQ8F,C,CAKzBE,WACA,OAAOtI,KAAKuI,K,CAqChBC,WAAWC,EAAkBC,GACzB,IAAIJ,EAAOtI,KAAKuI,MAChB,GAAID,EAAKK,QAAS,CACd,IAAIC,EAAgC,GAcpC,OAbAN,EAAKK,QAAQE,SAAQ,CAACC,EAAQC,KAC1B,GAAIC,aAAWC,eAAeH,EAAOI,KAAM,CACvC,IAAIC,EAAMH,aAAWI,OAAON,EAAOI,IAAIG,QAAQL,aAAWM,QAAS,KACnEtJ,KAAK2H,SAASoB,GAAKI,CACtB,KACI,CACD,IAAII,EAAIR,EACRH,EAASY,KAAKC,QAAMC,OAAOC,MAAMC,MAAIC,KAAKpB,EAAUK,EAAOI,KAAM,cAAeR,aAAA,EAAAA,EAAUoB,eAAe,KACpGC,MAAKZ,IACFnJ,KAAK2H,SAAS4B,GAAKJ,CAAG,IAEjC,KAEEa,QAAQC,IAAIrB,EACtB,CAEG,OAAOoB,QAAQE,S,CAIvBC,oBAAoBC,EAA4BC,EAAe5B,EAAkBC,GAC7E,IAAIJ,EAAOtI,KAAKuI,MAEZ+B,EAAQF,EAAKE,MACbC,EAAMjC,EAAKkC,SAASF,GACpBG,EAAYF,EAAIG,OAChBC,EAAUrC,EAAKsC,OAAOH,GACtBI,EAAgBN,EAAIO,QACpBC,EAAczC,EAAK0C,SAAW1C,EAAK0C,SAASH,QAAiBI,EAE7DC,EAAkBlL,KAAKmL,0BAA0BR,EAASI,EAAaV,GACvEe,EAAiBpL,KAAKqL,yBAAyBN,GAEnD,GAA0B,MAAtBJ,EAAQW,WAAoB,CAC5B,IAAIA,EAAahD,EAAKiD,YAAYZ,EAAQW,YACtCxC,EAAS9I,KAAK2H,SAAS2D,EAAWxC,QAClC0C,EAAaF,EAAWE,YAAc,EACtCC,EAAaH,EAAWG,WAExBC,EAAc5C,EAAO6C,MAAMH,EAAYA,EAAaC,GAExD,OAAOzL,KAAK4L,sBAAsBF,EAAaf,EAAQkB,SAAUX,EAAiBE,EAAgB1C,GAAUqB,MAAK+B,IAC7G9L,KAAK4H,UAAU0C,GAASwB,EACxB9L,KAAK+L,OAAOD,GACLA,IAEd,CAEG,OAAO9L,KAAKgM,YAAYpC,MAAIC,KAAKpB,EAAUkC,EAAQzB,KAAMgC,EAAiBE,EAAgB1C,GAAUqB,MAAK+B,IACrG9L,KAAK4H,UAAU0C,GAASwB,EACxB9L,KAAK+L,OAAOD,GACLA,I,CAWnBG,aAAaxD,EAAkBC,GAC3B,IAAIJ,EAAOtI,KAAKuI,MACZ2D,EAAY5D,EAAK4D,UACjB1B,EAAWlC,EAAKkC,SAChB5B,EAA6D,GACjE,GAAIsD,GAAa1B,EACb,IAAK,IAAI2B,KAAgB7D,EAAK4D,UAAW,CACrC,IAAIE,EAAuBD,EAAaC,qBACxC,GAAIA,EAAsB,CACtB,GAAIA,EAAqBC,iBAAkB,CACvC,IAAIhC,GAAO,EACPiC,EAAUtM,KAAKmK,oBAAoBiC,EAAqBC,iBAAkBhC,EAAM5B,EAAUC,GAC9FE,EAASY,KAAK8C,EACjB,CACD,GAAIF,EAAqBG,yBAA0B,CAC/C,IAAIlC,GAAO,EACPiC,EAAUtM,KAAKmK,oBAAoBiC,EAAqBG,yBAA0BlC,EAAM5B,EAAUC,GACtGE,EAASY,KAAK8C,EACjB,CACJ,CACD,GAAIH,EAAaK,cAAe,CAC5B,IAAInC,GAAO,EACPiC,EAAUtM,KAAKmK,oBAAoBgC,EAAaK,cAAenC,EAAM5B,EAAUC,GACnFE,EAASY,KAAK8C,EACjB,CACD,GAAIH,EAAaM,iBAAkB,CAC/B,IAAIpC,GAAO,EACPiC,EAAUtM,KAAKmK,oBAAoBgC,EAAaM,iBAAkBpC,EAAM5B,EAAUC,GACtFE,EAASY,KAAK8C,EACjB,CACD,GAAIH,EAAaO,gBAAiB,CAC9B,IAAIrC,GAAO,EACPiC,EAAUtM,KAAKmK,oBAAoBgC,EAAaO,gBAAiBrC,EAAM5B,EAAUC,GACrFE,EAASY,KAAK8C,EACjB,CACJ,CASL,OAPAtM,KAAK+H,YAAYc,SAAQ8D,IACrB,GAAIA,EAAUC,qBAAsB,CAChC,IAAIN,EAAUK,EAAUC,qBAAqBnE,EAAUC,GACvDE,EAASY,KAAK8C,EACjB,KAGEtC,QAAQC,IAAIrB,E,CAOvBiE,kBACI,OAAO7C,QAAQE,UAAUH,MAAK,KAC1B,IAAIzB,EAAOtI,KAAKuI,MACZD,EAAK4D,WACL5D,EAAK4D,UAAUrD,SAAQ,CAACiE,EAASxC,KAC7B,IAAIyC,EAAM/M,KAAKgN,eAAeF,GAC9B9M,KAAK6H,WAAWyC,KAAWyC,EAC3B/M,KAAK+L,OAAOgB,EAAI,GAEvB,G,CAQTE,eACI,OAAOjD,QAAQE,UAAUH,MAAK,KAC1B,IAAIzB,EAAOtI,KAAKuI,MACZD,EAAK4E,QAAU5E,EAAK6E,OACpB7E,EAAK6E,MAAMtE,SAASuE,I,MAChB,GAAqB,MAAjBA,EAASC,KAAc,CACvB,IAAIC,EAAWtN,KAAKuI,MAAM2E,OAAOE,EAASC,MACtCE,EAA8B,QAAnBC,EAAAxN,KAAKuI,MAAMkF,aAAQ,IAAAD,OAAA,EAAAA,EAAAJ,EAASM,MACvCC,EAAMP,EAASC,MAAyB,MAAjBD,EAASM,KAAgB,IAAMN,EAASM,KAAQ,IACvEL,EAAOrN,KAAK8H,QAAQ6F,GACnBN,IACDA,EAAOrN,KAAK4N,WAAWN,EAAUC,GACjCvN,KAAK8H,QAAQ6F,GAAON,EACpBrN,KAAK+L,OAAOsB,GAEnB,IAER,G,CAWTQ,OAAOvF,EAAiBwF,EAAmBpF,G,QACvC,IAAKJ,EAAKyF,OAAgC,QAAvBzF,EAAKyF,MAAMC,QAC1B,MAAM,IAAIC,MAAM,uBAGpBjO,KAAKuI,MAAQD,EACb,IAAIG,EAAWmB,MAAIsE,QAAQJ,GAC3B9N,KAAKmO,WAAa,GAEC,QAAnBX,EAAAlF,EAAK8F,sBAAc,IAAAZ,KAAE3E,SAAQwF,IACzB,IAAIC,EAAmB/G,aAAac,YAAYgG,GAC3CC,EAIDtO,KAAK+H,YAAYwG,IAAIF,EAAOC,EAAiBtO,OAH7CwO,QAAQC,KAAK,qCAAqCJ,IAIrD,IAGkB,QAAvBK,EAAApG,EAAKqG,0BAAkB,IAAAD,KAAE7F,SAAQwF,IACN9G,aAAac,YAAYgG,IAE5CG,QAAQC,KAAK,yCAAyCJ,IACzD,IAGL,IAAI/B,EAAwBtM,KAAKwI,WAAWC,EAAUC,GActD,OAZA4D,EAAUA,EAAQvC,MAAK,IACZ/J,KAAKiM,aAAaxD,EAAUC,KAGvC4D,EAAUA,EAAQvC,MAAK,IACZ/J,KAAKiN,iBAGhBX,EAAUA,EAAQvC,MAAK,IACZ/J,KAAK6M,oBAGTP,EAAQvC,MAAK,IACZ/J,KAAKiI,YAAY2G,OAAS,EACnB5E,QAAQC,IAAIjK,KAAKiI,aAAa8B,MAAK,KACtC/J,KAAKmO,WAAa,IAAI,KAI1BnO,KAAKmO,WAAa,KACXnE,QAAQE,Y,CAW3B2E,UAAUvG,EAAmBwF,EAAmBpF,G,UAC5C,IAAID,EAAWmB,MAAIsE,QAAQJ,GAE3B9N,KAAKmO,WAAa,GAElB,IAAIW,EAAO,IAAIC,OAAKzG,GAGpB,GAAa,YAFDwG,EAAKE,aAGb,MAAM,IAAIf,MAAM,qBAIpB,GAAe,GADDa,EAAKE,aAEf,MAAM,IAAIf,MAAM,sBAIPa,EAAKE,aASlB,IAAIC,EAAmBH,EAAKE,aAE5B,GAAsB,YADDF,EAAKE,aAEtB,MAAM,IAAIf,MAAM,8BAGpB,IAAIiB,EAAiBJ,EAAKK,gBAAgBF,GAEtCG,GADa,IAAIC,aACIjG,OAAO8F,GAC5BI,EAAqBC,KAAKC,MAAMJ,GACpCpP,KAAKuI,MAAQ+G,EAGb,IAAIG,EAAcX,EAAKE,aAEvB,GAAiB,SADDF,EAAKE,aAEjB,MAAM,IAAIf,MAAM,6BAEpB,IAAIyB,EAA6B,QAAflC,EAAA8B,EAAQ3G,eAAO,IAAA6E,OAAA,EAAAA,EAAG,GACpCkC,EAAYjE,WAAaiE,EAAYjE,WAAckE,KAAKC,IAAIF,EAAYjE,WAAYgE,GAAgBA,EAEpGzP,KAAK2H,SAAS,GAAKmH,EAAKK,gBAAgBO,EAAYjE,YAE9B,QAAtBiD,EAAAY,EAAQlB,sBAAc,IAAAM,KAAE7F,SAAQwF,IAC5B,IAAIC,EAAmB/G,aAAac,YAAYgG,GAC3CC,EAIDtO,KAAK+H,YAAYwG,IAAIF,EAAOC,EAAiBtO,OAH7CwO,QAAQC,KAAK,qCAAqCJ,IAIrD,IAIqB,QAA1BwB,EAAAP,EAAQX,0BAAkB,IAAAkB,KAAEhH,SAAQwF,IACT9G,aAAac,YAAYgG,IAE5CG,QAAQC,KAAK,yCAAyCJ,IACzD,IAGL,IAAI/B,EAAwBtM,KAAKiM,aAAaxD,EAAUC,GASxD,OARA4D,EAAUA,EAAQvC,MAAK,IACZ/J,KAAKiN,iBAGhBX,EAAUA,EAAQvC,MAAK,IACZ/J,KAAK6M,oBAGTP,EAAQvC,MAAK,IACZ/J,KAAKiI,YAAY2G,OAAS,EACnB5E,QAAQC,IAAIjK,KAAKiI,aAAa8B,MAAK,KACtC/J,KAAKmO,WAAa,IAAI,KAI1BnO,KAAKmO,WAAa,KACXnE,QAAQE,Y,CAKpB4F,SACH,IAAIxH,EAAOtI,KAAKuI,MAEhBvI,KAAKkI,QAAQ0G,OAAS,EACtB5O,KAAKmI,OAAOyG,OAAS,EACrB5O,KAAKmO,WAAa,GAElBnO,KAAK+P,UAAUzH,EAAK6E,OACpBnN,KAAKgQ,eAAe1H,EAAK6E,OACzBnN,KAAKiQ,WAAW3H,EAAK4H,QACrBlQ,KAAKmQ,eAAe7H,EAAK8H,YAEzB,IAAIC,EAAmCpF,MAAd3C,EAAKgI,MAAsBhI,EAAKgI,MAAQ,EAC7DC,EAAyBvQ,KAAKkI,QAAQmI,GAK1C,OAJArQ,KAAKkI,QAAQ0G,OAAS,EACtB5O,KAAKmI,OAAOyG,OAAS,EACrB5O,KAAKmO,WAAa,KAEXoC,C,CAGD3E,sBAAsB9C,EAAqB+C,EAAkCX,EAAyCE,EAAuC1C,GACnK,IACI8H,EAAc,QAAQ3E,YADL7C,aAAWyH,OAAO3H,KAGvC,OAAOW,QAAMC,OAAOgH,KAAK,CAAEF,IAAKA,EAAKtF,gBAAiBA,EAAiBE,eAAgBA,GACnFuF,SAAOC,UAAWlI,aAAQ,EAARA,EAAUoB,iB,CAG1BkC,YAAYwE,EAAatF,EAAyCE,EAAuC1C,GAC/G,OAAOe,QAAMC,OAAOgH,KAAK,CAAEF,IAAKA,EAAKtF,gBAAiBA,EAAiBE,eAAgBA,GACnFuF,SAAOC,UAAWlI,aAAQ,EAARA,EAAUoB,iB,CAO1B+G,WAAWC,GACjB,IAAI/H,EAAI/I,KAAKmO,WAAW2C,GAMxB,OALS,MAAL/H,EACAA,EAAI,EAEJA,IACJ/I,KAAKmO,WAAW2C,GAAW/H,EACpBA,EAAEgI,U,CAOLC,yBAAyBC,GAC7B,OAAQA,GACJ,IAAK,SAAU,OAAO,EACtB,IAAK,OAAQ,OAAO,EACpB,IAAK,OAAQ,OAAO,EACpB,IAAK,OACL,IAAK,OAAQ,OAAO,EACpB,IAAK,OAAQ,OAAO,EACpB,IAAK,OAAQ,OAAO,GACpB,QAAS,OAAO,E,CAQhBC,gBAAgBC,GACpB,OAAQA,GACJ,IAAK,WACL,IAAK,SAAU,OAAO,EACtB,IAAK,QAGL,IAAK,cACL,IAAK,eACL,IAAK,UAAW,OAAO,EAJvB,IAAK,KACL,IAAK,MAAO,OAAO,EAInB,QAAS,OAAO,E,CAShBC,0BAA0BC,GAC9B,OAAQA,GACJ,UAA0C,OAAOC,UACjD,UAAmD,OAAOC,WAC1D,UAA2C,OAAOC,WAClD,UAAoD,OAAOC,YAC3D,UAAkD,OAAOC,YACzD,UAA2C,OAAOC,a,CAS1DC,2BAA2BP,GACvB,OAAQA,GACJ,UACA,UAAmD,OAAO,EAC1D,UACA,UAAoD,OAAO,EAC3D,UACA,UAA2C,OAAO,E,CAIlDQ,wBAAwBvG,EAAiCE,EAAoBsG,EAAqCT,EAA+CU,GACrK,IAAIjJ,EAAsB9I,KAAK2H,SAAS2D,EAAWxC,QAEnD,MAAMrB,EAAczH,KAAKoR,0BAA0BC,GACnD,IACIvF,EADAkG,EAAyBhS,KAAKgR,yBAAyBc,GAE3D,GAAIxG,EAAW2G,WAAY,CACvB,IAAIC,EAAe5G,EAAW2G,WAC1BE,EAAiBnS,KAAK4R,2BAA2BP,GACjDe,EAAaF,EAAeC,EAG5BE,GADoB7G,GAAc,GACE2G,EAGpCG,EAAa,IAAI7K,EAAYqB,EAAQwC,EAAWE,YAAc,EAAGF,EAAWG,WAAa0G,GAC7FrG,EAAM,IAAIrE,EAAYsK,GACtB,IAAIQ,EAAW,EACf,IAAK,IAAIjI,EAAQ,EAAGA,EAAQyH,EAAOzH,IAAS,CACxC,IAAIkI,EAAkBlI,EAAQ8H,EAC9B,IAAK,IAAIrJ,EAAI,EAAGA,EAAIiJ,EAAgBjJ,IAChC+C,EAAIyG,KAAcD,EAAWE,EAAkBH,EAAgBtJ,EAEtE,CACJ,KACI,CAED+C,EAAM,IAAIrE,EAAYqB,GADMwC,EAAWE,YAAc,IAAMA,GAAc,GAC7BuG,EAC/C,CAED,OAAOjG,C,CAOH2G,2BAA2BC,GAC/B,IAAIC,EAA8B3S,KAAKuI,MAAMqK,UAAUF,GACvD,IAAKC,EACD,OAAO,KAEX,IAII7G,EAJAiG,EAAgBY,EAASZ,MACzBC,EAAyBhS,KAAKgR,yBAAyB2B,EAAS1B,MAChE4B,EAA4Bd,EAAQC,EAIpC1G,EAAkCtL,KAAKuI,MAAMgD,YAAYoH,EAASrH,YACtE,GAAIA,EACAQ,EAAM9L,KAAK6R,wBAAwBvG,EAAYqH,EAASnH,WAAYmH,EAAS1B,KAAM0B,EAAStB,cAAewB,OAE1G,CAED/G,EAAM,IADc9L,KAAKoR,0BAA0BuB,EAAStB,eACtD,CAAgBwB,GAAmBC,KAAK,EACjD,CAED,GAAIH,EAASI,OAAQ,CACjB,IAAIC,EAAcL,EAASI,OAAOhB,MAC9BkB,EAAgBN,EAASI,OAAOG,QAChCC,EAA0BnT,KAAKuI,MAAMgD,YAAY0H,EAAc3H,YAC/D8H,EAAoBpT,KAAK6R,wBAAwBsB,EAAyBF,EAAczH,WAAYmH,EAAS1B,KAAMgC,EAAc5B,cAAe2B,GAEhJK,EAAeV,EAASI,OAAOO,OAC/BC,EAAyBvT,KAAKuI,MAAMgD,YAAY8H,EAAa/H,YAC7DkI,EAAmBxT,KAAK6R,wBAAwB0B,EAAwBF,EAAa7H,WAAYmH,EAAS1B,KAAM0B,EAAStB,cAAe2B,EAAchB,GAE1J,IAAK,IAAI1H,EAAQ,EAAGA,EAAQ0I,EAAa1I,IAAS,CAC9C,IAAIvB,EAAIqK,EAAkB9I,GAC1B,IAAK,IAAImJ,EAAiB,EAAGA,EAAiBzB,EAAgByB,IAC1D3H,EAAI/C,EAAIiJ,EAAiByB,GAAkBD,EAAiBlJ,EAAQ0H,EAAiByB,EAE5F,CACJ,CAED,OAAO3H,C,CAQH4H,iBAAiB3I,GACrB,OAAIA,GACgE,MAAzDA,EAAY4I,WACM,MAArB5I,EAAY4I,S,CAShBC,iBAAiBC,GACrB,MAAsB,eAAlBA,EAAUhI,SACH,EAGA,C,CAQPiI,qBAAqB/I,GAEzB,OAAKA,EAIoB,OAArBA,EAAYgJ,UACL,EAEF/T,KAAK0T,iBAAiB3I,IACiD,OAAxEA,EAAY4I,UACL,EAKR,EAbI,C,CAoBPK,mBAAmBC,GAEvB,OADAA,EAAOA,UAAI,OAEP,WAMA,QACI,OAAOC,WAASC,OALpB,WACI,OAAOD,WAASE,MACpB,WACI,OAAOF,WAASG,S,CAgBpBlJ,0BAA0B0I,EAA2B9I,EAA+BV,GAUxF,MAT+D,CAC3D,EACA,EACArK,KAAK4T,iBAAiBC,GACtB7T,KAAK0T,iBAAiB3I,IACtB,EACAV,E,CAWAgB,yBAAyBN,GAC7B,IAAKA,EACD,OAAO,KAUX,MAP4C,CACxCuJ,WAAYtU,KAAK8T,qBAAqB/I,GACtCwJ,UAAWvU,KAAKgU,mBAAmBjJ,EAAYyJ,OAC/CC,UAAWzU,KAAKgU,mBAAmBjJ,EAAY2J,OAC/CC,WAAY,EACZC,gBAAiBC,kBAAgBC,K,CASzCC,mBAAmBC,GAOf,OALIA,EAAgBC,UAEhBzG,QAAQC,KAAK,8CAGVzO,KAAK4H,UAAUoN,EAAgB1K,M,CAG1C4K,wBAAwB9K,EAA4B+K,GAChD,IAAIxI,EAAY3M,KAAK+H,YAAYqN,IAAID,GACrC,OAAI/K,EAAKiL,YAAcjL,EAAKiL,WAAWF,IAAkBxI,EACjDA,EAAU2I,yBACH3I,EAAU2I,yBAAyBlL,QAD9C,EAKO,I,CASfmL,yBAAyBpJ,EAAiCqJ,G,MAGtD,OAD6CrJ,EAAasJ,WAAS,UAE/D,aACID,EAASE,mBAAqBC,qBAAmBC,kBACjD,MAEJ,YACIJ,EAASE,mBAAqBC,qBAAmBE,uBACjD,MAEJ,WACIL,EAASE,mBAAqBC,qBAAmBG,kBAQzDN,EAASO,eAA6C,QAA5BvI,EAAArB,EAAa6J,mBAAe,IAAAxI,IAAA,GAElDrB,EAAa8J,cACbT,EAASU,KAAOC,cAAYC,U,CAKpCC,2BAA2Bb,EAAoBc,EAA+BhU,EAAciU,EAAsBC,EAAuBC,GACrI,IAAIlM,EAAMvK,KAAK+U,mBAAmBuB,GAOlC,GANAd,EAASkB,WAAWpU,EAAMiI,GACtBgM,GACAf,EAASmB,UAAUJ,GAAQ,GAI3BE,EAAiB,CACjB,IAAIG,EAAgB5W,KAAKkV,wBAAwBoB,EAAS,yBACtDM,IACApB,EAASmB,UAAUF,GAAiB,GACpCjB,EAASqB,aAAaL,EAAeI,EAAcE,WAE1D,C,CAOLC,+BAA+B5K,EAAiCqJ,G,YAC5D,IAAIpJ,EAAuBD,EAAaC,qBACxC,GAAIA,EAAsB,CACtB,GAAIA,EAAqB4K,gBAAiB,CACtC,IAAIA,EAAkBxB,EAASyB,WAAW,qBAC1CD,EAAgBE,UAAU9K,EAAqB4K,iBAC/CxB,EAAS2B,WAAW,oBAAqBH,EAC5C,CACG5K,EAAqBC,kBACrBrM,KAAKqW,2BAA2Bb,EAAUpJ,EAAqBC,iBAAkB,qBAAsBvM,WAAWG,oBAAqB,0BAA2BH,WAAWM,8BAGjL,IAAIgX,EAAoD,QAAnC5J,EAAApB,EAAqBgL,sBAAc,IAAA5J,IAAI,EAC5DgI,EAAS6B,SAAS,mBAAoBD,GAEtC,IAAIE,EAAsD,QAApC5I,EAAAtC,EAAqBkL,uBAAe,IAAA5I,IAAI,EAC9D8G,EAAS6B,SAAS,oBAAqBC,GAEnClL,EAAqBG,0BACrBvM,KAAKqW,2BAA2Bb,EAAUpJ,EAAqBG,yBAA0B,6BAA8BzM,WAAWO,4BAA6B,kCAAmCP,WAAWQ,qCAEpN,CAED,GAAI6L,EAAaK,cAAe,CAC5BxM,KAAKqW,2BAA2Bb,EAAUrJ,EAAaK,cAAe,kBAAmB1M,WAAWS,iBAAkB,uBAAwBT,WAAWU,2BAEzJ,IAAI+W,EAAkD,QAApC1H,EAAA1D,EAAaK,cAAcgL,aAAS,IAAA3H,IAAA,EACtD2F,EAAS6B,SAAS,gBAAiBE,EACtC,CAED,GAAIpL,EAAaM,iBAAkB,CAC/BzM,KAAKqW,2BAA2Bb,EAAUrJ,EAAaM,iBAAkB,qBAAsB3M,WAAWW,oBAAqB,0BAA2BX,WAAWY,8BAErK,IAAI+W,EAAqD,QAA1CC,EAAAvL,EAAaM,iBAAiBgL,gBAAY,IAAAC,IAAA,EACzDlC,EAAS6B,SAAS,sBAAuBI,EAC5C,CAED,GAAItL,EAAawL,eAAgB,CAC7B,IAAIC,EAAiBpC,EAASqC,WAAW,oBACzCD,EAAeV,UAAU/K,EAAawL,gBACtCnC,EAASsC,WAAW,mBAAoBF,GACxCpC,EAASmB,UAAUoB,eAAaC,iBAAiB,EACpD,CAEG7L,EAAaO,kBACb8I,EAASmB,UAAUoB,eAAaC,iBAAiB,GAEjDhY,KAAKqW,2BAA2Bb,EAAUrJ,EAAaO,gBAAiB,oBAAqB5M,WAAWa,mBAAoB,yBAA0Bb,WAAWc,8BAGrKZ,KAAKuV,yBAAyBpJ,EAAcqJ,E,CAShDyC,sBAAsB9L,GAClB,IAAIqJ,EAAW,IAAI0C,WAQnB,OAPA1C,EAAS2C,cAAcrY,WAAWwH,YAGlCkO,EAASlT,KAAO6J,EAAa7J,KAAO6J,EAAa7J,KAAO,GAExDtC,KAAK+W,+BAA+B5K,EAAcqJ,GAE3CA,C,CAGDxI,eAAeb,GACrB,IAAIY,EAAgB,KAChBqL,EAAiB,GACrB,IAAK,MAAMzK,KAAOxB,EAAakJ,WAAY,CACvC,IAAI1I,EAAY3M,KAAK+H,YAAYqN,IAAIzH,GACjChB,IACIA,EAAUK,iBACVD,EAAMJ,EAAUK,eAAeb,IAE/BQ,EAAU0L,4BACVD,EAAe5O,KAAKmD,GAG/B,CASD,OAPKI,IACDA,EAAM/M,KAAKiY,sBAAsB9L,IAErCiM,EAAevP,SAAQ8D,IACnBA,EAAU0L,2BAA2BlM,EAAcY,EAAI,IAGpDA,C,CAOHuL,kBAAkBhL,GACtB,IAAIpB,EAAwB,GAe5B,OAbAoB,EAASiL,WAAW1P,SAAQ2P,IACxB,GAA0BvN,MAAtBuN,EAAUhD,SAAuB,CACjC,IAAIA,EAAqBxV,KAAK6H,WAAW2Q,EAAUhD,UACnDtJ,EAAU1C,KAAKgM,EAClB,KACI,CACD,IAAIA,EAAqB,IAAIiD,sBAC7BvM,EAAU1C,KAAKgM,GACfxV,KAAK6H,WAAW2B,KAAKgM,GACrBgD,EAAUhD,SAAWxV,KAAK6H,WAAW6Q,QAAQlD,EAChD,KAGEtJ,C,CAQH+D,WAAW0I,GACVA,GAGLA,EAAW9P,SAAQ,CAAC+P,EAAWtO,KAC3BtK,KAAKkI,QAAQoC,GAAStK,KAAK6Y,WAAWD,EAAU,G,CAShDC,WAAWD,GAGf,OAAO5Y,KAAK8Y,iBAAiBF,E,CAOzBE,iBAAiBF,GACrB,IAAIG,EAA0B,IAAIC,WAASJ,EAAUtW,MAAQ,SAM7D,OALAsW,EAAUzL,MAAMtE,SAAQoQ,IACpB,IAAIC,EAAmBlZ,KAAKmI,OAAO8Q,GACnCF,EAAcI,SAASD,EAAO,IAG3BH,C,CAQHK,eAAehM,EAAyB8L,GAC5C,GAAI9L,EAASiM,OAAQ,CACjB,IAAIC,EAAyBJ,EAAOpC,UAAUwC,YAC9CA,EAAYC,SAAShL,IAAInB,EAASiM,QAClCH,EAAOpC,UAAUwC,YAAcA,CAClC,KACI,CACD,IAAIE,EAAyBN,EAAOpC,UAAU0C,cAC1CC,EAA4BP,EAAOpC,UAAU2C,cAC7CC,EAAsBR,EAAOpC,UAAU4C,WAC3CtM,EAASuM,aAAeH,EAActC,UAAU9J,EAASuM,aACzDvM,EAASwM,UAAYH,EAAcvC,UAAU9J,EAASwM,UACtDxM,EAASoK,OAASkC,EAAWxC,UAAU9J,EAASoK,OAChD0B,EAAOpC,UAAU0C,cAAgBA,EACjCN,EAAOpC,UAAU2C,cAAgBA,EACjCP,EAAOpC,UAAU4C,WAAaA,CACjC,C,CAQG1J,eAAe6J,GACnBA,EAAUhR,SAAQ,CAACuE,EAAyB9C,KACxC,IAAI4O,EAAmBlZ,KAAKmI,OAAOmC,GAC/B8C,EAAS0M,UACT1M,EAAS0M,SAASjR,SAASkR,IACvB,IAAIC,EAAkBha,KAAKmI,OAAO4R,GAClCb,EAAOC,SAASa,EAAM,GAE7B,IAGLH,EAAUhR,SAAQ,CAACuE,EAAyB9C,KACxC,IAAI4O,EAAmBlZ,KAAKmI,OAAOmC,GAC/B4O,aAAkBe,uBAClBja,KAAKka,iBAAiB9M,EAAU8L,EACnC,G,CASDnJ,UAAU8J,GACTA,GAGLA,EAAUhR,SAAQ,CAACuE,EAAyB9C,KACxCtK,KAAKmI,OAAOmC,GAAStK,KAAKma,SAAS/M,EAAS,G,CAS5C+M,SAAS/M,GAGb,OAAOpN,KAAKoa,eAAehN,E,CAOvBgN,eAAehN,GACnB,IAAI8L,EACiB,MAAjB9L,EAASM,MACTwL,EAASlZ,KAAKqa,0BAA0BjN,GACxCpN,KAAKoZ,eAAehM,EAAU8L,IAER,MAAjB9L,EAASC,MACd6L,EAASlZ,KAAKsa,mBAAmBlN,GACjCpN,KAAKoZ,eAAehM,EAAU8L,KAG9BA,EAAS,IAAIF,WAAS5L,EAAS9K,MAC/BtC,KAAKoZ,eAAehM,EAAU8L,IAGlC,IAAIqB,EAAUva,KAAK6Q,WAAW,QAI9B,OAHAqI,EAAO5W,KAAO8K,EAAS9K,MAAQ,QAAQiY,IACjCrB,EAAOsB,OAAQD,QAAU,IAAMA,EAE9BrB,C,CAOHoB,mBAAmBlN,GACvB,IAAIE,EAA0BtN,KAAKuI,MAAM2E,OAAOE,EAASC,MACrDA,EAAOrN,KAAK8H,QAAQsF,EAASC,MAC7BnB,EAAwBlM,KAAKsY,kBAAkBhL,GAC/C4L,EAAuB,IAAIuB,eAAapN,EAAMD,EAAS9K,MAK3D,GAJA4W,EAAOwB,aAAaC,gBAAkBzO,EACtCgN,EAAOwB,aAAaE,eAAgB,EACpC1B,EAAOwB,aAAaG,YAAa,EAE7BvN,EAASwN,QAAS,CAClB,IAAIC,EAAS7B,EAAOwB,aACpBpN,EAASwN,QAAQjS,SAAQ,CAACmS,EAAQ1Q,KAC9B,IAAI2Q,EAAS5N,EAAK6N,gBAAgBC,uBAAuB7Q,GACzDyQ,EAAOK,sBAAsBH,EAAO3Y,KAAM0Y,EAAO,GAExD,CAED,OAAO9B,C,CAOHmB,0BAA0BjN,GAC9B,IAAIE,EAA0BtN,KAAKuI,MAAM2E,OAAOE,EAASC,MACrDA,EAAarN,KAAK8H,QAAQsF,EAASC,KAAO,IAAMD,EAASM,MACzDxB,EAAwBlM,KAAKsY,kBAAkBhL,GAC/C4L,EAA8B,IAAIe,sBAAoB5M,EAAMD,EAAS9K,MAKzE,GAJA4W,EAAOmC,oBAAoBV,gBAAkBzO,EAC7CgN,EAAOmC,oBAAoBT,eAAgB,EAC3C1B,EAAOmC,oBAAoBR,YAAa,EAEpCvN,EAASwN,QAAS,CAClB,IAAIC,EAAS7B,EAAOmC,oBACpB/N,EAASwN,QAAQjS,SAAQ,CAACmS,EAAQ1Q,KAC9B,IAAI2Q,EAAS5N,EAAK6N,gBAAgBC,uBAAuB7Q,GACzDyQ,EAAOK,sBAAsBH,EAAO3Y,KAAM0Y,EAAO,GAExD,CAED,OAAO9B,C,CAYHoC,mBAAmBC,EAAgCC,EAAuBC,EAAyCC,GACvH,IAAIC,EAA8C3b,KAAKyS,2BAA2B8I,GAClF,IAAKI,EACD,OAAO,KACXD,EAAgBlS,KAAKgS,GACrB,IAAI1P,EAAoB6P,EAExB,OADAF,EAAalN,IAAIiN,EAAe1P,GACzBA,C,CASH8P,eAAeL,EAAgCM,GACnD,IAAIC,EAAwC9b,KAAKyS,2BAA2B8I,GAC5E,GAAIO,EACA,OAAO,IAAIpK,YAAYoK,GAAaC,UAGnC,CACD,IAAI7I,EAAuB,IAAIxB,YAAYmK,GAC3C,IAAK,IAAI9S,EAAI,EAAGA,EAAI8S,EAAa9S,IAC7BmK,EAAQnK,GAAK8S,EAAc,EAAI9S,EAEnC,OAAOmK,CACV,C,CAGG8I,oBAAoBC,EAAyBC,GACjD,IAAIC,EAAS,IAAIxK,aAAasK,EAAUrN,QAExC,IAAK,IAAItE,EAAQ,EAAGA,EAAQ4R,EAAWtN,OAAQtE,GAAS,EAAG,CAEvD,IAAI8R,EAAKF,EAAW5R,GAChB+R,EAAKH,EAAW5R,EAAQ,GACxBgS,EAAKJ,EAAW5R,EAAQ,GAExBiS,EAAMN,EAAe,EAALG,GAChBI,EAAMP,EAAe,EAALG,EAAS,GACzBK,EAAMR,EAAe,EAALG,EAAS,GAUzBM,EARMT,EAAe,EAALI,GAQLE,EACXI,EARMV,EAAe,EAALI,EAAS,GAQdG,EACXI,EARMX,EAAe,EAALI,EAAS,GAQdI,EAEXI,EARMZ,EAAe,EAALK,GAQLC,EACXO,EARMb,EAAe,EAALK,EAAS,GAQdE,EACXO,EARMd,EAAe,EAALK,EAAS,GAQdG,EAEXO,EAAKL,EAAKI,EAAKH,EAAKE,EACpBG,EAAKL,EAAKC,EAAKH,EAAKK,EACpBG,EAAKR,EAAKI,EAAKH,EAAKE,EAEpBM,GAAW,EAAOxN,KAAKyN,KAAMJ,EAAKA,EAAOC,EAAKA,EAAOC,EAAKA,GAC1DG,EAAKL,EAAKG,EACVG,EAAKL,EAAKE,EACVI,EAAKL,EAAKC,EAEdhB,EAAY,EAALC,GAAUiB,EACjBlB,EAAY,EAALE,GAAUgB,EACjBlB,EAAY,EAALG,GAAUe,EAEjBlB,EAAY,EAALC,EAAS,GAAKkB,EACrBnB,EAAY,EAALE,EAAS,GAAKiB,EACrBnB,EAAY,EAALG,EAAS,GAAKgB,EAErBnB,EAAY,EAALC,EAAS,GAAKmB,EACrBpB,EAAY,EAALE,EAAS,GAAKkB,EACrBpB,EAAY,EAALG,EAAS,GAAKiB,CACxB,CAED,OAAOpB,C,CASHqB,yBAAyBC,EAA8BC,GAC3D,IAEIC,EAFA9B,EAAsB,EACtB+B,EAAqB,EAEzBH,EAAS5U,SAAQgV,IACbhC,GAAegC,EAAQhC,YACvB+B,GAAcC,EAAQ3K,QAAQtE,OAE9B+O,EAAeA,GAAgBE,EAAQF,YAAY,IAGvD,IAKIzB,EALA4B,EAAuCC,aAAWC,qBAAqBL,GAAc,GAErFM,EAD2BH,EAAkB5L,aACE,EAE/CgM,EAA4B,IAAIvM,aAAasM,EAAoBpC,GAEjEsC,EAAwBC,cAAYC,OACpCxC,EAAc,OACdK,EAAa,IAAIzK,YAAYmM,GAC7BO,EAAWC,cAAYE,QAGvBpC,EAAa,IAAIxK,YAAYkM,GAGjC5d,KAAKue,gBAAgBd,EAAUS,EAAahC,EAAY+B,GACxDje,KAAKwe,aAAaN,EAAahC,EAAY4B,EAAmBK,EAAUV,EAAUC,E,CAW9Ea,gBAAgBd,EAA8BS,EAA2BhC,EAAuC+B,GACpH,IAAIQ,EAAsB,EACtBC,EAAyB,EACzBC,EAAsB,EAC1BlB,EAAS5U,SAASgV,IAEd,IAAIe,EAAmBH,EAEnB5C,EAAsBgC,EAAQhC,YAE9BgD,EAAqBhB,EAAQ3K,QACjC,IAAK,IAAI5I,EAAQ,EAAGA,EAAQuU,EAAMjQ,OAAQtE,IACtC4R,EAAW0C,EAAWtU,GAASuU,EAAMvU,GAASoU,EAElDD,GAAeI,EAAMjQ,OACrB8P,GAAkB7C,EAElB,MAAMiD,oBAAsB,CAACzQ,EAAqB0Q,EAAqBC,EAA0B,KAC7F,IAAIC,EAAsBN,EAAcI,EACxC,IAAK,IAAIzU,EAAQ,EAAGA,EAAQuR,EAAavR,IACrC,IAAK,IAAI4U,EAAK,EAAGA,EAAKF,EAAiBE,IACnChB,EAAYe,EAAc3U,EAAQ2T,EAAoBiB,GAAM7Q,EAAM/D,EAAQ0U,EAAkBE,EAEnG,EAGL,IAAIH,EAAsB,EACtBtD,EAA0CoC,EAAQpC,aAClD0D,EAAyB1D,EAAarG,IAAI,YAC9C,IAAe0J,oBAAoBK,EAAUJ,EAAa,GAAIA,GAAe,GAC7E,IAAI5C,EAAuBV,EAAarG,IAAI,UAC5C,IAAa0J,oBAAoB3C,EAAQ4C,EAAa,GAAIA,GAAe,GACzE,IAAIK,EAAsB3D,EAAarG,IAAI,SAC3C,IAAY0J,oBAAoBM,EAAOL,EAAa,GAAIA,GAAe,GACvE,IAAIM,EAAmB5D,EAAarG,IAAI,MACxC,IAAS0J,oBAAoBO,EAAIN,EAAa,GAAIA,GAAe,GACjE,IAAIO,EAAoB7D,EAAarG,IAAI,OACzC,IAAU0J,oBAAoBQ,EAAKP,EAAa,GAAIA,GAAe,GACnE,IAAIQ,EAA4B9D,EAAarG,IAAI,eACjD,IAAkB0J,oBAAoBS,EAAaR,EAAa,GAAIA,GAAe,GACnF,IAAIS,EAA6B/D,EAAarG,IAAI,gBAClD,GAAIoK,EAAc,CACd,IAAIC,EAAgC,IAAIlO,WAAWiO,GAEnDV,oBADwC,IAAInN,aAAa8N,EAAkB3W,QAClCiW,EAAa,GAAIA,GAAe,CAC5E,CACD,IAAIW,EAAwBjE,EAAarG,IAAI,WAC7C,IAAc0J,oBAAoBY,EAASX,EAAa,GAAIA,GAAe,GAE3EJ,GAAe9C,EAAcoC,CAAiB,G,CAa9C0B,yBAAyBlE,EAAyCmE,EAA4B1D,EAAyB2D,EAAqCC,EAA8BC,GAC9L,IAAIC,EAAgB,EAChBC,EAA2B,IAAIC,IAC/BC,EAA+B1E,EAAarG,IAAI,gBAEhDyG,EAAsBsE,EAAevR,OAAS,EAE9CwR,EAAyB,IAAIzO,aAAawO,EAAevR,QAEzDyR,EAA4B,IAAIC,MAAMzE,GAAa/I,MAAK,GAG5D,IAAK,IAAI/J,EAAY,EAAGwX,EAAYrE,EAAWtN,OAAQ7F,EAAIwX,EAAGxX,GAAK,EAAG,CAGlE,IAAIyX,EAA2B,IAAIN,IACnC,IAAK,IAAI3W,EAAYR,EAAGQ,EAAIR,EAAI,EAAGQ,IAAK,CACpC,IACIkX,EAAoC,EADlBvE,EAAW3S,GAEjC,IAAK,IAAImX,EAAY,EAAGA,EAAI,EAAGA,IAC3BF,EAAYxZ,IAAImZ,EAAeM,EAAkBC,GAExD,CAED,IAAIC,EAAuB,IAAIT,IAAI,IAAID,KAAgBO,IACvD,GAAIG,EAAQC,KA9vCA,GA8vCwB,CAGhC,IAAI7O,EAAgBhJ,EAAIiX,EACxBF,EAAmBtW,KAAKwW,GACxBD,EAAmBvW,KAAKuI,GAExB,IAAI8O,EAAwBP,MAAMQ,KAAKb,GACvCJ,EAAgBrW,KAAK,IAAIiI,YAAYoP,IAErCb,EAAQjX,EAERkX,EAAc,IAAIC,IAAIM,EACzB,MAGGP,EAAcU,EAGlB,GAAI5X,GAAKwX,EAAI,EAAG,CACZ,IAAIxO,EAAgBhJ,EAAIiX,EAAQ,EAChCF,EAAmBtW,KAAKwW,GACxBD,EAAmBvW,KAAKuI,GACxBiO,EAAQjX,EACR,IAAI8X,EAAwBP,MAAMQ,KAAKb,GACvCJ,EAAgBrW,KAAK,IAAIiI,YAAYoP,GACxC,CACJ,CAGD,IAAIE,EAAoBlB,EAAgBjR,OACpCoS,EAA8C,IAAIhZ,IACtDyT,EAAa5S,SAAQ,CAACwF,EAAOV,KACzB,IAAIsT,EAAuB,IAAIX,MAC/BU,EAAgBzS,IAAIZ,EAAKsT,EAAM,IAGnC,IAAIC,EAA+D,GACnE,IAAK,MAAMvT,KAAOiS,EAAauB,QAAS,CACpC,IAAIC,EAASF,EAAavT,GAAO,IAAI3F,IAExB4X,EAAauB,QAAQxT,GAC3B9E,SAAQ,CAACwF,EAAOgT,KACnBD,EAAO7S,IAAI8S,EAAO,IAAIf,MAAgB,GAE7C,CAED,IAAIgB,EAAsBzF,EAAc,EACxC,IAAK,IAAI0F,EAAY,EAAGA,EAAIR,EAAWQ,IAAK,CACxC,IAAIb,EAAYZ,EAAmByB,GAC/BC,EAAYzB,EAAmBwB,GAC/BE,EAAkB5B,EAAgB0B,GAElCG,EAA4B,IAAIpB,MAAMzE,GAAa/I,MAAK,GACxD6O,EAAgC,IAAI3Z,IACxC,IAAK,IAAI4Z,EAAe,EAAGA,EAAOJ,EAAGI,IAAQ,CACzC,IAAIC,EAAa3F,EAAW0F,EAAOlB,GAC/BoB,EAAkB,EAAID,EAC1B,IAAK,IAAIE,EAAcD,EAASC,EAAMD,EAAU,EAAGC,IAAO,CACtD,IAAIC,EAAuB7B,EAAe4B,GACtCE,EAAuBR,EAAG/I,QAAQsJ,GACtCC,GAAgC,GAAjBA,EAAqB,EAAIA,EAEpC5B,EAAUwB,KAAQH,EAAUG,GAC5Bb,EAAgB5L,IAAI,gBAAgB5L,KAAKyY,GAGpC5B,EAAUwB,IAAOH,EAAUG,KAIhCzB,EAAS2B,GAAOE,EAEvB,CAED,GAAK5B,EAAUwB,IAAQH,EAAUG,GAK5B,IAAKxB,EAAUwB,IAAOH,EAAUG,GACjC3F,EAAW0F,EAAOlB,GAAKiB,EAASvM,IAAIyM,QAGnC,GAAIxB,EAAUwB,KAAQH,EAAUG,GAAK,CACtCH,EAAUG,IAAM,EAChBP,IACAK,EAASpT,IAAIsT,EAAIP,GACjBpF,EAAW0F,EAAOlB,GAAKY,EACvBN,EAAgBnY,SAAQ,CAACwF,EAAiBV,KACtC,IAAIuU,EAAoBliB,KAAKkR,gBAAgBvD,GACzCwU,EAAyB1G,EAAarG,IAAIzH,GAC9C,GAAY,iBAARA,EACA,IAAK,IAAIrD,EAAQ,EAAGA,EAAQ4X,EAAW5X,IACnC+D,EAAM7E,KAAK2Y,EAAS7X,EAAQuX,EAAKK,GAExC,IAGL,IAAK,MAAMvU,KAAOuT,EAAc,CAC5B,IAAIE,EAASF,EAAavT,GACtByU,EAASxC,EAAauB,QAAQxT,GAClCyT,EAAOvY,SAAQ,CAACwF,EAAOgT,KACnB,IAAIa,EAAYliB,KAAKkR,gBAAgBmQ,GACjCc,EAAWC,EAAOhN,IAAIiM,GAE1B,IAAK,IAAI/W,EAAQ,EAAGA,EAAQ4X,EAAW5X,IACnC+D,EAAM7E,KAAK2Y,EAAS7X,EAAQuX,EAAKK,GACpC,GAGR,CAGJ,MAEQ7B,EAAUwB,IAAOH,EAAUG,KAChC3F,EAAW0F,EAAOlB,GAAKiB,EAASvM,IAAIyM,SAzCpCH,EAAUG,IAAM,EAChBF,EAASpT,IAAIsT,EAAIA,EA0CxB,CAEDH,EAAU7Y,SAAQ,CAACwF,EAAO/D,KACtB+V,EAAU/V,GAAS+D,GAASgS,EAAU/V,EAAM,GAEnD,CAED0W,EAAgBnY,SAAQ,CAACwF,EAAiBV,KACtC,IAAI0U,EAA8B5G,EAAarG,IAAIzH,GACxC,gBAAPA,IACA0U,EAAgBjC,GAEpB,IAAIkC,EAAoBD,EAAczT,OAASP,EAAMO,OACjD2T,EAA8B,IAAI5Q,aAAa2Q,GACnDC,EAAchU,IAAI8T,EAAe,GACjCE,EAAchU,IAAIF,EAAOgU,EAAczT,QACvC6M,EAAalN,IAAIZ,EAAK4U,EAAc,IAGxC,IAAK,MAAM5U,KAAOuT,EAAc,CAC5B,IAAIE,EAASF,EAAavT,GACtByU,EAASxC,EAAauB,QAAQxT,GAElCyT,EAAOvY,SAAQ,CAACwF,EAAOgT,KACnB,IAAIc,EAAWC,EAAOhN,IAAIiM,GACtBiB,EAAYjU,EAAMO,OAASuT,EAASvT,OAEpC2T,EAAgB,IAAI5Q,aAAa2Q,GACrCC,EAAchU,IAAI4T,EAAU,GAC5BI,EAAchU,IAAIF,EAAO8T,EAASvT,QAClCwT,EAAO7T,IAAI8S,EAAOkB,EAAc,GAEvC,CAEDpC,EAAiB,I,CAab3B,aAAaN,EAA2BhC,EAAuC4B,EAAsCK,EAAuBV,EAA8BC,GAC9K,IAAI8E,EAA+BC,eAAaC,gBAAgBC,qBAAqBzE,EAAYzS,WAAYmX,cAAYC,QAAQ,GACjIL,EAAa1E,kBAAoBA,EACjC0E,EAAaM,QAAQ5E,EAAYpV,QAEjC,IAAIgT,EAA6B2G,eAAaC,gBAAgBK,oBAAoB5E,EAAUjC,EAAWtN,OAAQgU,cAAYC,QAAQ,GACnI/G,EAAYgH,QAAQ5G,GAEpBwB,EAASsF,aAAe7E,EACxBT,EAASuF,aAAenH,EACxB4B,EAASwF,cAAgBV,EACzB9E,EAASyF,WAAWX,EAAc1G,GAClC4B,EAAS0F,aAAeZ,EAAaa,YAAcvF,EAAkB5L,aAErE,IAAIoR,GAAoB,EACpB1T,EAAM,IAAI9L,UAAQyf,OAAOC,UAAWD,OAAOC,UAAWD,OAAOC,WAC7DC,EAAM,IAAI3f,WAASyf,OAAOC,WAAYD,OAAOC,WAAYD,OAAOC,WAGhEE,EAAwB,EACxBC,EAAuBlG,EAAS7O,OAChCgV,EAAuB,IAAItD,MAAeqD,GAC9C,IAAK,IAAIrZ,EAAQ,EAAGA,EAAQqZ,EAAcrZ,IAAS,CAC/C,IAAIuT,EAA4BJ,EAASnT,GAErCuZ,EAAmB,IAAIC,UAAQpG,GACnCkG,EAAUtZ,GAASuZ,EAEnBA,EAAQX,cAAgBV,EACxBqB,EAAQZ,aAAenH,EAEvB,IAAIiI,EAAwBL,EAC5BA,GAAiB7F,EAAQ3K,QAAQtE,OACjC,IAAIoV,EAAwBnG,EAAQ3K,QAAQtE,OAC5CiV,EAAQI,eAAeF,EAAeC,EAAe7F,GAErD0F,EAAQK,iBAAmBrG,EAAQgC,gBACnCgE,EAAQM,qBAAuBtG,EAAQiC,mBACvC+D,EAAQO,qBAAuBvG,EAAQkC,mBAEvC,IAAK,IAAIsE,EAAW,EAAGA,EAAWR,EAAQM,qBAAqBvV,OAAQyV,IACnER,EAAQM,qBAAqBE,IAAaN,EAG1ClG,EAAQyG,UAAYzG,EAAQ0G,UAC5B3U,EAAI4U,EAAI7U,KAAKC,IAAIiO,EAAQ0G,SAAS,GAAI3U,EAAI4U,GAC1C5U,EAAI6U,EAAI9U,KAAKC,IAAIiO,EAAQ0G,SAAS,GAAI3U,EAAI6U,GAC1C7U,EAAI8U,EAAI/U,KAAKC,IAAIiO,EAAQ0G,SAAS,GAAI3U,EAAI8U,GAE1CjB,EAAIe,EAAI7U,KAAK8T,IAAI5F,EAAQyG,SAAS,GAAIb,EAAIe,GAC1Cf,EAAIgB,EAAI9U,KAAK8T,IAAI5F,EAAQyG,SAAS,GAAIb,EAAIgB,GAC1ChB,EAAIiB,EAAI/U,KAAK8T,IAAI5F,EAAQyG,SAAS,GAAIb,EAAIiB,IAG1CpB,GAAoB,CAE3B,CAED5F,EAASiH,cAAcf,GACnBN,EACA5F,EAASkH,mBAGTlH,EAASmH,OAAOC,OAAOlV,GACvB8N,EAASmH,OAAOE,OAAOtB,IAO3B,IAAIuB,EAAqBxC,EAAaa,YAAcvH,EAAYuH,YAChE3F,EAASuH,cAAcD,GACvBtH,EAASwH,cAAcF,E,CASnBG,kBAAkB9X,EAAYoQ,EAA8BlQ,GAChE,IAAKA,EACD,OAEJ,IAAI6X,EAAmB7X,EAAS6X,OAE5BC,EAAyC,IAAI1T,aAAa3R,KAAKyS,2BAA2BlF,EAAS+X,sBAEnGC,EAAoBH,EAAOxW,OAC3B4W,EAAsBnY,EAAKoY,WAAa,GAC5CL,EAAOvc,SAAQoQ,IACX,IAAIyM,EAAsB1lB,KAAKuI,MAAM4E,MAAM8L,GAC3CuM,EAAUhc,KAAKkc,EAAKpjB,KAAK,IAG7B+K,EAAKsY,kBAAoB,GACzBtY,EAAKuY,wBAA0BP,EAAyBvc,OACxD,IAAK,IAAIwB,EAAQ,EAAGA,EAAQib,EAAWjb,IAAS,CAC5C,IAAIub,EAA+B,GAAKvb,EACpCwb,EAA2BT,EAAyB1Z,MAAMka,EAAsBA,EAAuB,IAC3GxY,EAAKsY,kBAAkBrb,GAAS,IAAIyb,YAChCD,EAAW,GAAIA,EAAW,GAAIA,EAAW,GAAIA,EAAW,GACxDA,EAAW,GAAIA,EAAW,GAAIA,EAAW,GAAIA,EAAW,GACxDA,EAAW,GAAIA,EAAW,GAAIA,EAAW,IAAKA,EAAW,IACzDA,EAAW,IAAKA,EAAW,IAAKA,EAAW,IAAKA,EAAW,IAC3DA,EAEP,CAED,IAAIE,EAAmBvI,EAAS7O,OAC5BqX,EAAqC5Y,EAAK6Y,qBAC9CD,EAAarX,OAASvB,EAAKsY,kBAAkB/W,OAC7C,IAAK,IAAIyV,EAAmB,EAAGA,EAAW2B,EAAU3B,IAAY,CAC5D,IAAI8B,EAAmB9Y,EAAK+Y,WAAW/B,GACnCtD,EAAoBoF,EAAQhC,qBAAqBvV,OACrD,IAAK,IAAIyX,EAAoB,EAAGA,EAAYtF,EAAWsF,IAAa,CAChE,IAAIC,EAA2BH,EAAQjC,iBAAiBmC,GACxD,IAAK,IAAIE,EAAc,EAAGA,EAAMD,EAAY1X,OAAQ2X,IAAO,CACvD,IAAIC,EAAaF,EAAYC,GAC7BN,EAAaO,KAAQP,EAAaO,GAAM,IAAIC,qBAAmBpC,EAAUgC,EAAWE,GACvF,CACJ,CACJ,CAED,IAAK,IAAIjc,EAAQ,EAAGA,EAAQ2b,EAAarX,OAAQtE,IACxC2b,EAAa3b,KACd2b,EAAa3b,GAAS,IAAImc,qBAAmB,EAAG,EAAG,G,CAKvDC,iBAAiBrZ,EAAYoQ,GAEjC,IAAIkJ,GAAc,EACdC,GAAY,EACZC,GAAa,EAQjB,GANApJ,EAAS5U,SAAQgV,IACb8I,EAAc9I,EAAQ+B,aAAaT,UAAYwH,EAC/CC,EAAY/I,EAAQ+B,aAAazD,QAAUyK,EAC3CC,EAAahJ,EAAQ+B,aAAaF,SAAWmH,CAAU,MAGrDF,GAAeE,GAAcA,GAC/B,OAGJ,IAAIhL,EAAcxO,EAAKwO,YAEnBiL,EAAY,IAAIC,kBACpBD,EAAUjL,YAAcA,EAExB,IAAImL,EAAS,GACTL,GACAK,EAAOxd,KAAK,YACZod,GACAI,EAAOxd,KAAK,UACZqd,GACAG,EAAOxd,KAAK,WAEhB,IAAIyd,EAAiBlJ,aAAWC,qBAAqBgJ,EAAOE,kBACxDC,EAA0BF,EAAe/U,aAAe,EAE5D4U,EAAUM,UAAYH,EAEtB,IAAIpC,EAASiC,EAAUjC,OACnBjV,EAAMiV,EAAOwC,SACb5D,EAAMoB,EAAOyC,SACjB1X,EAAIrB,IAAIgV,OAAOC,UAAWD,OAAOC,UAAWD,OAAOC,WACnDC,EAAIlV,KAAKgV,OAAOC,WAAYD,OAAOC,WAAYD,OAAOC,WAEtD,IAAI+D,EAAkB,EACtB,IAAK,IAAIjd,EAAQ,EAAGA,EAAQmT,EAAS7O,OAAQtE,IAAS,CAClD,IAAIuT,EAAUJ,EAASnT,GAEvBsF,EAAI4U,EAAI7U,KAAKC,IAAIA,EAAI4U,EAAG3G,EAAQ+B,aAAa2E,SAAS,IACtD3U,EAAI6U,EAAI9U,KAAKC,IAAIA,EAAI6U,EAAG5G,EAAQ+B,aAAa2E,SAAS,IACtD3U,EAAI8U,EAAI/U,KAAKC,IAAIA,EAAI8U,EAAG7G,EAAQ+B,aAAa2E,SAAS,IAEtDd,EAAIe,EAAI7U,KAAK8T,IAAIA,EAAIe,EAAG3G,EAAQ+B,aAAa0E,SAAS,IACtDb,EAAIgB,EAAI9U,KAAK8T,IAAIA,EAAIgB,EAAG5G,EAAQ+B,aAAa0E,SAAS,IACtDb,EAAIiB,EAAI/U,KAAK8T,IAAIA,EAAIiB,EAAG7G,EAAQ+B,aAAa0E,SAAS,IAEtD,IAAInD,EAAUtD,EAAQ+B,aAAauB,QAEnC,IAAK,MAAMqG,KAAcrG,EAAS,CAE9B,IAAIsG,EAAUX,EAAUY,gBAAgBF,GACxC,IAAKC,EAAS,CACVA,EAAU,IAAIE,qBACdF,EAAQnlB,KAAOklB,EAEf,IAAIvM,EAAS,IAAI2M,cACjB3M,EAAO3Y,KAAOklB,EACdvM,EAAO3S,KAAO,IAAIqJ,aAAakK,EAAcsL,GAAyBrU,KAAK,GAE3E2U,EAAQI,UAAU5M,GAClB6L,EAAUgB,gBAAgBL,EAC7B,CAED,IAAIxM,EAASwM,EAAQM,iBAAiB,GAClCC,EAAW7G,EAAQqG,GAEvB,IAAK,IAAIS,EAAc,EAAGA,EAAcpK,EAAQhC,YAAaoM,IAAe,CACxE,IAAIC,EAAgBF,EAAS5S,IAAI,YACjC,GAAI8S,EAAe,CACf,IACIC,EADalB,EAAemB,wBAAwBrK,aAAWsK,gBAC3CF,OAAS,EACjClN,EAAO3S,MAAM2f,EAAcV,GAAmBJ,EAA0BgB,GAAUD,EAA4B,EAAdD,GAChGhN,EAAO3S,MAAM2f,EAAcV,GAAmBJ,EAA0BgB,EAAS,GAAKD,EAA4B,EAAdD,EAAkB,GACtHhN,EAAO3S,MAAM2f,EAAcV,GAAmBJ,EAA0BgB,EAAS,GAAKD,EAA4B,EAAdD,EAAkB,EACzH,CAED,IAAIK,EAAcN,EAAS5S,IAAI,UAC/B,GAAIkT,EAAa,CACb,IACIH,EADgBlB,EAAemB,wBAAwBrK,aAAWwK,cAC3CJ,OAAS,EACpClN,EAAO3S,MAAM2f,EAAcV,GAAmBJ,EAA0BgB,GAAUG,EAA0B,EAAdL,GAC9FhN,EAAO3S,MAAM2f,EAAcV,GAAmBJ,EAA0BgB,EAAS,GAAKG,EAA0B,EAAdL,EAAkB,GACpHhN,EAAO3S,MAAM2f,EAAcV,GAAmBJ,EAA0BgB,EAAS,GAAKG,EAA0B,EAAdL,EAAkB,EACvH,CACD,IAAIO,EAAeR,EAAS5S,IAAI,WAChC,GAAIoT,EAAc,CACd,IACIL,EADiBlB,EAAemB,wBAAwBrK,aAAW0K,eAC3CN,OAAS,EACrClN,EAAO3S,MAAM2f,EAAcV,GAAmBJ,EAA0BgB,GAAUK,EAA2B,EAAdP,GAC/FhN,EAAO3S,MAAM2f,EAAcV,GAAmBJ,EAA0BgB,EAAS,GAAKK,EAA2B,EAAdP,EAAkB,GACrHhN,EAAO3S,MAAM2f,EAAcV,GAAmBJ,EAA0BgB,EAAS,GAAKK,EAA2B,EAAdP,EAAkB,GACrHhN,EAAO3S,MAAM2f,EAAcV,GAAmBJ,EAA0BgB,EAAS,GAAKtK,EAAQpC,aAAarG,IAAI,WAAyB,EAAd6S,EAAkB,EAC/I,CACJ,CACJ,CAEDV,GAAmB1J,EAAQhC,WAC9B,CAEDgJ,EAAOC,OAAOlV,GACdiV,EAAOE,OAAOtB,GAEdpW,EAAK6N,gBAAkB4L,EACvBA,EAAU4B,U,CAOJ9a,WAAWN,EAAyBC,GAC1C,IAAImQ,EAAiB,IAAIiL,OAErBC,EAA+Ctb,EAASiL,WACxDsQ,EAAyBvb,EAASwN,QAElCyK,EAAoB,EAAahY,EAAS6X,OAAOxW,OAAS,EAC1D6O,EAA+B,GAqJnC,OAnJAmL,EAAmB/f,SAASigB,I,MAExB,IAAI7U,EAAmC6U,EAAkB7U,KAC7ChJ,MAARgJ,IACAA,EAAI,GACJ,GAAwCA,GAExCzF,QAAQC,KAAK,2CAIjB,IAyBIiR,EAzBAhE,EAA4B,GAC5BD,EAA0C,IAAIzT,IAC9C+gB,EAAyCD,EAAkBC,WAE3D5J,EAAyBnf,KAAKsb,mBAAmByN,EAAWC,SAAU,WAAYvN,EAAcC,GAChGG,EAAsBsD,EAASvQ,OAAS,EACxCsN,EAA0Blc,KAAK4b,eAAekN,EAAkB5V,QAAS2I,GACzEoN,EAAmBjpB,KAAKuI,MAAMqK,UAAUmW,EAAWC,UAEnD7M,EAAuBnc,KAAKsb,mBAAmByN,EAAWG,OAAQ,SAAUzN,EAAcC,GAmB9F,GAfKS,IACDA,EAASnc,KAAKgc,oBAAoBmD,EAAUjD,GAC5CR,EAAgBlS,KAAK,UACrBiS,EAAalN,IAAI,SAAU4N,IAGLnc,KAAKsb,mBAAmByN,EAAWI,QAAS,QAAS1N,EAAcC,GACtE1b,KAAKsb,mBAAmByN,EAAWK,WAAY,KAAM3N,EAAcC,GAClE1b,KAAKsb,mBAAmByN,EAAWM,WAAY,MAAO5N,EAAcC,GAC5D1b,KAAKsb,mBAAmByN,EAAWO,UAAW,cAAe7N,EAAcC,GAC1E1b,KAAKsb,mBAAmByN,EAAWQ,SAAU,eAAgB9N,EAAcC,GAG5GgE,EAAU1f,KAAKsb,mBAAmByN,EAAWS,QAAS,UAAW/N,EAAcC,GAE3EgE,EACA,IAAK,IAAI+J,EAAe,EAAGA,EAAe/J,EAAQ9Q,OAAQ6a,GAAgB,EACtE/J,EAAQ+J,EAAe,KAAO,EAUtC,IAAItI,EAAwC2H,EAAkB3H,QAC1DvB,EAA6B,CAAE9E,QAAS+N,EAAc1J,UAAU,EAAOhD,QAAQ,EAAOuD,SAAS,EAAOyB,QAAS,GAAIoD,SAAU,CAAChB,OAAOC,UAAWD,OAAOC,UAAWD,OAAOC,WAAYc,SAAU,EAAEf,OAAOC,WAAYD,OAAOC,WAAYD,OAAOC,YAClP,GAAIrC,EAAS,CAET,IAAIuI,EACAC,GAA+B,QAAjBnc,EAAAF,EAASsc,cAAQ,IAAApc,OAAA,EAAAA,EAAAmc,cAAe,GAClDD,EAAiB9J,EAAauB,QAE9BA,EAAQtY,SAAQ,CAACoS,EAAQ3Q,KACrB,IAAIkd,EAAamC,EAAYrf,IAAU,UAAUA,IAC7Cuf,EAAQ,IAAI7hB,IAChB0hB,EAAelC,GAAcqC,EAE7B,IAAI3B,EAA8BloB,KAAKyS,2BAA2BwI,EAAO+N,UACrEV,EAA4BtoB,KAAKyS,2BAA2BwI,EAAOiO,QACnEV,EAA6BxoB,KAAKyS,2BAA2BwI,EAAOuO,SAExE,GAAItB,IACA2B,EAAMtb,IAAI,WAAY2Z,GACtBtI,EAAaT,UAAW,EAEpBA,GAAU,CACV,IAAItD,EAAsBsD,EAASvQ,OAAS,EAE5C,IAAK,IAAI7F,EAAI,EAAGA,EAAI8S,EAAa9S,IAAK,CAClC,IAAIof,EAAa,EAAJpf,EAET+gB,EAAS3K,EAASgJ,GAAUD,EAAcC,GAC1C4B,EAAS5K,EAASgJ,EAAS,GAAKD,EAAcC,EAAS,GACvD6B,EAAS7K,EAASgJ,EAAS,GAAKD,EAAcC,EAAS,GAE3DvI,EAAa2E,SAAS,GAAK5U,KAAKC,IAAIka,EAAQlK,EAAa2E,SAAS,IAClE3E,EAAa2E,SAAS,GAAK5U,KAAKC,IAAIma,EAAQnK,EAAa2E,SAAS,IAClE3E,EAAa2E,SAAS,GAAK5U,KAAKC,IAAIoa,EAAQpK,EAAa2E,SAAS,IAElE3E,EAAa0E,SAAS,GAAK3U,KAAK8T,IAAIqG,EAAQlK,EAAa0E,SAAS,IAClE1E,EAAa0E,SAAS,GAAK3U,KAAK8T,IAAIsG,EAAQnK,EAAa0E,SAAS,IAClE1E,EAAa0E,SAAS,GAAK3U,KAAK8T,IAAIuG,EAAQpK,EAAa0E,SAAS,GACrE,CACJ,CAGDgE,IACAuB,EAAMtb,IAAI,SAAU+Z,GACpB1I,EAAazD,QAAS,GAEtBqM,IACAqB,EAAMtb,IAAI,UAAWia,GACrB5I,EAAaF,SAAU,EAC1B,GAER,CAED,IAAIG,EAAsC,IAAIS,MAC1CR,EAA+B,GAC/BC,EAA+B,GAEnC,GAAIxS,EACA,GAAIgY,EAnxDI,GAqxDJvlB,KAAK2f,yBAAyBlE,EAAcmE,EAAc1D,EAAY2D,EAAiBC,EAAoBC,GAC3GlE,EAAcJ,EAAarG,IAAI,YAAYxG,OAAS,MAEnD,CACDkR,EAAmB,GAAK,EACxBC,EAAmB,GAAK7D,EAAWtN,OACnCiR,EAAgB,GAAK,IAAIpO,YAAY8T,GACrC,IAAK,IAAI0E,EAAK,EAAGA,EAAK1E,EAAW0E,IAC7BpK,EAAgB,GAAGoK,GAAMA,CAEhC,MAGDnK,EAAmB,GAAK,EACxBC,EAAmB,GAAK7D,EAAWtN,OAEvC,IAAIkP,EAA4BpC,EAAgB3K,WAE5C8M,EAA4B,IAAIqM,iBACpCzM,EAASjU,KAAKqU,GAEdA,EAAQpC,aAAeA,EACvBoC,EAAQyG,SAAW2E,EAAiBxF,IACpC5F,EAAQ0G,SAAW0E,EAAiBrZ,IACpCiO,EAAQ+B,aAAeA,EACvB/B,EAAQ3K,QAAUgJ,EAClB2B,EAAQhC,YAAcA,EACtBgC,EAAQF,aAAeG,EACvBD,EAAQgC,gBAAkBA,EAC1BhC,EAAQiC,mBAAqBA,EAC7BjC,EAAQkC,mBAAqBA,CAAkB,IAGnD/f,KAAKwd,yBAAyBC,EAAUC,GACxC1d,KAAKmlB,kBAAkBzH,EAAUD,EAAUlQ,GAC3CvN,KAAK0mB,iBAAiBhJ,EAAUD,GACzBC,C,CAOHyM,4BAA4BC,GAChC,IAAIrP,EAA8BqP,EAAQ/O,oBACtChO,EAAa+c,EAAQC,WAAWC,WAGhCC,EAFqBxP,EAAOyP,SAEQ1T,UAAU2T,YAC9CC,EAA8B,IAAI3E,YACtCwE,EAAcI,OAAOD,GAErB,IAAIxX,EAAU7F,EAAKud,aAEf3O,EAAuB,GACvBqK,EAAyB,GACzBuE,EAAyB,GAC7Bxd,EAAKyd,aAAa7O,GAClB5O,EAAK0d,eAAezE,GACpBjZ,EAAK2d,eAAeH,GAEpB,IAAII,EAA6B,GACjC5d,EAAK6d,WAAWriB,SAAQ,CAACgb,EAAkBvZ,KACRuZ,EAAQK,iBAC7Brb,SAAQ,CAACsiB,EAAuBC,KACtC,IAAIpL,EAAgB6D,EAAQM,qBAAqBiH,GAE7CC,EADgBxH,EAAQO,qBAAqBgH,GAClBpL,EAC/B,IAAK,IAAIsL,EAAStL,EAAOsL,EAASD,EAAUC,IAAU,CAClD,IAAIC,EAAarY,EAAQoY,GACrBE,EAAqBlF,EAAYiF,GACjC/G,EAAY2G,EAASK,EAAUhH,GAC/BC,EAAY0G,EAASK,EAAU/G,GAC/BC,EAAYyG,EAASK,EAAU9G,GAC/B+G,EAAYN,EAASK,EAAUC,GACnCR,EAAgBM,GAAM,IAAI1oB,UAAQ2hB,EAAGC,EAAGC,EAAG+G,EAC9C,IACH,IAGN,IAAIC,EAAgCre,EAAKsY,kBACrCgG,EAAoB5Q,EAAO4Q,MAC3BC,EAAsB,GACtBC,EAAqB,IAAI9F,YAC7B4F,EAAM9iB,SAAQ,CAACijB,EAAMxhB,KACjBshB,EAAOthB,GAAS,IAAIyb,YACpBA,YAAUgG,SAASrB,EAAkBoB,EAAKhV,UAAU2T,YAAaoB,GACjE9F,YAAUgG,SAASF,EAASH,EAAiBphB,GAAQshB,EAAOthB,GAAO,IAGvE,IAAI0hB,EAA2B,IAAIjG,YAC/BkG,EAAkB,IAAInoB,UACtB8L,EAAe,IAAI9L,UAAQyf,OAAOC,UAAWD,OAAOC,UAAWD,OAAOC,WACtEC,EAAe,IAAI3f,WAASyf,OAAOC,WAAYD,OAAOC,WAAYD,OAAOC,WAE7E,IAAK,IAAIlZ,EAAQ,EAAGA,EAAQ2R,EAAUrN,OAAQtE,IAAS,CACnD,IAAI4hB,EAAejQ,EAAU3R,GACzBkhB,EAAqBP,EAAgB3gB,GACrC6hB,EAAsBtB,EAAYvgB,GAEtC,GAAMkhB,GAAaW,EAAnB,CAIA,IAAK,IAAIC,EAAK,EAAGA,EAAK,GAAIA,IACtBJ,EAAczS,SAAS6S,GAAMR,EAAOJ,EAAUhH,GAAGjL,SAAS6S,GAAMD,EAAW3H,EAC3EwH,EAAczS,SAAS6S,IAAOR,EAAOJ,EAAU/G,GAAGlL,SAAS6S,GAAMD,EAAW1H,EAC5EuH,EAAczS,SAAS6S,IAAOR,EAAOJ,EAAU9G,GAAGnL,SAAS6S,GAAMD,EAAWzH,EAC5EsH,EAAczS,SAAS6S,IAAOR,EAAOJ,EAAUC,GAAGlS,SAAS6S,GAAMD,EAAWV,EAEhF3nB,UAAQuoB,gBAAgBH,EAAKF,EAAeC,GAC5CnoB,UAAQ8L,IAAIA,EAAKqc,EAAQrc,GACzB9L,UAAQ2f,IAAIA,EAAKwI,EAAQxI,EAVxB,CAYJ,CAiBDxH,EAAY,KACZqK,EAAcuE,EAAcI,EAAkB,KAC9C/X,EAAU,KACV0Y,EAAS,KAET7Q,EAAOuR,YAAYxH,OAAOlV,GAC1BmL,EAAOuR,YAAYvH,OAAOtB,GAC1B1I,EAAOuR,YAAcvR,EAAOuR,W,CASxBpS,iBAAiB9M,EAAyBgd,GAC9C,IAAI1c,EAAsB1N,KAAKuI,MAAMkF,MAAML,EAASM,MAChD2N,EAA2C+O,EAAQ/O,oBACvD3N,EAAK0X,OAAOvc,SAAQoQ,IAChB,IAAI6S,EAAiB9rB,KAAKmI,OAAO8Q,GACjCoC,EAAoBsQ,MAAMniB,KAAKsiB,EAAK,IAEnB7gB,MAAjByC,EAAK6e,WACL7e,EAAK6e,SAAW7e,EAAK0X,OAAO,IAEhC/J,EAAoBmP,SAAWxqB,KAAKmI,OAAOuF,EAAK6e,UAEhDvsB,KAAKmqB,4BAA4BC,E,CAO7BoC,iBAAiBC,GACrB,MAAMC,cAAgB,CAACC,EAAmBC,KACtC,IAAKD,EACD,OAAO,EACX,IAAuC,GAAnCA,EAAQjU,QAAQkU,GAChB,IAAK,IAAItiB,EAAQ,EAAGA,EAAQqiB,EAAQ/d,OAAQtE,IAAS,CACjD,IAAI8C,EAA0BpN,KAAKuI,MAAM4E,MAAMwf,EAAQriB,IACvD,GAAIoiB,cAActf,EAAS0M,SAAU8S,GACjC,OAAO,CAEd,CAEL,OAAO,CAAI,EAGf,IACIC,EAD0CJ,EAAS,GAAGxR,OACzByK,KACjC,IAAK,IAAIpb,EAAQ,EAAGA,EAAQtK,KAAKuI,MAAM2H,OAAOtB,OAAQtE,IAAS,CAC3D,IAAIsO,EAA4B5Y,KAAKuI,MAAM2H,OAAO5F,GAClD,GAAIoiB,cAAc9T,EAAUzL,MAAO0f,GAC/B,OAAO7sB,KAAKkI,QAAQoC,EAE3B,CACD,OAAO,I,CASHwiB,iBAAiBC,EAAgBC,GACrC,IAAIC,EAAkB,GACtB,GAAIF,GAAQC,EACR,OAAOC,EAEX,IAAI/T,EAAmB8T,EACvB,KAAO9T,EAAOgU,QAAUH,GACpB7T,EAAmBA,EAAOgU,OAC1BD,EAAMzjB,KAAK0P,EAAO5W,MAItB,OAFA2qB,EAAQA,EAAMlR,UACdkR,EAAMzjB,KAAKwjB,EAAU1qB,MACd2qB,C,CAQH9c,eAAeC,GACdA,GAGLA,EAAWvH,SAAQ,CAACskB,EAA+B7iB,KAE/CtK,KAAKotB,cAAcD,EAAU,G,CAS7BC,cAAcD,GAGlB,OAAOntB,KAAKqtB,eAAeF,E,CAQvBE,eAAeF,GAEnB,IAAIV,EAAwCU,EAAUV,SACVU,EAAUniB,SAEtD,IAAIsiB,EAAyBttB,KAAKwsB,iBAAiBC,GAEnD,IAAKa,EACD,OAAO,KAGX,IAAIC,EAAqBD,EAAaE,aAAaC,YACnD,IAAKF,EAAU,CACXA,EAAWD,EAAaI,aAAaD,YACrC,IAAIE,EAAyC,IAAIC,0BAAwB,iBACzEL,EAASM,mBAAmBF,GAC5BA,EAAcG,cAAgB,CACjC,CAED,IAAIC,EAAsB/tB,KAAKguB,mBAAmBb,EAAWG,GACzDK,EAAyCJ,EAASU,qBAElDC,EAAwBH,EAAKzrB,KAE7BqrB,EAAcQ,iBAAiBD,KAC/BA,EAAgBH,EAAKzrB,KAAO,GAAG4rB,KAAiBluB,KAAK6Q,WAAWqd,MAGpE,IAAIE,EAA+B,IAAIC,gBAQvC,OANAD,EAAc9rB,KAAO4rB,EACrBE,EAAcL,KAAOA,EACrBJ,EAAcW,SAASF,GACvBT,EAAcY,aAAeH,EAC7BT,EAAca,YAAa,EAEpBjB,C,CAUDS,mBAAmBb,EAA+BG,GACxD,IAAIS,EAAsB,IAAIU,gBAE1BC,EAAmB,EAEnBjC,EAAwCU,EAAUV,SAClDzhB,EAAwCmiB,EAAUniB,SAElD2jB,EAAwB,GAC5BlC,EAAS5jB,SAAQ,CAAC4e,EAAoCnd,K,MAClD,IAAI2Q,EAA0CwM,EAAQxM,OAClDnQ,EAAqCE,EAASyc,EAAQ3c,SACtD8jB,EAAkD3T,EAAO4T,KAEzDC,EAAa9uB,KAAKyS,2BAA2B3H,EAAQikB,OACrDC,EAAYhvB,KAAKyS,2BAA2B3H,EAAQmkB,QAEpDC,EAAY,IAAIvd,aAAamd,GAC7BK,EAAW,IAAIxd,aAAaqd,GAE5B9V,EAAmBlZ,KAAKmI,OAAO8S,EAAOyK,MAEtC0J,EAAapvB,KAAK8sB,iBAAiBQ,EAAcpU,GAErD,GAAc,WAAV0V,EAA2D,CAE3D,IAAIvhB,EAAwC,QAAjCG,EAAA0L,EAAOsU,aAAa6B,qBAAa,IAAA7hB,OAAA,EAAAA,EAAA8c,WAC5C,GAAIjd,GAAQA,EAAK6N,gBAAiB,CAE9B,IAAIoU,EAAWpW,EAAOsU,aAAa+B,uBAAuB,sBAAwB,eAE9EzI,EAAYzZ,EAAK6N,gBACjBsU,EAAe1I,EAAU0I,aAE7B,GAAIL,EAASvgB,OAASsgB,EAAUtgB,QAAU4gB,EACtC,IAAK,IAAIC,EAAe,EAAGA,EAAeD,EAAcC,IAAgB,CACpE,IACIC,EADe5I,EAAU3L,uBAAuBsU,GACrBntB,KAE3BqtB,EAAqB,GACzBhB,EAAUnlB,KAAKmmB,GACfA,EAAS1C,MAAQmC,EACjBO,EAASC,cAAgB9kB,EAAQ8kB,cACjCD,EAAST,UAAYA,EACrBS,EAASE,WAAa,IAAIle,aAAaud,EAAUtgB,QACjD,IAAK,IAAI7F,EAAI,EAAGA,EAAImmB,EAAUtgB,OAAQ7F,IAClC4mB,EAASE,WAAW9mB,GAAKomB,EAASpmB,EAAIymB,EAAeC,GAGzDE,EAASG,cAAgBR,EACzBK,EAASI,WAAa,GACtBJ,EAASI,WAAWvmB,KAAK,qBACzBmmB,EAASI,WAAWvmB,KAAKkmB,GACzBC,EAASK,eAAiBL,EAASI,WAAWnhB,OAC9C+gB,EAAS1e,KAAO,EAChB0e,EAASM,aAAe,0BACxBN,EAASO,eAAiB,CAACR,GAC3BC,EAASQ,mBAAqB,oBAE9BR,EAASjB,SAAWiB,EAAST,UAAUS,EAAST,UAAUtgB,OAAS,GACnE8f,EAAW/e,KAAK8T,IAAIiL,EAAUiB,EAASjB,SAC1C,CAER,CACJ,KACI,CACD,IAAIiB,EAAqB,GACzBhB,EAAUnlB,KAAKmmB,GACfA,EAAST,UAAYA,EACrBS,EAASE,WAAaV,EACtB,IAAIS,EAAgB9kB,EAAQ8kB,cAK5B,OAJAD,EAASC,cAAgBA,EAEzBD,EAAS1C,MAAQmC,EAETR,GACJ,kBACIe,EAASG,cAAgB,YACzBH,EAASK,eAAiB,EAC1BL,EAASI,WAAa,GACtBJ,EAASI,WAAWvmB,KAAK,iBACzBmmB,EAAS1e,KAAO,EAChB,MACJ,eACI0e,EAASG,cAAgB,YACzBH,EAASK,eAAiB,EAC1BL,EAASI,WAAa,GACtBJ,EAASI,WAAWvmB,KAAK,iBACzBmmB,EAAS1e,KAAO,EAChB,MACJ,YACI0e,EAASG,cAAgB,YACzBH,EAASK,eAAiB,EAC1BL,EAASI,WAAa,GACtBJ,EAASI,WAAWvmB,KAAK,cACzBmmB,EAAS1e,KAAO,EAMxB0e,EAASjB,SAAWiB,EAAST,UAAUS,EAAST,UAAUtgB,OAAS,GACnE8f,EAAW/e,KAAK8T,IAAIiL,EAAUiB,EAASjB,SAC1C,KAGLX,EAAKzrB,KAAO6qB,EAAU7qB,KAAO6qB,EAAU7qB,KAAO,aAAatC,KAAK6Q,WAAW,eAC3Ekd,EAAKqC,UAAY1B,EACjBX,EAAKsC,WAAY,EACjBtC,EAAKuC,WAAa,GAClB,IAAIC,EAAoB5B,EAAU/f,OAC9BzB,EAA0B4gB,EAAK5lB,OACnCgF,EAAM4E,MAAQwe,EACd,IAAIC,EAAgBzC,EAAK0C,UAAY,GACjCC,EAAgB3C,EAAK4C,UAAY,GACrC,IAAK,IAAI5nB,EAAY,EAAGA,EAAIwnB,EAAWxnB,IAAK,CACxC,IAAI2c,EAAqB,IAAIkL,eAEzBC,EAAyBlC,EAAU5lB,GAEvCoE,EAAM2jB,eAAe/nB,EAAG2c,GACxBA,EAAKqL,aAAehoB,EAEpB,IAAIkI,EAAeyU,EAAKzU,KAAO4f,EAAa5f,KACxC+f,EAAqBH,EAAa5D,MAAMre,OAC5C8W,EAAKuL,mBAAmBD,GACxB,IAAIE,EAAqBL,EAAa5D,MACtC,IAAK,IAAI1jB,EAAY,EAAGA,EAAIynB,EAAYznB,IACpCmc,EAAKyL,qBAAqB5nB,EAAG2nB,EAAS3nB,IAE1C,IAAI6nB,EAAmB1L,EAAK2L,eAAe,KACvCC,EAA2Bd,EAASY,GACxC,IAAeZ,EAASY,GAAYE,EAAW,IAC/CA,EAAS9nB,KAAKkc,GACdA,EAAKoK,cAAgBe,EAAaf,cAClC,IAAIE,EAAyBa,EAAab,eAC1CtK,EAAK6L,kBAAkBvB,GACvB,IAAK,IAAIzmB,EAAY,EAAGA,EAAIymB,EAAgBzmB,IACxCmc,EAAK8L,oBAAoBjoB,EAAGsnB,EAAad,WAAWxmB,IAExD,IAAIkoB,EAAmBL,EAAW,IAAM1L,EAAKoK,cAAgB,IAAMpK,EAAKgM,cAAc,KACtFhB,EAASe,GAAYA,EACrB/L,EAAK+L,SAAWA,EAEhB/L,EAAKiM,gBAAkBd,EAAaZ,aACpCvK,EAAKkM,WAAaf,EAAaX,eAC/BxK,EAAKyK,mBAAqBU,EAAaV,mBAEvC,IAAI0B,EAAwBhB,EAAa3B,UAAUtgB,OAGnD,IAAK,IAAIrF,EAAY,EAAGA,EAAIsoB,EAAetoB,IACvC,OAAQ0H,GACJ,KAAK,EACD,IAAI6gB,EAAgB,IAAIC,gBAIxB,OAHArM,EAAKsM,oBAAoBzoB,EAAGuoB,GAC5BA,EAAcG,KAAOpB,EAAa3B,UAAU3lB,GAEpCsnB,EAAajB,eACjB,kBAEQkC,EAAczjB,MAAQwiB,EAAahB,WAAW,EAAItmB,EAAI,GAEtDuoB,EAAcI,UAAYrB,EAAahB,WAAW,EAAItmB,EAAI,GAC1DuoB,EAAcK,WAAatB,EAAahB,WAAW,EAAItmB,EAAI,GAE/D,MACJ,WACIuoB,EAAczjB,MAAQwiB,EAAahB,WAAWtmB,GAC9CuoB,EAAcI,UAAYE,IAC1BN,EAAcK,WAAaC,IAC3B,MAEJ,QACI,CACIN,EAAczjB,MAAQwiB,EAAahB,WAAWtmB,GAE9C,IAAI8oB,EAAa,GAAL9oB,EAASA,EAAIA,EAAI,EACzB+oB,EAAWzB,EAAa3B,UAAUmD,GAClCE,EAAY1B,EAAahB,WAAWwC,GACpCG,EAAcH,GAAS9oB,EAAI,EAAKuoB,EAAcG,KAAOK,EAEzDR,EAAcI,WAAaJ,EAAczjB,MAAQkkB,GAAaC,EAE9D,IAAIC,EAAQlpB,GAAKsoB,EAAgB,EAAItoB,EAAIA,EAAI,EACzCmpB,EAAW7B,EAAa3B,UAAUuD,GAClCE,EAAY9B,EAAahB,WAAW4C,GACpCG,EAAcH,GAASlpB,EAAI,EAAKmpB,EAAWZ,EAAcG,KAE7DH,EAAcK,YAAcQ,EAAYb,EAAczjB,OAASukB,EAE3DP,GAAS9oB,IACTuoB,EAAcI,UAAYJ,EAAcK,YAExCM,GAASlpB,IACTuoB,EAAcK,WAAaL,EAAcI,UAEhD,EAIT,MACJ,KAAK,EACL,KAAK,EACL,KAAK,EACD,IAAIW,EAAsC,IAAIC,kBAC9CpN,EAAKsM,oBAAoBzoB,EAAGspB,GAC5B,IAAIE,EAAsBF,EAAmBZ,KAAOpB,EAAa3B,UAAU3lB,GACvE2oB,EAAqBW,EAAmBX,UACxCC,EAAsBU,EAAmBV,WACzC9jB,EAAiBwkB,EAAmBxkB,MAExC,OAAQwiB,EAAajB,eACjB,kBACIvhB,EAAM2kB,SAASnC,EAAahB,WAAW,EAAItmB,EAAI,GAAIsnB,EAAahB,WAAW,EAAItmB,EAAI,GAAIsnB,EAAahB,WAAW,EAAItmB,EAAI,IACvH2oB,EAAUc,SAASnC,EAAahB,WAAW,EAAItmB,EAAI,GAAIsnB,EAAahB,WAAW,EAAItmB,EAAI,GAAIsnB,EAAahB,WAAW,EAAItmB,EAAI,IAC3H4oB,EAAWa,SAASnC,EAAahB,WAAW,EAAItmB,EAAI,GAAIsnB,EAAahB,WAAW,EAAItmB,EAAI,GAAIsnB,EAAahB,WAAW,EAAItmB,EAAI,IAC5H,MACJ,WACI8E,EAAM2kB,SAASnC,EAAahB,WAAW,EAAItmB,GAAIsnB,EAAahB,WAAW,EAAItmB,EAAI,GAAIsnB,EAAahB,WAAW,EAAItmB,EAAI,IACnH2oB,EAAUc,SAASZ,IAAUA,IAAUA,KACvCD,EAAWa,SAASZ,IAAUA,IAAUA,KACxC,MAEJ,QACI,CACI/jB,EAAM2kB,SAASnC,EAAahB,WAAW,EAAItmB,GAAIsnB,EAAahB,WAAW,EAAItmB,EAAI,GAAIsnB,EAAahB,WAAW,EAAItmB,EAAI,IAEnH,IAAI8oB,EAAa,GAAL9oB,EAASA,EAAIA,EAAI,EACzB+oB,EAAWzB,EAAa3B,UAAUmD,GAClCY,EAAQpC,EAAahB,WAAW,EAAIwC,GACpCa,EAAQrC,EAAahB,WAAW,EAAIwC,EAAQ,GAC5Cc,EAAQtC,EAAahB,WAAW,EAAIwC,EAAQ,GAE5CG,EAAcH,GAAS9oB,EAAI,EAAIwpB,EAAcT,EACjDJ,EAAU1N,GAAKnW,EAAMmW,EAAIyO,GAAST,EAClCN,EAAUzN,GAAKpW,EAAMoW,EAAIyO,GAASV,EAClCN,EAAUxN,GAAKrW,EAAMqW,EAAIyO,GAASX,EAElC,IAAIC,EAAQlpB,GAAKsoB,EAAgB,EAAItoB,EAAIA,EAAI,EACzCmpB,EAAW7B,EAAa3B,UAAUuD,GAClCW,EAAQvC,EAAahB,WAAW,EAAI4C,GACpCY,EAAQxC,EAAahB,WAAW,EAAI4C,EAAQ,GAC5Ca,EAAQzC,EAAahB,WAAW,EAAI4C,EAAQ,GAE5Cc,EAAcd,GAASlpB,EAAI,EAAImpB,EAAWK,EAC9CZ,EAAW3N,GAAK4O,EAAQ/kB,EAAMmW,GAAK+O,EACnCpB,EAAW1N,GAAK4O,EAAQhlB,EAAMoW,GAAK8O,EACnCpB,EAAWzN,GAAK4O,EAAQjlB,EAAMqW,GAAK6O,EAE/BlB,GAAS9oB,GACT4oB,EAAWqB,QAAQtB,GAEnBO,GAASlpB,GACT2oB,EAAUsB,QAAQrB,EAEzB,EAGT,MACJ,KAAK,EACD,IAAIsB,EAAyC,IAAIC,qBACjDhO,EAAKsM,oBAAoBzoB,EAAGkqB,GAC5B,IAAIE,EAAsBF,EAAmBxB,KAAOpB,EAAa3B,UAAU3lB,GACvEqqB,EAAwBH,EAAmBvB,UAC3C2B,EAAyBJ,EAAmBtB,WAC5C2B,EAAuBL,EAAmBplB,MAC9C,OAAQwiB,EAAajB,eACjB,kBACIkE,EAASvlB,IAAIsiB,EAAahB,WAAW,GAAKtmB,EAAI,GAAIsnB,EAAahB,WAAW,GAAKtmB,EAAI,GAAIsnB,EAAahB,WAAW,GAAKtmB,EAAI,GAAIsnB,EAAahB,WAAW,GAAKtmB,EAAI,IAC7JqqB,EAAaZ,SAASnC,EAAahB,WAAW,GAAKtmB,EAAI,GAAIsnB,EAAahB,WAAW,GAAKtmB,EAAI,GAAIsnB,EAAahB,WAAW,GAAKtmB,EAAI,GAAIsnB,EAAahB,WAAW,GAAKtmB,EAAI,IACtKsqB,EAAcb,SAASnC,EAAahB,WAAW,GAAKtmB,EAAI,GAAIsnB,EAAahB,WAAW,GAAKtmB,EAAI,GAAIsnB,EAAahB,WAAW,GAAKtmB,EAAI,IAAKsnB,EAAahB,WAAW,GAAKtmB,EAAI,KACxK,MACJ,WACIuqB,EAASvlB,IAAIsiB,EAAahB,WAAW,EAAItmB,EAAI,GAAIsnB,EAAahB,WAAW,EAAItmB,EAAI,GAAIsnB,EAAahB,WAAW,EAAItmB,EAAI,GAAIsnB,EAAahB,WAAW,EAAItmB,EAAI,IACzJqqB,EAAaZ,SAASZ,IAAUA,IAAUA,IAAUA,KACpDyB,EAAcb,SAASZ,IAAUA,IAAUA,IAAUA,KACrD,MAGJ,QACI,CACI0B,EAASvlB,IAAIsiB,EAAahB,WAAW,EAAItmB,EAAI,GAAIsnB,EAAahB,WAAW,EAAItmB,EAAI,GAAIsnB,EAAahB,WAAW,EAAItmB,EAAI,GAAIsnB,EAAahB,WAAW,EAAItmB,EAAI,IAEzJ,IAAI8oB,EAAa,GAAL9oB,EAASA,EAAIA,EAAI,EACzB+oB,EAAWzB,EAAa3B,UAAUmD,GAClCY,EAAQpC,EAAahB,WAAW,EAAIwC,GACpCa,EAAQrC,EAAahB,WAAW,EAAIwC,EAAQ,GAC5Cc,EAAQtC,EAAahB,WAAW,EAAIwC,EAAQ,GAC5C0B,EAAQlD,EAAahB,WAAW,EAAIwC,EAAQ,GAE5CG,EAAcH,GAAS9oB,EAAI,EAAIoqB,EAAcrB,EACjDsB,EAAapP,GAAKsP,EAAStP,EAAIyO,GAAST,EACxCoB,EAAanP,GAAKqP,EAASrP,EAAIyO,GAASV,EACxCoB,EAAalP,GAAKoP,EAASpP,EAAIyO,GAASX,EACxCoB,EAAanI,GAAKqI,EAASrI,EAAIsI,GAASvB,EAExC,IAAIC,EAAQlpB,GAAKsoB,EAAgB,EAAItoB,EAAIA,EAAI,EACzCmpB,EAAW7B,EAAa3B,UAAUuD,GAClCW,EAAQvC,EAAahB,WAAW,EAAI4C,GACpCY,EAAQxC,EAAahB,WAAW,EAAI4C,EAAQ,GAC5Ca,EAAQzC,EAAahB,WAAW,EAAI4C,EAAQ,GAC5CuB,EAAQnD,EAAahB,WAAW,EAAI4C,EAAQ,GAE3CqB,EAAStP,EAAI4O,EAAQU,EAASrP,EAAI4O,EAAQS,EAASpP,EAAI4O,EAAQQ,EAASrI,EAAIuI,EAAS,IACtFZ,IAAU,EACVC,IAAU,EACVC,IAAU,EACVU,IAAU,EACVnD,EAAahB,WAAW,EAAI4C,GAASW,EACrCvC,EAAahB,WAAW,EAAI4C,EAAQ,GAAKY,EACzCxC,EAAahB,WAAW,EAAI4C,EAAQ,GAAKa,EACzCzC,EAAahB,WAAW,EAAI4C,EAAQ,GAAKuB,GAG7C,IAAIT,EAAcd,GAASlpB,EAAI,EAAImpB,EAAWiB,EAC9CE,EAAcrP,GAAK4O,EAAQU,EAAStP,GAAK+O,EACzCM,EAAcpP,GAAK4O,EAAQS,EAASrP,GAAK8O,EACzCM,EAAcnP,GAAK4O,EAAQQ,EAASpP,GAAK6O,EACzCM,EAAcpI,GAAKuI,EAAQF,EAASrI,GAAK8H,EAErClB,GAAS9oB,GACTsqB,EAAcL,QAAQI,GAEtBnB,GAASlpB,GACTqqB,EAAaJ,QAAQK,EAG5B,GAMxB,CAID,OAFAlF,EAAY,KAELZ,C,EAl4EIxmB,aAAWc,YAAkE,GAw5EhG,MAAM6hB,iBAcFziB,c,EAwBJwsB,OAAKC,cAAa,KACdp0B,WAAWq0B,MAAM,IC/+ErB,MAAMC,EAAgB,wBAiBhBza,EAAc,IAAI1W,YAClB2W,EAAW,IAAI3W,YAEfklB,EAAS,IAAIkM,UACb7c,EAAQ,IAAI6c,U,MAGLC,sBAMT7sB,YAAY8sB,GAJHv0B,KAAIsC,KAAW8xB,EAKpBp0B,KAAKw0B,UAAYD,C,CAGrBE,gBAAgB9nB,G,MACZwb,EAAO6K,SAAS,EAAG,GACfrmB,EAAUwb,QACVA,EAAOjR,UAAUvK,EAAUwb,QAE/BllB,YAAUyxB,sBAAsBvM,EAAQxO,GAExC,IAAIgb,EAAwB,QAAlBnnB,EAAAb,EAAUiN,gBAAQ,IAAApM,IAAI,EAChCvK,YAAU2xB,oBAAoBD,EAAK/a,GAEnCpC,EAAMwb,SAAS,EAAG,GACdrmB,EAAU6K,OACVA,EAAMN,UAAUvK,EAAU6K,OAG9B,IAAIqd,EAAQ,IAAI5xB,YAGhB,OAFAA,YAAU8oB,SAASpS,EAAaC,EAAUib,GAC1CA,EAAMrd,MAAMA,EAAOqd,GACZA,C,CAGXvf,yBAAyBlL,G,MACrB,IAAIuC,EAAsD,QAAfa,EAAApD,EAAKiL,kBAAU,IAAA7H,OAAA,EAAAA,EAAE8mB,sBAK5D,MAAO,CACHxd,UAJQ9W,KAAKy0B,gBAAgB9nB,GAK7BsI,SAJWtI,EAAUsI,S,EAUjC1N,aAAautB,kBAAkBV,GAAgBG,GAAa,IAAID,sBAAsBC,KCpEtF,MAAMH,EAAgB,2B,MAeTW,yBAKTttB,YAAY8sB,GAJHv0B,KAAIsC,KAAW8xB,EAKpBp0B,KAAKw0B,UAAYD,C,CAGrB3nB,qBAAqBnE,EAAkBC,GACnC,IAAIwD,EAAYlM,KAAKw0B,UAAUlsB,KAAK4D,UAChC1B,EAAWxK,KAAKw0B,UAAUlsB,KAAKkC,SAEnC,GAAI0B,GAAa1B,EAAU,CACvB,IAAI5B,EAAsC,GAU1C,OATAsD,EAAUrD,SAAQ2M,I,MACd,IAAI7I,EAA4D,QAAnBa,EAAAgI,EAASH,kBAAU,IAAA7H,OAAA,EAAAA,EAAEunB,yBAClE,GAAIpoB,GACIA,EAAUqoB,kBAAmB,CAC7B,IAAI1oB,EAAUtM,KAAKw0B,UAAUrqB,oBAAoBwC,EAAUqoB,mBAAmB,EAAOvsB,EAAUC,GAC/FE,EAASY,KAAK8C,EACjB,CACJ,IAEEtC,QAAQC,IAAIrB,EACtB,CAEG,OAAOoB,QAAQE,S,CAIvBmO,2BAA2BlM,EAAiCqJ,G,QACxD,IAAI7I,EAAyCR,EAAakJ,WAAW0f,yBAEjEE,EAAyC,QAA5BznB,EAAAb,EAAUuoB,0BAAkB,IAAA1nB,IAAI,EAC7CoM,EAAuC,QAA5BlL,EAAA/B,EAAUwoB,0BAAkB,IAAAzmB,IAAI,EAM/C,GAJA8G,EAASmB,UAAUoB,eAAaqd,mBAAmB,GACnD5f,EAAS6B,SAAS,uBAAwB4d,GAC1Czf,EAAS6B,SAAS,uBAAwBuC,GAEtCjN,EAAUqoB,kBAAmB,CAC7B,IAAIzqB,EAAMvK,KAAKw0B,UAAUzf,mBAAmBpI,EAAUqoB,mBACtDxf,EAASkB,WAAW,sBAAuBnM,GAC3CiL,EAASmB,UAAU7W,WAAWoB,sBAAsB,EACvD,C,EAITqG,aAAautB,kBAAkBV,GAAgBG,GAAa,IAAIQ,yBAAyBR,KChEzF,MAAMH,EAAgB,0B,MAyBTiB,wBAKT5tB,YAAY8sB,GAJHv0B,KAAIsC,KAAW8xB,EAKpBp0B,KAAKw0B,UAAYD,C,CAGrB3nB,qBAAqBnE,EAAkBC,GACnC,IAAIwD,EAAYlM,KAAKw0B,UAAUlsB,KAAK4D,UAChC1B,EAAWxK,KAAKw0B,UAAUlsB,KAAKkC,SAEnC,GAAI0B,GAAa1B,EAAU,CACvB,IAAI5B,EAAsC,GAkB1C,OAjBAsD,EAAUrD,SAAQ2M,I,MACd,IAAI7I,EAA2D,QAAnBa,EAAAgI,EAASH,kBAAU,IAAA7H,OAAA,EAAAA,EAAE6nB,wBACjE,GAAI1oB,EAAW,CACX,GAAIA,EAAU2oB,iBAAkB,CAC5B,IAAIhpB,EAAUtM,KAAKw0B,UAAUrqB,oBAAoBwC,EAAU2oB,kBAAkB,EAAO7sB,EAAUC,GAC9FE,EAASY,KAAK8C,EACjB,CACD,GAAIK,EAAU4oB,0BAA2B,CACrC,IAAIjpB,EAAUtM,KAAKw0B,UAAUrqB,oBAAoBwC,EAAU4oB,2BAA2B,EAAO9sB,EAAUC,GACvGE,EAASY,KAAK8C,EACjB,CACD,GAAIK,EAAU6oB,uBAAwB,CAClC,IAAIlpB,EAAUtM,KAAKw0B,UAAUrqB,oBAAoBwC,EAAU6oB,wBAAwB,EAAO/sB,EAAUC,GACpGE,EAASY,KAAK8C,EACjB,CACJ,KAEEtC,QAAQC,IAAIrB,EACtB,CAEG,OAAOoB,QAAQE,S,CAIvBmO,2BAA2BlM,EAAiCqJ,G,UACxD,IAAI7I,EAAwCR,EAAakJ,WAAWggB,wBAChEI,EAAqC,QAAzBjoB,EAAAb,EAAU+oB,uBAAe,IAAAloB,IAAI,EACzCmoB,EAAuD,QAAlCjnB,EAAA/B,EAAUipB,gCAAwB,IAAAlnB,IAAI,EAc/D,GAZA8G,EAASmB,UAAUoB,eAAa8d,kBAAkB,GAElDrgB,EAAS6B,SAAS,oBAAqBoe,GACnC9oB,EAAU2oB,kBACVt1B,KAAKw0B,UAAUne,2BAA2Bb,EAAU7I,EAAU2oB,iBAAkB,qBAAsBx1B,WAAWe,oBAAqB,0BAA2Bf,WAAWgB,8BAGhL0U,EAAS6B,SAAS,uBAAwBse,GACtChpB,EAAU4oB,2BACVv1B,KAAKw0B,UAAUne,2BAA2Bb,EAAU7I,EAAU4oB,0BAA2B,8BAA+Bz1B,WAAWiB,6BAA8B,mCAAoCjB,WAAWkB,uCAGhN2L,EAAU6oB,uBAAwB,CAClChgB,EAASmB,UAAUoB,eAAa+d,yBAAyB,GAEzD91B,KAAKw0B,UAAUne,2BAA2Bb,EAAU7I,EAAU6oB,uBAAwB,2BAA4B,KAAM,gCAAiC11B,WAAWmB,oCAEpK,IAAIuW,EAAkD,QAA1C3H,EAAAlD,EAAU6oB,uBAAuBhe,aAAS,IAAA3H,IAAA,EACtD2F,EAAS6B,SAAS,yBAA0BG,EAE/C,C,EAMTjQ,aAAautB,kBAAkBV,GAAgBG,GAAa,IAAIc,wBAAwBd,KCjGxF,MAAMH,EAAgB,kC,MAWT2B,gCAKTtuB,YAAY8sB,GAJHv0B,KAAIsC,KAAW8xB,EAKpBp0B,KAAKw0B,UAAYD,C,CAGrBlc,2BAA2BlM,EAA4BqJ,G,MAEnD,IAEIwgB,EAA6C,QAA1BxoB,EAF4BrB,EAAakJ,WAAW0gB,gCAE1CE,wBAAgB,IAAAzoB,IAAI,EAErDgI,EAAS6B,SAAS,qBAAsB2e,E,EAKhDzuB,aAAautB,kBAAkBV,GAAgBG,GAAa,IAAIwB,gCAAgCxB,KCjChG,MAAMH,EAAgB,oB,MAWT8B,kBAMTzuB,YAAY8sB,GAJHv0B,KAAIsC,KAAW8xB,EAKpBp0B,KAAKw0B,UAAYD,C,CAGrBlc,2BAA2BlM,EAAiCqJ,G,MACxD,IAEI2gB,EAAmB,QAAb3oB,EAF4BrB,EAAakJ,WAAW6gB,kBAE1CC,WAAG,IAAA3oB,IAAI,IAE3BgI,EAASmB,UAAUoB,eAAaqe,YAAY,GAC5C5gB,EAAS6B,SAAS,QAAS8e,E,EAKnC5uB,aAAautB,kBAAkBV,GAAgBG,GAAa,IAAI2B,kBAAkB3B,KC7BlF,MAAMH,EAAgB,4B,MAqBTiC,0BAKT5uB,YAAY8sB,GAJHv0B,KAAIsC,KAAW8xB,EAKpBp0B,KAAKw0B,UAAYD,C,CAIrB3nB,qBAAqBnE,EAAkBC,GACnC,IAAIwD,EAAYlM,KAAKw0B,UAAUlsB,KAAK4D,UAChC1B,EAAWxK,KAAKw0B,UAAUlsB,KAAKkC,SAEnC,GAAI0B,GAAa1B,EAAU,CACvB,IAAI5B,EAAsC,GAe1C,OAdAsD,EAAUrD,SAAQ2M,I,MACd,IAAI7I,EAA6D,QAAnBa,EAAAgI,EAASH,kBAAU,IAAA7H,OAAA,EAAAA,EAAE6oB,0BACnE,GAAI1pB,EAAW,CACX,GAAIA,EAAU2pB,mBAAoB,CAC9B,IAAIhqB,EAAUtM,KAAKw0B,UAAUrqB,oBAAoBwC,EAAU2pB,oBAAoB,EAAO7tB,EAAUC,GAChGE,EAASY,KAAK8C,EACjB,CACD,GAAIK,EAAU4pB,4BAA6B,CACvC,IAAIjqB,EAAUtM,KAAKw0B,UAAUrqB,oBAAoBwC,EAAU4pB,6BAA6B,EAAO9tB,EAAUC,GACzGE,EAASY,KAAK8C,EACjB,CACJ,KAGEtC,QAAQC,IAAIrB,EACtB,CAEG,OAAOoB,QAAQE,S,CAIvBmO,2BAA2BlM,EAAiCqJ,G,YACxD,IAAI7I,EAA0CR,EAAakJ,WAAWghB,0BAElEG,EAAoC,QAA3BhpB,EAAAb,EAAU8pB,yBAAiB,IAAAjpB,IAAI,EACxC2oB,EAA8B,QAAxBznB,EAAA/B,EAAU+pB,sBAAc,IAAAhoB,IAAI,IAClCioB,EAAoD,QAArC9mB,EAAAlD,EAAUiqB,mCAA2B,IAAA/mB,IAAI,IACxDgnB,EAAoD,QAArCnf,EAAA/K,EAAUmqB,mCAA2B,IAAApf,IAAI,IAE5DlC,EAASmB,UAAUoB,eAAagf,oBAAoB,GACpDvhB,EAAS6B,SAAS,sBAAuBmf,GACzChhB,EAAS6B,SAAS,mBAAoB8e,GACtC3gB,EAAS6B,SAAS,gCAAiCsf,GACnDnhB,EAAS6B,SAAS,gCAAiCwf,GAE/ClqB,EAAU2pB,oBACVt2B,KAAKw0B,UAAUne,2BAA2Bb,EAAU7I,EAAU2pB,mBAAoB,uBAAwBx2B,WAAWsB,sBAAuB,4BAA6BtB,WAAWuB,gCAGpLsL,EAAU4pB,6BACVv2B,KAAKw0B,UAAUne,2BAA2Bb,EAAU7I,EAAU4pB,4BAA6B,gCAAiCz2B,WAAWwB,+BAAgC,qCAAsCxB,WAAWyB,wC,EAOpOgG,aAAautB,kBAAkBV,GAAgBG,GAAa,IAAI8B,0BAA0B9B,KClF1F,MAAMH,EAAgB,sB,MAkBT4C,oBAKTvvB,YAAY8sB,GAJHv0B,KAAIsC,KAAW8xB,EAKpBp0B,KAAKw0B,UAAYD,C,CAGrB3nB,qBAAqBnE,EAAkBC,GACnC,IAAIwD,EAAYlM,KAAKw0B,UAAUlsB,KAAK4D,UAChC1B,EAAWxK,KAAKw0B,UAAUlsB,KAAKkC,SAEnC,GAAI0B,GAAa1B,EAAU,CACvB,IAAI5B,EAAsC,GAiB1C,OAhBAsD,EAAUrD,SAAQ2M,I,MACd,IAAI7I,EAAuD,QAAnBa,EAAAgI,EAASH,kBAAU,IAAA7H,OAAA,EAAAA,EAAEwpB,oBAC7D,GAAIrqB,EAAW,CACX,GAAIA,EAAUsqB,kBAAmB,CAC7B,IAAI5sB,GAAO,EACPiC,EAAUtM,KAAKw0B,UAAUrqB,oBAAoBwC,EAAUsqB,kBAAmB5sB,EAAM5B,EAAUC,GAC9FE,EAASY,KAAK8C,EACjB,CACD,GAAIK,EAAUuqB,sBAAuB,CACjC,IAAI7sB,GAAO,EACPiC,EAAUtM,KAAKw0B,UAAUrqB,oBAAoBwC,EAAUuqB,sBAAuB7sB,EAAM5B,EAAUC,GAClGE,EAASY,KAAK8C,EACjB,CACJ,KAGEtC,QAAQC,IAAIrB,EACtB,CAEG,OAAOoB,QAAQE,S,CAGvBmO,2BAA2BlM,EAA4BqJ,G,MACnD,IAAI7I,EAAoCR,EAAakJ,WAAW2hB,oBAEhExhB,EAASmB,UAAUoB,eAAaof,cAAc,GAE9C,IAAIC,EAAmB,IAAItzB,UAAQ,EAAG,EAAG,GACrC6I,EAAUyqB,kBACVA,EAAiBlgB,UAAUvK,EAAUyqB,kBAEzC,IAAIC,EAAqD,QAA9B7pB,EAAAb,EAAU0qB,4BAAoB,IAAA7pB,IAAI,EAE7DgI,EAASsC,WAAW,qBAAsBsf,GAC1C5hB,EAAS6B,SAAS,mBAAoBggB,GAElC1qB,EAAUsqB,mBACVj3B,KAAKw0B,UAAUne,2BAA2Bb,EAAU7I,EAAUsqB,kBAAmB,sBAAuBn3B,WAAW0B,qBAAsB,2BAA4B1B,WAAW2B,+BAGhLkL,EAAUuqB,uBACVl3B,KAAKw0B,UAAUne,2BAA2Bb,EAAU7I,EAAUuqB,sBAAuB,0BAA2Bp3B,WAAW4B,yBAA0B,+BAAgC5B,WAAW6B,kC,EAO5M4F,aAAautB,kBAAkBV,GAAgBG,GAAa,IAAIyC,oBAAoBzC,KCnFpF,MAAMH,EAAgB,6B,MAaTkD,2BAKT7vB,YAAY8sB,GAJHv0B,KAAIsC,KAAW8xB,EAKpBp0B,KAAKw0B,UAAYD,C,CAGrB3nB,qBAAqBnE,EAAkBC,GACnC,IAAIwD,EAAYlM,KAAKw0B,UAAUlsB,KAAK4D,UAChC1B,EAAWxK,KAAKw0B,UAAUlsB,KAAKkC,SAEnC,GAAI0B,GAAa1B,EAAU,CACvB,IAAI5B,EAAsC,GAW1C,OAVAsD,EAAUrD,SAAQ2M,I,MACd,IAAI7I,EAA8D,QAAnBa,EAAAgI,EAASH,kBAAU,IAAA7H,OAAA,EAAAA,EAAE8pB,2BACpE,GAAI3qB,GACIA,EAAU4qB,oBAAqB,CAC/B,IAAIltB,GAAO,EACPiC,EAAUtM,KAAKw0B,UAAUrqB,oBAAoBwC,EAAU4qB,oBAAqBltB,EAAM5B,EAAUC,GAChGE,EAASY,KAAK8C,EACjB,CACJ,IAEEtC,QAAQC,IAAIrB,EACtB,CAEG,OAAOoB,QAAQE,S,CAIvBmO,2BAA2BlM,EAAiCqJ,G,MACxD,IAAI7I,EAA2CR,EAAakJ,WAAWiiB,2BAEnEE,EAAiD,QAA5BhqB,EAAAb,EAAU6qB,0BAAkB,IAAAhqB,IAAI,EACzDgI,EAASE,mBAAqBC,qBAAmB8hB,mBACjDjiB,EAASkiB,YAAc,IAEvBliB,EAASmB,UAAUoB,eAAa4f,qBAAqB,GAErDniB,EAAS6B,SAAS,uBAAwBmgB,GAEtC7qB,EAAU4qB,qBACVv3B,KAAKw0B,UAAUne,2BAA2Bb,EAAU7I,EAAU4qB,oBAAqB,wBAAyBz3B,WAAW8B,uBAAwB,6BAA8B9B,WAAW+B,gC,EAMpM0F,aAAautB,kBAAkBV,GAAgBG,GAAa,IAAI+C,2BAA2B/C,KC9D3F,MAAMH,EAAgB,uB,MAiBTwD,qBAKTnwB,YAAY8sB,GAJHv0B,KAAIsC,KAAW8xB,EAKpBp0B,KAAKw0B,UAAYD,C,CAGrB3nB,qBAAqBnE,EAAkBC,GACnC,IAAIwD,EAAYlM,KAAKw0B,UAAUlsB,KAAK4D,UAChC1B,EAAWxK,KAAKw0B,UAAUlsB,KAAKkC,SAEnC,GAAI0B,GAAa1B,EAAU,CACvB,IAAI5B,EAAsC,GAa1C,OAXAsD,EAAUrD,SAAQ2M,I,MACd,IAAI7I,EAAwD,QAAnBa,EAAAgI,EAASH,kBAAU,IAAA7H,OAAA,EAAAA,EAAEoqB,qBAC9D,GAAIjrB,GACIA,EAAUkrB,iBAAkB,CAC5B,IAAIxtB,GAAO,EACPiC,EAAUtM,KAAKw0B,UAAUrqB,oBAAoBwC,EAAUkrB,iBAAkBxtB,EAAM5B,EAAUC,GAC7FE,EAASY,KAAK8C,EACjB,CACJ,IAGEtC,QAAQC,IAAIrB,EACtB,CAEG,OAAOoB,QAAQE,S,CAIvBmO,2BAA2BlM,EAAiCqJ,G,QACxD,IAAI7I,EAAqCR,EAAakJ,WAAWuiB,qBAEjEpiB,EAASmB,UAAUoB,eAAa+f,kBAAkB,GAElD,IAAIC,EAA2C,QAAzBvqB,EAAAb,EAAUorB,uBAAe,IAAAvqB,IAAI,EAC/CwqB,EAAmD,QAA7BtpB,EAAA/B,EAAUqrB,2BAAmB,IAAAtpB,IAAI,MAE3D8G,EAAS6B,SAAS,0BAA2B0gB,GAC7CviB,EAAS6B,SAAS,8BAA+B2gB,GAEjD,IAAIC,EAAmB,IAAIn0B,UAAQ,EAAG,EAAG,GACrC6I,EAAUsrB,kBACVA,EAAiB/gB,UAAUvK,EAAUsrB,kBAGzCziB,EAASsC,WAAW,2BAA4BmgB,GAE5CtrB,EAAUkrB,kBACV73B,KAAKw0B,UAAUne,2BAA2Bb,EAAU7I,EAAUkrB,iBAAkB,2BAA4B/3B,WAAWgC,0BAA2B,gCAAiChC,WAAWiC,mC,EAM1MwF,aAAautB,kBAAkBV,GAAgBG,GAAa,IAAIqD,qBAAqBrD,KC5ErF,MAAMH,EAAgB,yB,MAiBT8D,uBAKTzwB,YAAY8sB,GAJHv0B,KAAIsC,KAAW8xB,EAKpBp0B,KAAKw0B,UAAYD,C,CAGrB3nB,qBAAqBnE,EAAkBC,GACnC,IAAIE,EAAsC,GAEtCsD,EAAYlM,KAAKw0B,UAAUlsB,KAAK4D,UAChC1B,EAAWxK,KAAKw0B,UAAUlsB,KAAKkC,SAmBnC,OAlBI0B,GAAa1B,GACb0B,EAAUrD,SAAQ2M,I,MACd,IAAI7I,EAA0D,QAAnBa,EAAAgI,EAASH,kBAAU,IAAA7H,OAAA,EAAAA,EAAE0qB,uBAChE,GAAIvrB,EAAW,CACX,GAAIA,EAAUwrB,gBAAiB,CAC3B,IAAI9tB,GAAO,EACPiC,EAAUtM,KAAKw0B,UAAUrqB,oBAAoBwC,EAAUwrB,gBAAiB9tB,EAAM5B,EAAUC,GAC5FE,EAASY,KAAK8C,EACjB,CACD,GAAIK,EAAUyrB,qBAAsB,CAChC,IAAI/tB,GAAO,EACPiC,EAAUtM,KAAKw0B,UAAUrqB,oBAAoBwC,EAAUyrB,qBAAsB/tB,EAAM5B,EAAUC,GACjGE,EAASY,KAAK8C,EACjB,CACJ,KAIFtC,QAAQC,IAAIrB,E,CAGvByP,2BAA2BlM,EAAiCqJ,G,MACxD,IAAI7I,EAAuCR,EAAakJ,WAAW6iB,uBAE/DG,EAAyC,QAAxB7qB,EAAAb,EAAU0rB,sBAAc,IAAA7qB,IAAI,EAC7C8qB,EAAsB,IAAIx0B,UAAQ,EAAK,EAAK,GAC5C6I,EAAU2rB,qBACVA,EAAoBphB,UAAUvK,EAAU2rB,qBAG5C9iB,EAASmB,UAAUzW,WAASC,gBAAgB,aAAa,GAEzDqV,EAAS6B,SAAS,mBAAoBghB,GACtC7iB,EAASsC,WAAW,wBAAyBwgB,GAEzC3rB,EAAUwrB,iBACVn4B,KAAKw0B,UAAUne,2BAA2Bb,EAAU7I,EAAUwrB,gBAAiB,0BAA2Br4B,WAAWkC,yBAA0B,+BAAgClC,WAAWmC,mCAG1L0K,EAAUyrB,sBACVp4B,KAAKw0B,UAAUne,2BAA2Bb,EAAU7I,EAAUyrB,qBAAsB,yBAA0Bt4B,WAAWoC,wBAAyB,8BAA+BpC,WAAWqC,iC,EAMxMoF,aAAautB,kBAAkBV,GAAgBG,GAAa,IAAI2D,uBAAuB3D,KCjFvF,MAAMH,EAAgB,sB,MAMTmE,oBAMT9wB,YAAY8sB,GAJHv0B,KAAIsC,KAAW8xB,EAKpBp0B,KAAKw0B,UAAYD,C,CAGrBvnB,eAAeb,GACX,IAAIqsB,EAAQ,IAAIC,gBAEZrsB,EAAuBD,EAAaC,qBACxC,GAAIA,EAAsB,CACtB,GAAIA,EAAqB4K,gBAAiB,CACtC,IAAIoI,EAAQoZ,EAAME,YAClBtZ,EAAMlI,UAAU9K,EAAqB4K,iBACrCoI,EAAMuZ,QAAQvZ,GACdoZ,EAAME,YAActZ,CACvB,CAEGhT,EAAqBC,mBACrBmsB,EAAMI,cAAgB54B,KAAKw0B,UAAUzf,mBAAmB3I,EAAqBC,kBAEpF,CAID,OAFArM,KAAKw0B,UAAUjf,yBAAyBpJ,EAAcqsB,GAE/CA,C,EAIfjxB,aAAautB,kBAAkBV,GAAgBG,GAAa,IAAIgE,oBAAoBhE,KCrBpF5jB,SAAOkoB,eAAe,CAAC,QATvB,MACInoB,KAAKooB,GACD,OAAOA,EAAKpvB,OAAOC,MAAMmvB,EAAKtoB,IAAK,OAAQsoB,EAAKpwB,SAASoB,eAAe,IAAMgvB,EAAKC,SAAShvB,MAAMzB,IAC9F,IAAI0wB,EAAO,IAAIzxB,aACf,OAAOyxB,EAAKnrB,OAAOvF,EAAMwwB,EAAKtoB,IAAKsoB,EAAKpwB,UAAUqB,MAAK,IAAMivB,GAAK,G,IAgB9EroB,SAAOkoB,eAAe,CAAC,OATvB,MACInoB,KAAKooB,GACD,OAAOA,EAAKpvB,OAAOC,MAAMmvB,EAAKtoB,IAAK,cAAesoB,EAAKpwB,SAASoB,eAAe,IAAMgvB,EAAKC,SAAShvB,MAAMzB,IACrG,IAAI0wB,EAAO,IAAIzxB,aACf,OAAOyxB,EAAKnqB,UAAUvG,EAAMwwB,EAAKtoB,IAAKsoB,EAAKpwB,UAAUqB,MAAK,IAAMivB,GAAK,G"}