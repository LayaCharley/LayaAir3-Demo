!function(e,r){"use strict";class glTFShader{static init(){this.Define_BaseColorMap=r.Shader3D.getDefineByName("BASECOLORMAP"),this.Define_BaseColorMapTransform=r.Shader3D.getDefineByName("BASECOLORMAP_TRANSFORM"),this.Define_MetallicRoughnessMap=r.Shader3D.getDefineByName("METALLICROUGHNESSMAP"),this.Define_MetallicRoughnessMapTransform=r.Shader3D.getDefineByName("METALLICROUGHNESSMAP_TRANSFORM"),this.Define_NormalMap=r.Shader3D.getDefineByName("NORMALMAP"),this.Define_NormalMapTransform=r.Shader3D.getDefineByName("NORMALMAP_TRANSFORM"),this.Define_OcclusionMap=r.Shader3D.getDefineByName("OCCLUSIONMAP"),this.Define_OcclusionMapTransform=r.Shader3D.getDefineByName("OCCLUSIONMAP_TRANSFORM"),this.Define_EmissionMap=r.Shader3D.getDefineByName("EMISSIONMAP"),this.Define_EmissionMapTransform=r.Shader3D.getDefineByName("EMISSIONMAP_TRANSFORM"),this.Define_ClearCoatMap=r.Shader3D.getDefineByName("CLEARCOATMAP"),this.Define_ClearCoatMapTransform=r.Shader3D.getDefineByName("CLEARCOATMAP_TRANSFORM"),this.Define_ClearCoatRoughnessMap=r.Shader3D.getDefineByName("CLEARCOAT_ROUGHNESSMAP"),this.Define_ClearCoatRoughnessMapTransform=r.Shader3D.getDefineByName("CLEARCOAT_ROUGHNESSMAP_TRANSFORM"),this.Define_ClearCoatNormalMapTransform=r.Shader3D.getDefineByName("CLEARCOAT_NORMALMAP_TRANSFORM"),this.Define_AnisotropyMap=r.Shader3D.getDefineByName("ANISOTROPYMAP"),this.Define_AnisotropyMapTransform=r.Shader3D.getDefineByName("ANISOTROPYMAP_TRANSFORM"),this.Define_IridescenceMap=r.Shader3D.getDefineByName("IRIDESCENCEMAP"),this.Define_IridescenceMapTransform=r.Shader3D.getDefineByName("IRIDESCENCEMAP_TRANSFORM"),this.Define_IridescenceThicknessMap=r.Shader3D.getDefineByName("IRIDESCENCE_THICKNESSMAP"),this.Define_IridescenceThicknessMapTransform=r.Shader3D.getDefineByName("IRIDESCENCE_THICKNESSMAP_TRANSFORM"),this.Define_SheenColorMap=r.Shader3D.getDefineByName("SHEENCOLORMAP"),this.Define_SheenColorMapTransform=r.Shader3D.getDefineByName("SHEENCOLORMAP_TRANSFORM"),this.Define_SheenRoughnessMap=r.Shader3D.getDefineByName("SHEEN_ROUGHNESSMAP"),this.Define_SheenRoughnessMapTransform=r.Shader3D.getDefineByName("SHEEN_ROUGHNESSMAP_TRANSFORM"),this.Define_TransmissionMap=r.Shader3D.getDefineByName("TRANSMISSIONMAP"),this.Define_TransmissionMapTransform=r.Shader3D.getDefineByName("TRANSMISSIONMAP_TRANSFORM"),this.Define_VolumeThicknessMap=r.Shader3D.getDefineByName("THICKNESSMAP"),this.Define_VolumeThicknessMapTransform=r.Shader3D.getDefineByName("THICKNESSMAP_TRANSFORM"),this.Define_SpecularFactorMap=r.Shader3D.getDefineByName("SPECULARFACTORMAP"),this.Define_SpecularFactorMapTransform=r.Shader3D.getDefineByName("SPECULARFACTORMAP_TRANSFORM"),this.Define_SpecularColorMap=r.Shader3D.getDefineByName("SPECULARCOLORMAP"),this.Define_SpecularColorMapTransform=r.Shader3D.getDefineByName("SPECULARCOLORMAP_TRANSFORM");let e=r.Shader3D.find(glTFShader.name);if(e)return;r.Shader3D.addInclude("glTFMetallicRoughness.glsl",'#if !defined(glTFMetallicRoughness_lib)\r\n    #define glTFMetallicRoughness_lib\r\n\r\n    #include "ShadingFrag.glsl";\r\n\r\n    #include "PBRFrag.glsl";\r\n\r\nstruct SurfaceInputs {\r\n    vec3 diffuseColor;\r\n    float alpha;\r\n    float alphaTest;\r\n    float metallic;\r\n    float roughness;\r\n    float occlusion;\r\n    vec3 emissionColor;\r\n    vec3 normalTS;\r\n    float specular;\r\n\r\n    // specular\r\n    float specularFactor;\r\n    vec3 specularColor;\r\n\r\n    #ifdef CLEARCOAT\r\n    float clearCoat;\r\n    float clearCoatRoughness;\r\n\t#ifdef CLEARCOAT_NORMAL\r\n    vec3 clearCoatNormalTS;\r\n\t#endif // CLEARCOAT_NORMAL\r\n    #endif // CLEARCOAT\r\n\r\n    #ifdef ANISOTROPIC\r\n    float anisotropy;\r\n    vec2 anisotropyDirection;\r\n    #endif // ANISOTROPIC\r\n\r\n    #ifdef IOR\r\n    float ior;\r\n    #endif // IOR\r\n\r\n    #ifdef IRIDESCENCE\r\n    float iridescence;\r\n    float iridescenceIor;\r\n    float iridescenceThickness;\r\n    #endif // IRIDESCENCE\r\n\r\n    #ifdef SHEEN\r\n    vec3 sheenColor;\r\n    float sheenRoughness;\r\n    #endif // SHEEN\r\n\r\n    #ifdef TRANSMISSION\r\n    float transmission;\r\n    #endif // TRANSMISSION\r\n\r\n    #ifdef THICKNESS\r\n    float thickness;\r\n    vec3 attenuationColor;\r\n    float attenuationDistance;\r\n    #endif // THICKNESS\r\n};\r\n\r\nvoid initSurface(inout Surface surface, const in SurfaceInputs inputs, const in PixelParams pixel)\r\n{\r\n    surface.alpha = inputs.alpha;\r\n\r\n    surface.normalTS = inputs.normalTS;\r\n\r\n    vec3 baseColor = inputs.diffuseColor;\r\n    float metallic = inputs.metallic;\r\n    float perceptualRoughness = inputs.roughness;\r\n\r\n    #ifdef IOR\r\n    float ior = inputs.ior;\r\n    surface.ior = ior;\r\n    vec3 f0 = vec3(dielectricIorToF0(ior));\r\n    #else // IOR\r\n    vec3 f0 = vec3(dielectricSpecularToF0(inputs.specular));\r\n    surface.ior = dielectricF0ToIor(f0.x);\r\n    #endif // IOR\r\n\r\n    // KHR_materials_specular\r\n    f0 *= inputs.specularFactor * inputs.specularColor;\r\n\r\n    surface.perceptualRoughness = max(perceptualRoughness, MIN_PERCEPTUAL_ROUGHNESS);\r\n    surface.roughness = surface.perceptualRoughness * surface.perceptualRoughness;\r\n    surface.diffuseColor = computeDiffuse(baseColor, metallic);\r\n    surface.f0 = computeF0(f0, baseColor, metallic);\r\n    surface.f90 = computeF90(surface.f0);\r\n\r\n    surface.occlusion = inputs.occlusion;\r\n\r\n    #ifdef EMISSION\r\n    surface.emissionColor = inputs.emissionColor;\r\n    #endif // EMISSION\r\n\r\n    #ifdef IRIDESCENCE\r\n    surface.iridescence = inputs.iridescence;\r\n    surface.iridescenceIor = inputs.iridescenceIor;\r\n    surface.iridescenceThickness = inputs.iridescenceThickness;\r\n    #endif // IRIDESCENCE\r\n\r\n    #ifdef SHEEN\r\n    surface.sheenColor = inputs.sheenColor;\r\n    surface.sheenPerceptualRoughness = max(inputs.sheenRoughness, MIN_PERCEPTUAL_ROUGHNESS);\r\n    surface.sheenRoughness = pow2(surface.sheenPerceptualRoughness);\r\n    #endif // SHEEN\r\n\r\n    #ifdef CLEARCOAT\r\n    surface.clearCoat = inputs.clearCoat;\r\n    surface.clearCoatPerceptualRoughness = clamp(inputs.clearCoatRoughness, MIN_PERCEPTUAL_ROUGHNESS, 1.0);\r\n    surface.clearCoatRoughness = surface.clearCoatPerceptualRoughness * surface.clearCoatPerceptualRoughness;\r\n\t#ifdef CLEARCOAT_NORMAL\r\n    surface.clearCoatNormalTS = inputs.clearCoatNormalTS;\r\n\t#endif // CLEARCOAT_NORMAL\r\n    #endif // CLEARCOAT\r\n\r\n    #ifdef ANISOTROPIC\r\n    surface.anisotropy = inputs.anisotropy;\r\n    surface.anisotropyDirection = inputs.anisotropyDirection;\r\n    #endif // ANISOTROPIC\r\n\r\n    #ifdef TRANSMISSION\r\n    surface.transmission = inputs.transmission;\r\n    #endif // TRANSMISSION\r\n\r\n    #ifdef THICKNESS\r\n    surface.thickness = inputs.thickness;\r\n    surface.attenuationColor = inputs.attenuationColor;\r\n    surface.attenuationDistance = inputs.attenuationDistance;\r\n    #endif // THICKNESS\r\n}\r\n\r\nvec4 glTFMetallicRoughness(const in SurfaceInputs inputs, in PixelParams pixel)\r\n{\r\n    #ifdef ALPHATEST\r\n    if (inputs.alpha < inputs.alphaTest)\r\n\t{\r\n\t    discard;\r\n\t}\r\n    #endif // ALPHATEST\r\n\r\n    Surface surface;\r\n    initSurface(surface, inputs, pixel);\r\n\r\n    PixelInfo info;\r\n    getPixelInfo(info, pixel, surface);\r\n\r\n    vec3 surfaceColor = vec3(0.0);\r\n    surfaceColor += PBRLighting(surface, info);\r\n\r\n    return vec4(surfaceColor, surface.alpha);\r\n}\r\n\r\n#endif // glTFMetallicRoughness_lib');let t={u_AlphaTestValue:r.ShaderDataType.Float,u_BaseColorFactor:r.ShaderDataType.Vector4,u_BaseColorTexture:r.ShaderDataType.Texture2D,u_BaseColorMapTransform:r.ShaderDataType.Matrix3x3,u_Specular:r.ShaderDataType.Float,u_MetallicFactor:r.ShaderDataType.Float,u_RoughnessFactor:r.ShaderDataType.Float,u_MetallicRoughnessTexture:r.ShaderDataType.Texture2D,u_MetallicRoughnessMapTransform:r.ShaderDataType.Matrix3x3,u_NormalTexture:r.ShaderDataType.Texture2D,u_NormalMapTransform:r.ShaderDataType.Matrix3x3,u_NormalScale:r.ShaderDataType.Float,u_OcclusionTexture:r.ShaderDataType.Texture2D,u_OcclusionMapTransform:r.ShaderDataType.Matrix3x3,u_OcclusionStrength:r.ShaderDataType.Float,u_EmissionFactor:r.ShaderDataType.Vector3,u_EmissionTexture:r.ShaderDataType.Texture2D,u_EmissionMapTransform:r.ShaderDataType.Matrix3x3,u_EmissionStrength:r.ShaderDataType.Float,u_ClearCoatFactor:r.ShaderDataType.Float,u_ClearCoatTexture:r.ShaderDataType.Texture2D,u_ClearCoatMapTransform:r.ShaderDataType.Matrix3x3,u_ClearCoatRoughness:r.ShaderDataType.Float,u_ClearCoatRoughnessTexture:r.ShaderDataType.Texture2D,u_ClearCoatRoughnessMapTransform:r.ShaderDataType.Matrix3x3,u_ClearCoatNormalTexture:r.ShaderDataType.Texture2D,u_ClearCoatNormalMapTransform:r.ShaderDataType.Matrix3x3,u_ClearCoatNormalScale:r.ShaderDataType.Float,u_AnisotropyStrength:r.ShaderDataType.Float,u_AnisotropyRotation:r.ShaderDataType.Float,u_AnisotropyTexture:r.ShaderDataType.Texture2D,u_AnisotropyMapTransform:r.ShaderDataType.Matrix3x3,u_Ior:r.ShaderDataType.Float,u_IridescenceFactor:r.ShaderDataType.Float,u_IridescenceTexture:r.ShaderDataType.Texture2D,u_IridescenceMapTransform:r.ShaderDataType.Matrix3x3,u_IridescenceIor:r.ShaderDataType.Float,u_IridescenceThicknessMinimum:r.ShaderDataType.Float,u_IridescenceThicknessMaximum:r.ShaderDataType.Float,u_IridescenceThicknessTexture:r.ShaderDataType.Texture2D,u_IridescenceThicknessMapTransform:r.ShaderDataType.Matrix3x3,u_SheenColorFactor:r.ShaderDataType.Vector3,u_SheenColorTexture:r.ShaderDataType.Texture2D,u_SheenColorMapTransform:r.ShaderDataType.Matrix3x3,u_SheenRoughness:r.ShaderDataType.Float,u_SheenRoughnessTexture:r.ShaderDataType.Texture2D,u_SheenRoughnessMapTransform:r.ShaderDataType.Matrix3x3,u_TransmissionFactor:r.ShaderDataType.Float,u_TransmissionTexture:r.ShaderDataType.Texture2D,u_TransmissionMapTransform:r.ShaderDataType.Matrix3x3,u_VolumeThicknessFactor:r.ShaderDataType.Float,u_VolumeThicknessTexture:r.ShaderDataType.Texture2D,u_VoluemThicknessMapTransform:r.ShaderDataType.Matrix3x3,u_VolumeAttenuationDistance:r.ShaderDataType.Float,u_VolumeAttenuationColor:r.ShaderDataType.Vector3,u_SpecularFactor:r.ShaderDataType.Float,u_SpecularFactorTexture:r.ShaderDataType.Texture2D,u_SpecularFactorMapTransfrom:r.ShaderDataType.Matrix3x3,u_SpecularColorFactor:r.ShaderDataType.Vector3,u_SpecularColorTexture:r.ShaderDataType.Texture2D,u_SpecularColorMapTransform:r.ShaderDataType.Matrix3x3},n={u_AlphaTestValue:.5,u_BaseColorFactor:r.Vector4.ONE,u_BaseColorMapTransform:r.Matrix3x3.DEFAULT,u_Specular:.5,u_MetallicFactor:1,u_RoughnessFactor:1,u_MetallicRoughnessMapTransform:r.Matrix3x3.DEFAULT,u_NormalMapTransform:r.Matrix3x3.DEFAULT,u_NormalScale:1,u_OcclusionMapTransform:r.Matrix3x3.DEFAULT,u_OcclusionStrength:1,u_EmissionFactor:r.Vector3.ZERO,u_EmissionMapTransform:r.Matrix3x3.DEFAULT,u_EmissionStrength:1,u_SpecularFactor:1,u_SpecularFactorMapTransfrom:r.Matrix3x3.DEFAULT,u_SpecularColorFactor:r.Vector3.ONE,u_SpecularColorMapTransform:r.Matrix3x3.DEFAULT,u_Ior:1.5,u_ClearCoatFactor:0,u_ClearCoatMapTransform:r.Matrix3x3.DEFAULT,u_ClearCoatRoughness:0,u_ClearCoatRoughnessMapTransform:r.Matrix3x3.DEFAULT,u_ClearCoatNormalMapTransform:r.Matrix3x3.DEFAULT,u_ClearCoatNormalScale:1,u_AnisotropyStrength:0,u_AnisotropyRotation:0,u_AnisotropyMapTransform:r.Matrix3x3.DEFAULT,u_IridescenceFactor:0,u_IridescenceMapTransform:r.Matrix3x3.DEFAULT,u_IridescenceIor:1.33,u_IridescenceThicknessMinimum:100,u_IridescenceThicknessMaximum:400,u_IridescenceThicknessMapTransform:r.Matrix3x3.DEFAULT,u_SheenColorFactor:r.Vector3.ZERO,u_SheenColorMapTransform:r.Matrix3x3.DEFAULT,u_SheenRoughness:0,u_SheenRoughnessMapTransform:r.Matrix3x3.DEFAULT,u_TransmissionFactor:0,u_TransmissionMapTransform:r.Matrix3x3.DEFAULT};e=r.Shader3D.add("glTFPBR",!0,!0);let a=new r.SubShader(r.SubShader.DefaultAttributeMap,t,n);e.addSubShader(a),a.addShaderPass('#define SHADER_NAME glTFPBRVS\r\n\r\n#include "Math.glsl";\r\n\r\n#include "Scene.glsl";\r\n#include "SceneFogInput.glsl";\r\n\r\n#include "Camera.glsl";\r\n#include "Sprite3DVertex.glsl";\r\n\r\n#include "VertexCommon.glsl";\r\n\r\n#include "PBRVertex.glsl";\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    PixelParams pixel;\r\n    initPixelParams(pixel, vertex);\r\n\r\n    gl_Position = getPositionCS(pixel.positionWS);\r\n\r\n    gl_Position = remapPositionZ(gl_Position);\r\n\r\n#ifdef FOG\r\n    FogHandle(gl_Position.z);\r\n#endif\r\n}','#define SHADER_NAME glTFPBRFS\r\n\r\n#include "Color.glsl";\r\n\r\n#include "Scene.glsl";\r\n#include "SceneFog.glsl";\r\n\r\n#include "Camera.glsl";\r\n#include "Sprite3DFrag.glsl";\r\n\r\n#include "glTFMetallicRoughness.glsl";\r\n\r\nvoid initSurfaceInputs(inout SurfaceInputs inputs, const in PixelParams pixel)\r\n{\r\n    vec2 uv = vec2(0.0);\r\n#ifdef UV\r\n    uv = pixel.uv0;\r\n#endif //\r\n\r\n    // render state\r\n    inputs.alphaTest = u_AlphaTestValue;\r\n\r\n    // surface\r\n    inputs.diffuseColor = u_BaseColorFactor.xyz;\r\n    inputs.alpha = u_BaseColorFactor.w;\r\n\r\n#ifdef COLOR\r\n    #ifdef ENABLEVERTEXCOLOR\r\n    inputs.diffuseColor *= pixel.vertexColor.xyz;\r\n    inputs.alpha *= pixel.vertexColor.a;\r\n    #endif // ENABLEVERTEXCOLOR\r\n#endif // COLOR\r\n\r\n#ifdef BASECOLORMAP\r\n    vec2 baseColorUV = uv;\r\n    #ifdef BASECOLORMAP_TRANSFORM\r\n    baseColorUV = (u_BaseColorMapTransform * vec3(baseColorUV, 1.0)).xy;\r\n    #endif // BASECOLORMAP_TRANSFORM\r\n    vec4 baseColorSampler = texture2D(u_BaseColorTexture, baseColorUV);\r\n    #ifdef Gamma_u_BaseColorTexture\r\n    baseColorSampler = gammaToLinear(baseColorSampler);\r\n    #endif // u_BaseColorTexture_Gamma\r\n    inputs.diffuseColor *= baseColorSampler.rgb;\r\n    inputs.alpha *= baseColorSampler.a;\r\n#endif // BASECOLORMAP\r\n\r\n    inputs.specular = u_Specular;\r\n\r\n    inputs.specularFactor = 1.0;\r\n    inputs.specularColor = vec3(1.0);\r\n\r\n    inputs.specularFactor = u_SpecularFactor;\r\n#ifdef SPECULARFACTORMAP\r\n    vec2 specularFactorUV = uv;\r\n    #ifdef SPECULARFACTORMAP_TRANSFORM\r\n    specularFactorUV = (u_SpecularFactorMapTransfrom * specularFactorUV).xy;\r\n    #endif // SPECULARFACTORMAP_TRANSFORM\r\n    vec4 specularFactorSampler = texture2D(u_SpecularFactorTexture, specularFactorUV);\r\n    inputs.specularFactor *= specularFactorSampler.a;\r\n#endif // SPECULARFACTORMAP\r\n\r\n    inputs.specularColor = u_SpecularColorFactor;\r\n#ifdef SPECULARCOLORMAP\r\n    vec2 specularColorUV = uv;\r\n    #ifdef SPECULARFACTORMAP_TRANSFORM\r\n    specularColorUV = (u_SpecularColorMapTransform * specularColorUV).xy;\r\n    #endif // SPECULARFACTORMAP_TRANSFORM\r\n    vec4 specularColorSampler = texture2D(u_SpecularColorTexture, specularColorUV);\r\n    #ifdef Gamma_u_SpecularColorTexture\r\n    specularColorSampler = gammaToLinear(specularColorSampler);\r\n    #endif // Gamma_u_SpecularColorTexture\r\n    inputs.specularColor *= specularColorSampler.rgb;\r\n#endif // SPECULARCOLORMAP\r\n\r\n    inputs.metallic = u_MetallicFactor;\r\n    float roughness = u_RoughnessFactor;\r\n#ifdef METALLICROUGHNESSMAP\r\n    vec2 metallicUV = uv;\r\n    #ifdef METALLICROUGHNESSMAP_TRANSFORM\r\n    metallicUV = (u_MetallicRoughnessMapTransform * vec3(metallicUV, 1.0)).xy;\r\n    #endif METALLICROUGHNESSMAP_TRANSFORM\r\n    vec4 metallicRoughnessSampler = texture2D(u_MetallicRoughnessTexture, metallicUV);\r\n    inputs.metallic *= metallicRoughnessSampler.b;\r\n    roughness *= metallicRoughnessSampler.g;\r\n#endif // METALLICROUGHNESSMAP\r\n    inputs.roughness = roughness;\r\n\r\n    float occlusion = 1.0;\r\n#ifdef OCCLUSIONMAP\r\n    vec2 occlusionUV = uv;\r\n    #ifdef OCCLUSIONMAP_TRANSFORM\r\n    occlusionUV = (u_OcclusionMapTransform * vec3(occlusionUV, 1.0)).xy;\r\n    #endif // OCCLUSIONMAP_TRANSFORM\r\n    vec4 occlusionSampler = texture2D(u_OcclusionTexture, occlusionUV);\r\n    #ifdef Gamma_u_OcclusionTexture\r\n    occlusionSampler = gammaToLinear(occlusionSampler);\r\n    #endif // Gamma_u_OcclusionTexture\r\n    occlusion = occlusionSampler.r;\r\n#endif // OCCLUSIONMAP\r\n    inputs.occlusion = (1.0 - u_OcclusionStrength) + occlusion * u_OcclusionStrength;\r\n\r\n    inputs.emissionColor = u_EmissionFactor * u_EmissionStrength;\r\n#ifdef EMISSIONMAP\r\n    vec2 emissionUV = uv;\r\n    #ifdef EMISSIONMAP_TRANSFORM\r\n    emissionUV = (u_EmissionMapTransform * vec3(emissionUV, 1.0)).xy;\r\n    #endif // EMISSIONMAP_TRANSFORM\r\n    vec4 emissionSampler = texture2D(u_EmissionTexture, emissionUV);\r\n    #ifdef Gamma_u_EmissionTexture\r\n    emissionSampler = gammaToLinear(emissionSampler);\r\n    #endif // Gamma_u_EmissionTexture\r\n    inputs.emissionColor *= emissionSampler.rgb;\r\n#endif // EMISSIONMAP\r\n\r\n    inputs.normalTS = vec3(0.0, 0.0, 1.0);\r\n#ifdef NORMALMAP\r\n    vec2 normalUV = uv;\r\n    #ifdef NORMALMAP_TRANSFORM\r\n    normalUV = (u_NormalMapTransform * vec3(normalUV, 1.0)).xy;\r\n    #endif // NORMALMAP_TRANSFORM\r\n    vec3 normalSampler = texture2D(u_NormalTexture, normalUV).xyz;\r\n    normalSampler = normalize(normalSampler * 2.0 - 1.0);\r\n    normalSampler.y *= -1.0;\r\n    inputs.normalTS = normalScale(normalSampler, u_NormalScale);\r\n#endif // NORMALMAP\r\n\r\n#ifdef IOR\r\n    inputs.ior = u_Ior;\r\n#endif // IOR\r\n\r\n#ifdef IRIDESCENCE\r\n    float iridescenceFactor = u_IridescenceFactor;\r\n    #ifdef IRIDESCENCEMAP\r\n    vec2 iridescenceUV = uv;\r\n\t#ifdef IRIDESCENCEMAP_TRANSFORM\r\n    iridescenceUV = (u_IridescenceMapTransform * vec3(iridescenceUV, 1.0)).xy;\r\n\t#endif // IRIDESCENCEMAP_TRANSFORM\r\n    vec4 iridescenceSampler = texture2D(u_IridescenceTexture, iridescenceUV);\r\n    iridescenceFactor *= iridescenceSampler.r;\r\n    #endif // IRIDESCENCEMAP\r\n    float iridescenceThickness = u_IridescenceThicknessMaximum;\r\n    #ifdef IRIDESCENCE_THICKNESSMAP\r\n    vec2 iridescenceThicknessUV = uv;\r\n\t#ifdef IRIDESCENCE_THICKNESSMAP_TRANSFORM\r\n    iridescenceThicknessUV = (u_IridescenceThicknessMapTransform, vec3(iridescenceThicknessUV, 1.0)).xy;\r\n\t#endif // IRIDESCENCE_THICKNESSMAP_TRANSFORM\r\n    vec4 iridescenceThicknessSampler = texture2D(u_IridescenceThicknessTexture, iridescenceThicknessUV);\r\n    iridescenceThickness = mix(u_IridescenceThicknessMinimum, u_IridescenceThicknessMaximum, iridescenceThicknessSampler.g);\r\n    #endif // IRIDESCENCE_THICKNESSMAP\r\n    inputs.iridescence = iridescenceFactor;\r\n    inputs.iridescenceIor = u_IridescenceIor;\r\n    inputs.iridescenceThickness = iridescenceThickness;\r\n#endif // IRIDESCENCE\r\n\r\n#ifdef SHEEN\r\n    vec3 sheenColor = u_SheenColorFactor;\r\n    #ifdef SHEENCOLORMAP\r\n    vec2 sheenColorUV = uv;\r\n\t#ifdef SHEENCOLORMAP_TRANSFORM\r\n    sheenColorUV = (u_SheenColorMapTransform * vec3(sheenColorUV, 1.0)).xy;\r\n\t#endif // SHEENCOLORMAP_TRANSFORM\r\n    vec4 sheenColorSampler = texture2D(u_SheenColorTexture, sheenColorUV);\r\n\t#ifdef Gamma_u_SheenColorFactor\r\n    sheenColorSampler = gammaToLinear(sheenColorSampler);\r\n\t#endif // Gamma_u_SheenColorFactor\r\n    sheenColor *= sheenColorSampler.rgb;\r\n    #endif // SHEENCOLORMAP\r\n\r\n    float sheenRoughness = u_SheenRoughness;\r\n    #ifdef SHEEN_ROUGHNESSMAP\r\n    vec2 sheenRoughnessUV = uv;\r\n\t#ifdef SHEEN_ROUGHNESSMAP_TRANSFORM\r\n    sheenRoughnessUV = (u_SheenRoughnessMapTransform * vec3(sheenRoughnessUV, 1.0)).xy;\r\n\t#endif // SHEEN_ROUGHNESSMAP_TRANSFORM\r\n    vec4 sheenRoughnessSampler = texture2D(u_SheenRoughnessTexture, sheenRoughnessUV);\r\n    sheenRoughness *= sheenRoughnessSampler.a;\r\n    #endif // SHEEN_ROUGHNESSMAP\r\n\r\n    inputs.sheenColor = sheenColor;\r\n    inputs.sheenRoughness = sheenRoughness;\r\n#endif // SHEEN\r\n\r\n#ifdef CLEARCOAT\r\n    inputs.clearCoat = u_ClearCoatFactor;\r\n    inputs.clearCoatRoughness = u_ClearCoatRoughness;\r\n\r\n    #ifdef CLEARCOATMAP\r\n    vec2 clearCoatUV = uv;\r\n\t#ifdef CLEARCOATMAP_TRANSFORM\r\n    clearCoatUV = (u_ClearCoatMapTransform * vec3(clearCoatUV, 1.0)).xy;\r\n\t#endif // CLEARCOATMAP_TRANSFORM\r\n    vec4 clearCoatSampler = texture2D(u_ClearCoatTexture, clearCoatUV);\r\n    inputs.clearCoat *= clearCoatSampler.r;\r\n    #endif // CLEARCOATMAP\r\n\r\n    #ifdef CLEARCOAT_ROUGHNESSMAP\r\n    vec2 clearCoatRoughnessUV = uv;\r\n\t#ifdef CLEARCOAT_ROUGHNESSMAP_TRANSFORM\r\n    clearCoatRoughnessUV = (u_ClearCoatRoughnessMapTransform * vec3(uv, 1.0)).xy;\r\n\t#endif // CLEARCOAT_ROUGHNESSMAP_TRANSFORM\r\n    vec4 clearcoatSampleRoughness = texture2D(u_ClearCoatRoughnessTexture, clearCoatRoughnessUV);\r\n    inputs.clearCoatRoughness *= clearcoatSampleRoughness.g;\r\n    #endif // CLEARCOAT_ROUGHNESSMAP\r\n\r\n    #ifdef CLEARCOAT_NORMAL\r\n    vec2 clearCoatNormalUV = uv;\r\n\t#ifdef CLEARCOAT_NORMALMAP_TRANSFORM\r\n    clearCoatNormalUV = (u_ClearCoatNormalMapTransform * vec3(clearCoatNormalUV, 1.0)).xy;\r\n\t#endif // CLEARCOAT_NORMALMAP_TRANSFORM\r\n    vec3 clearCoatNormalSampler = texture2D(u_ClearCoatNormalTexture, clearCoatNormalUV).rgb;\r\n    clearCoatNormalSampler = normalize(clearCoatNormalSampler * 2.0 - 1.0);\r\n    clearCoatNormalSampler.y *= -1.0;\r\n    // todo scale\r\n    inputs.clearCoatNormalTS = normalScale(clearCoatNormalSampler, u_ClearCoatNormalScale);\r\n    #endif // CLEARCOAT_NORMAL\r\n#endif // CLEARCOAT\r\n\r\n#ifdef ANISOTROPIC\r\n    inputs.anisotropy = u_AnisotropyStrength;\r\n    vec2 direction = vec2(1.0, 0.0);\r\n\r\n    #ifdef ANISOTROPYMAP\r\n    vec2 anisotropyUV = uv;\r\n\t#ifdef ANISOTROPYMAP_TRANSFORM\r\n    anisotropyUV = (u_AnisotropyMapTransform * vec3(anisotropyUV, 1.0)).xy;\r\n\t#endif // ANISOTROPYMAP_TRANSFORM\r\n    vec3 anisotropySampler = texture2D(u_AnisotropyTexture, anisotropyUV).rgb;\r\n\r\n    inputs.anisotropy *= anisotropySampler.b;\r\n    direction = anisotropySampler.xy * 2.0 - 1.0;\r\n    #endif // ANISOTROPYMAP\r\n\r\n    vec2 anisotropyRotation = vec2(cos(u_AnisotropyRotation), sin(u_AnisotropyRotation));\r\n    mat2 rotationMatrix = mat2(anisotropyRotation.x, anisotropyRotation.y, -anisotropyRotation.y, anisotropyRotation.x);\r\n    inputs.anisotropyDirection = rotationMatrix * direction;\r\n\r\n#endif // ANISOTROPIC\r\n\r\n#ifdef TRANSMISSION\r\n    float transmission = u_TransmissionFactor;\r\n    #ifdef TRANSMISSIONMAP\r\n    vec2 transmissionUV = uv;\r\n\t#ifdef TRANSMISSIONMAP_TRANSFORM\r\n    transmissionUV = (u_TransmissionMapTransform * vec3(transmissionUV, 1.0)).xy;\r\n\t#endif // TRANSMISSIONMAP_TRANSFORM\r\n    vec4 transmissionSampler = texture2D(u_TransmissionTexture, transmissionUV);\r\n    transmission *= transmissionSampler.r;\r\n    #endif // TRANSMISSIONMAP\r\n    inputs.transmission = transmission;\r\n#endif // TRANSMISSION\r\n\r\n#ifdef THICKNESS\r\n\r\n    float thicknessFactor = u_VolumeThicknessFactor;\r\n    float attenuationDistance = u_VolumeAttenuationDistance;\r\n    vec3 attenuationColor = u_VolumeAttenuationColor.xyz;\r\n\r\n    #ifdef THICKNESSMAP\r\n    vec2 thicknessUV = uv;\r\n\t#ifdef THICKNESSMAP_TRANSFORM\r\n    thicknessUV = (u_VoluemThicknessMapTransform * vec3(thicknessUV, 1.0)).xy;\r\n\t#endif // THICKNESSMAP_TRANSFORM\r\n    vec4 thicknessSampler = texture2D(u_VolumeThicknessTexture, thicknessUV);\r\n    thicknessFactor *= thicknessSampler.g;\r\n    #endif // THICKNESSMAP\r\n\r\n    inputs.thickness = thicknessFactor;\r\n    inputs.attenuationColor = attenuationColor;\r\n    inputs.attenuationDistance = attenuationDistance;\r\n\r\n#endif // THICKNESS\r\n}\r\n\r\nvoid main()\r\n{\r\n\r\n#ifndef DEBUG\r\n    PixelParams pixel;\r\n    getPixelParams(pixel);\r\n\r\n    SurfaceInputs inputs;\r\n    initSurfaceInputs(inputs, pixel);\r\n\r\n    vec4 surfaceColor = glTFMetallicRoughness(inputs, pixel);\r\n\r\n    #ifdef FOG\r\n    surfaceColor.rgb = sceneLitFog(surfaceColor.rgb);\r\n    #endif // FOG\r\n\r\n    gl_FragColor = surfaceColor;\r\n\r\n#else DEBUG\r\n    // // debug\r\n    PixelParams pixel;\r\n    getPixelParams(pixel);\r\n\r\n    SurfaceInputs inputs;\r\n    initSurfaceInputs(inputs, pixel);\r\n\r\n    Surface surface;\r\n    initSurface(surface, inputs, pixel);\r\n\r\n    PixelInfo info;\r\n    getPixelInfo(info, pixel, surface);\r\n\r\n    vec3 debug = vec3(0.0);\r\n\r\n    #ifdef Debug_ShadingNormal\r\n    debug = vec3(info.normalWS * 0.5 + 0.5);\r\n    #endif // Debug_ShadingNormal\r\n\r\n    #ifdef Debug_GeometryNormal\r\n    debug = vec3(info.vertexNormalWS * 0.5 + 0.5);\r\n    #endif // Debug_GeometryNormal\r\n\r\n    #ifdef Debug_GeometryTangent\r\n    debug = vec3(pixel.tangentWS * 0.5 + 0.5);\r\n    #endif // Debug_GeometryTangent\r\n\r\n    #ifdef Debug_GeometryBiTangent\r\n    debug = vec3(pixel.biNormalWS * 0.5 + 0.5);\r\n    #endif // Debug_GeometryBiTangent\r\n\r\n    #ifdef Debug_Roughness\r\n    debug = vec3(surface.perceptualRoughness);\r\n    #endif // Debug_Roughness\r\n\r\n    #ifdef Debug_Alpha\r\n    debug = vec3(surface.alpha);\r\n    #endif // Debug_Alpha\r\n\r\n    #ifdef Debug_Occlusion\r\n    debug = vec3(surface.occlusion);\r\n    #endif // Debug_Occlusion\r\n\r\n    #ifdef Debug_BaseColor\r\n    debug = surface.diffuseColor;\r\n    #endif // Debug_BaseColor\r\n\r\n    #ifdef Debug_Metallic\r\n    debug = vec3(inputs.metallic);\r\n    #endif // Debug_Metallic\r\n\r\n    #ifdef THICKNESS\r\n\t#ifdef Debug_VolumeThickness\r\n    debug = vec3(surface.thickness);\r\n\t#endif // Debug_VolumeThickness\r\n\r\n\t#ifdef Debug_Attenuation\r\n    {\r\n\tvec3 scaleLength = vec3(0.0);\r\n\tscaleLength.x = length(vec3(u_WorldMat[0].xyz));\r\n\tscaleLength.y = length(vec3(u_WorldMat[1].xyz));\r\n\tscaleLength.z = length(vec3(u_WorldMat[2].xyz));\r\n\r\n\tvec3 n = info.normalWS;\r\n\tvec3 r = -info.viewDir;\r\n\tfloat airIor = 1.0;\r\n\r\n\tfloat ior = surface.ior;\r\n\tfloat etaIR = airIor / ior;\r\n\tfloat etaRI = ior / airIor;\r\n\tvec3 refractionVector = normalize(refract(r, n, etaIR)) * surface.thickness * scaleLength;\r\n\r\n\tvec3 absorption = -log((surface.attenuationColor)) / (surface.attenuationDistance);\r\n\tdebug = exp(-absorption);\r\n    }\r\n\t#endif // Debug_Attenuation\r\n\r\n    #endif // THICKNESS\r\n\r\n    #ifdef TRANSMISSION\r\n\t#ifdef Debug_Transmission\r\n    vec3 E = getE(surface, info);\r\n    debug = transmissionIBL(surface, info, E);\r\n\t#endif // Debug_Transmission\r\n    #endif // TRANSMISSION\r\n\r\n    #ifdef Debug_IOR\r\n    debug = vec3(surface.ior - 1.0);\r\n    #endif // Debug_IOR\r\n\r\n    #ifdef Debug_SpecularFactor\r\n    debug = vec3(inputs.specularFactor);\r\n    #endif // Debug_SpecularFactor\r\n\r\n    #ifdef Debug_SpecularColor\r\n    debug = vec3(inputs.specularColor);\r\n    #endif // DebugSpecularColor\r\n\r\n    #ifdef Debug_f0\r\n    debug = vec3(surface.f0);\r\n    #endif // Debug_f0\r\n\r\n    #ifdef Debug_f90\r\n    debug = vec3(surface.f90);\r\n    #endif // Debug_f90\r\n\r\n    #ifdef Debug_FrontFace\r\n    if (gl_FrontFacing)\r\n\t{\r\n\t    debug = vec3(1.0, 0.0, 0.0);\r\n\t}\r\n    else\r\n\t{\r\n\t    debug = vec3(0.0, 1.0, 0.0);\r\n\t}\r\n    #endif // Debug_FrontFace\r\n\r\n    #ifdef Debug_SpecularAO\r\n    float specularAO = saturate(pow(info.NoV + surface.occlusion, exp2(-16.0 * surface.roughness - 1.0)) - 1.0 + surface.occlusion);\r\n\r\n    float diffAO = specularAO - surface.occlusion;\r\n\r\n    debug = vec3(abs(diffAO));\r\n\r\n    if (diffAO < 0.0)\r\n\t{\r\n\t    debug *= vec3(1.0, 0.0, 0.0);\r\n\t}\r\n    else\r\n\t{\r\n\t    debug *= vec3(0.0, 1.0, 0.0);\r\n\t}\r\n    #endif // Debug_SpecularAO\r\n\r\n    // // #ifdef CLEARCOAT\r\n    // //     // debug = vec3(info.iridescenceFresnel);\r\n    // //     #ifdef CLEARCOAT_NORMAL\r\n    // //     debug = vec3(surface.clearCoatNormalTS * 0.5 + 0.5);\r\n    // //     #endif // CLEARCOAT_NORMAL\r\n    // //     // debug = vec3(surface.clearCoatRoughness);\r\n    // //     // debug = vec3(surface.clearCoat);\r\n    // // #endif // CLEARCOAT\r\n\r\n    // debug = vec3(info.normalWS * 0.5 + 0.5);\r\n\r\n    // // #ifdef SHEEN\r\n    // //     // debug = vec3(inputs.sheenColor);\r\n    // //     // debug = vec3(inputs.sheenRoughness);\r\n    // //     debug = vec3(info.sheenScaling);\r\n    // // #endif // SHEEN\r\n\r\n    // // #ifdef IRIDESCENCE\r\n    // //     // debug = vec3(surface.iridescenceIor - 1.0);\r\n    // //     // debug = vec3(surface.iridescenceThickness / 1200.0);\r\n    // //     debug = vec3(info.iridescenceFresnel);\r\n    // // #endif // IRIDESCENCE\r\n\r\n    // // #ifdef TRANSMISSION\r\n    // //     debug = vec3(surface.transmission);\r\n    // // #endif // TRANSMISSION\r\n\r\n    debug = gammaToLinear(debug);\r\n    gl_FragColor = vec4(debug, 1.0);\r\n\r\n#endif // DEBUG\r\n}'),a.addShaderPass('#define SHADER_NAME glTFDepthVS\r\n\r\n#include "DepthVertex.glsl";\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    mat4 worldMat = getWorldMatrix();\r\n    vec4 pos = (worldMat * vec4(vertex.positionOS, 1.0));\r\n    vec3 positionWS = pos.xyz / pos.w;\r\n\r\n    mat4 normalMat = transpose(inverse(worldMat));\r\n    vec3 normalWS = normalize((normalMat * vec4(vertex.normalOS, 0.0)).xyz);\r\n\r\n    vec4 positionCS = DepthPositionCS(positionWS, normalWS);\r\n    gl_Position = remapPositionZ(positionCS);\r\n}','#define SHADER_NAME glTFDepthFS\r\n\r\n#include "DepthFrag.glsl";\r\n\r\nvoid main()\r\n{\r\n    gl_FragColor = getDepthColor();\r\n}',"ShadowCaster"),a.addShaderPass('#define SHADER_NAME glTFPBRDepthNormalVS\r\n\r\n#include "Math.glsl";\r\n\r\n#include "Camera.glsl";\r\n\r\n#include "Sprite3DVertex.glsl";\r\n\r\n#include "VertexCommon.glsl";\r\n\r\n#include "PBRVertex.glsl";\r\n\r\nvarying vec4 v_PositionCS;\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    PixelParams pixel;\r\n    initPixelParams(pixel, vertex);\r\n\r\n    sharePixelParams(pixel);\r\n\r\n    vec4 positionCS = getPositionCS(pixel.positionWS);\r\n    v_PositionCS = positionCS;\r\n    gl_Position = positionCS;\r\n    gl_Position = remapPositionZ(gl_Position);\r\n}','#define SHADER_NAME glTFPBRDepthNormalFS\r\n\r\n#include "Color.glsl";\r\n\r\n#include "Scene.glsl";\r\n#include "SceneFog.glsl";\r\n\r\n#include "Camera.glsl";\r\n#include "Sprite3DFrag.glsl";\r\n\r\n#include "ShadingFrag.glsl";\r\n\r\n#include "DepthNormalFrag.glsl";\r\n\r\nvarying vec4 v_PositionCS;\r\n\r\nvoid main()\r\n{\r\n    PixelParams pixel;\r\n    getPixelParams(pixel);\r\n\r\n    vec3 normalWS = pixel.normalWS;\r\n\r\n#ifdef NORMALMAP\r\n    #ifdef UV\r\n\r\n    vec2 uv = pixel.uv0;\r\n\r\n    vec3 normalSampler = texture2D(u_NormalTexture, uv).xyz;\r\n    normalSampler = normalize(normalSampler * 2.0 - 1.0);\r\n    normalSampler.y *= -1.0;\r\n    vec3 normalTS = normalScale(normalSampler, u_NormalScale);\r\n    normalWS = normalize(pixel.TBN * normalTS);\r\n\r\n    #endif UV\r\n#endif // NORMALMAP\r\n\r\n    vec4 positionCS = v_PositionCS;\r\n\r\n    vec4 dephtNormal = encodeDepthNormal(positionCS, normalWS);\r\n\r\n    gl_FragColor = dephtNormal;\r\n}',"DepthNormal")}}glTFShader.ShaderName="glTFPBR";class glTFResource extends r.Prefab{constructor(){super(3),this._buffers={},this._textures=[],this._materials=[],this._meshes={},this._extensions=new Map,this._pendingOps=[],this._scenes=[],this._nodes=[]}static registerExtension(e,r){this._Extensions[e]=r}get data(){return this._data}loadBinary(e,t){let n=this._data;if(n.buffers){let a=[];return n.buffers.forEach(((n,s)=>{if(r.Base64Tool.isBase64String(n.uri)){let e=r.Base64Tool.decode(n.uri.replace(r.Base64Tool.reghead,""));this._buffers[s]=e}else{let o=s;a.push(r.ILaya.loader.fetch(r.URL.join(e,n.uri),"arraybuffer",null==t?void 0:t.createCallback(.2)).then((e=>{this._buffers[o]=e})))}})),Promise.all(a)}return Promise.resolve()}loadTextureFromInfo(e,t,n,a){let s=this._data,o=e.index,i=s.textures[o],l=i.source,u=s.images[l],c=i.sampler,h=s.samplers?s.samplers[c]:void 0,f=this.getTextureConstructParams(u,h,t),d=this.getTexturePropertyParams(h);if(null!=u.bufferView){let e=s.bufferViews[u.bufferView],r=this._buffers[e.buffer],t=e.byteOffset||0,n=e.byteLength,i=r.slice(t,t+n);return this.loadTextureFromBuffer(i,u.mimeType,f,d,a).then((e=>(this._textures[o]=e,this.addDep(e),e)))}return this.loadTexture(r.URL.join(n,u.uri),f,d,a).then((e=>(this._textures[o]=e,this.addDep(e),e)))}loadTextures(e,r){let t=this._data,n=t.materials,a=t.textures,s=[];if(n&&a)for(let n of t.materials){let t=n.pbrMetallicRoughness;if(t){if(t.baseColorTexture){let n=!0,a=this.loadTextureFromInfo(t.baseColorTexture,n,e,r);s.push(a)}if(t.metallicRoughnessTexture){let n=!1,a=this.loadTextureFromInfo(t.metallicRoughnessTexture,n,e,r);s.push(a)}}if(n.normalTexture){let t=!1,a=this.loadTextureFromInfo(n.normalTexture,t,e,r);s.push(a)}if(n.occlusionTexture){let t=!1,a=this.loadTextureFromInfo(n.occlusionTexture,t,e,r);s.push(a)}if(n.emissiveTexture){let t=!0,a=this.loadTextureFromInfo(n.emissiveTexture,t,e,r);s.push(a)}}return this._extensions.forEach((t=>{if(t.loadAdditionTextures){let n=t.loadAdditionTextures(e,r);s.push(n)}})),Promise.all(s)}importMaterials(){return Promise.resolve().then((()=>{let e=this._data;e.materials&&e.materials.forEach(((e,r)=>{let t=this.createMaterial(e);this._materials[r++]=t,this.addDep(t)}))}))}importMeshes(){return Promise.resolve().then((()=>{let e=this._data;e.meshes&&e.nodes&&e.nodes.forEach((e=>{var r;if(null!=e.mesh){let t=this._data.meshes[e.mesh],n=null===(r=this._data.skins)||void 0===r?void 0:r[e.skin],a=e.mesh+(null!=e.skin?"_"+e.skin:""),s=this._meshes[a];s||(s=this.createMesh(t,n),this._meshes[a]=s,this.addDep(s))}}))}))}_parse(e,t,n){var a,s;if(!e.asset||"2.0"!==e.asset.version)throw new Error("glTF version wrong!");this._data=e;let o=r.URL.getPath(t);this._idCounter={},null===(a=e.extensionsUsed)||void 0===a||a.forEach((e=>{let r=glTFResource._Extensions[e];r?this._extensions.set(e,r(this)):console.warn(`glTF: unsupported used extension: ${e}`)})),null===(s=e.extensionsRequired)||void 0===s||s.forEach((e=>{glTFResource._Extensions[e]||console.warn(`glTF: unsupported required extension: ${e}`)}));let i=this.loadBinary(o,n);return i=i.then((()=>this.loadTextures(o,n))),i=i.then((()=>this.importMeshes())),i=i.then((()=>this.importMaterials())),i.then((()=>this._pendingOps.length>0?Promise.all(this._pendingOps).then((()=>{this._idCounter=null})):(this._idCounter=null,Promise.resolve())))}_parseglb(e,t,n){var a,s,o;let i=r.URL.getPath(t);this._idCounter={};let l=new r.Byte(e);if(1179937895!=l.readUint32())throw new Error("glb fromat wrong!");if(2!=l.readUint32())throw new Error("glb version wrong!");l.readUint32();let u=l.readUint32();if(1313821514!=l.readUint32())throw new Error("glb json chunk data wrong!");let c=l.readArrayBuffer(u),h=(new TextDecoder).decode(c),f=JSON.parse(h);this._data=f;let d=l.readUint32();if(5130562!=l.readUint32())throw new Error("glb bin chunk data wrong!");let m=null===(a=f.buffers)||void 0===a?void 0:a[0];m.byteLength=m.byteLength?Math.min(m.byteLength,d):d,this._buffers[0]=l.readArrayBuffer(m.byteLength),null===(s=f.extensionsUsed)||void 0===s||s.forEach((e=>{let r=glTFResource._Extensions[e];r?this._extensions.set(e,r(this)):console.warn(`glTF: unsupported used extension: ${e}`)})),null===(o=f.extensionsRequired)||void 0===o||o.forEach((e=>{glTFResource._Extensions[e]||console.warn(`glTF: unsupported required extension: ${e}`)}));let p=this.loadTextures(i,n);return p=p.then((()=>this.importMeshes())),p=p.then((()=>this.importMaterials())),p.then((()=>this._pendingOps.length>0?Promise.all(this._pendingOps).then((()=>{this._idCounter=null})):(this._idCounter=null,Promise.resolve())))}create(){let e=this._data;this._scenes.length=0,this._nodes.length=0,this._idCounter={},this.loadNodes(e.nodes),this.buildHierarchy(e.nodes),this.loadScenes(e.scenes),this.loadAnimations(e.animations);let r=null!=e.scene?e.scene:0,t=this._scenes[r];return this._scenes.length=0,this._nodes.length=0,this._idCounter=null,t}loadTextureFromBuffer(e,t,n,a,s){let o=`data:${t};base64,${r.Base64Tool.encode(e)}`;return r.ILaya.loader.load({url:o,constructParams:n,propertyParams:a},r.Loader.TEXTURE2D,null==s?void 0:s.createCallback())}loadTexture(e,t,n,a){return r.ILaya.loader.load({url:e,constructParams:t,propertyParams:n},r.Loader.TEXTURE2D,null==a?void 0:a.createCallback())}generateId(e){let r=this._idCounter[e];return null==r?r=0:r++,this._idCounter[e]=r,r.toString()}getAccessorComponentsNum(e){switch(e){case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16;default:return 0}}getAttributeNum(e){switch(e){case"POSITION":case"NORMAL":return 3;case"COLOR":case"BLENDWEIGHT":case"BLENDINDICES":case"TANGENT":return 4;case"UV":case"UV1":return 2;default:return 0}}_getTypedArrayConstructor(e){switch(e){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5125:return Uint32Array;case 5126:return Float32Array}}_getAccessorDateByteStride(e){switch(e){case 5120:case 5121:return 1;case 5122:case 5123:return 2;case 5125:case 5126:return 4}}getBufferFormBufferView(e,r,t,n,a){let s=this._buffers[e.buffer];const o=this._getTypedArrayConstructor(n);let i,l=this.getAccessorComponentsNum(t);if(e.byteStride){let t=e.byteStride,u=this._getAccessorDateByteStride(n),c=t/u,h=(r||0)/u,f=new o(s,e.byteOffset||0,e.byteLength/u);i=new o(a);let d=0;for(let e=0;e<a;e++){let r=e*c;for(let e=0;e<l;e++)i[d++]=f[r+h+e]}}else{i=new o(s,(e.byteOffset||0)+(r||0),a)}return i}getBufferwithAccessorIndex(e){let r=this._data.accessors[e];if(!r)return null;let t,n=r.count,a=this.getAccessorComponentsNum(r.type),s=n*a,o=this._data.bufferViews[r.bufferView];if(o)t=this.getBufferFormBufferView(o,r.byteOffset,r.type,r.componentType,s);else{t=new(this._getTypedArrayConstructor(r.componentType))(s).fill(0)}if(r.sparse){let e=r.sparse.count,n=r.sparse.indices,s=this._data.bufferViews[n.bufferView],o=this.getBufferFormBufferView(s,n.byteOffset,r.type,n.componentType,e),i=r.sparse.values,l=this._data.bufferViews[i.bufferView],u=this.getBufferFormBufferView(l,i.byteOffset,r.type,r.componentType,e*a);for(let r=0;r<e;r++){let e=o[r];for(let n=0;n<a;n++)t[e*a+n]=u[r*a+n]}}return t}getTextureMipmap(e){return!e||9729!=e.minFilter&&9728!=e.minFilter}getTextureFormat(e){return"image/jpeg"===e.mimeType?0:1}getTextureFilterMode(e){return e?9728===e.magFilter?0:this.getTextureMipmap(e)&&9987===e.minFilter?2:1:1}getTextureWrapMode(e){switch(e=null!=e?e:10497){case 10497:default:return r.WrapMode.Repeat;case 33071:return r.WrapMode.Clamp;case 33648:return r.WrapMode.Mirrored}}getTextureConstructParams(e,r,t){return[0,0,this.getTextureFormat(e),this.getTextureMipmap(r),!1,t]}getTexturePropertyParams(e){if(!e)return null;return{filterMode:this.getTextureFilterMode(e),wrapModeU:this.getTextureWrapMode(e.wrapS),wrapModeV:this.getTextureWrapMode(e.wrapT),anisoLevel:1,hdrEncodeFormat:r.HDREncodeFormat.NONE}}getTextureWithInfo(e){return e.texCoord&&console.warn("glTF Loader: non 0 uv channel unsupported."),this._textures[e.index]}getExtensionTextureInfo(e,r){let t=this._extensions.get(r);return e.extensions&&e.extensions[r]&&t?t.loadExtensionTextureInfo?t.loadExtensionTextureInfo(e):void 0:null}applyMaterialRenderState(e,t){var n;switch(e.alphaMode||"OPAQUE"){case"OPAQUE":t.materialRenderMode=r.MaterialRenderMode.RENDERMODE_OPAQUE;break;case"BLEND":t.materialRenderMode=r.MaterialRenderMode.RENDERMODE_TRANSPARENT;break;case"MASK":t.materialRenderMode=r.MaterialRenderMode.RENDERMODE_CUTOUT}t.alphaTestValue=null!==(n=e.alphaCutoff)&&void 0!==n?n:.5,e.doubleSided&&(t.cull=r.RenderState.CULL_NONE)}setMaterialTextureProperty(e,r,t,n,a,s){let o=this.getTextureWithInfo(r);if(e.setTexture(t,o),n&&e.setDefine(n,!0),s){let t=this.getExtensionTextureInfo(r,"KHR_texture_transform");t&&(e.setDefine(s,!0),e.setMatrix3x3(a,t.transform))}}applyDefaultMaterialProperties(e,t){var n,a,s,o;let i=e.pbrMetallicRoughness;if(i){if(i.baseColorFactor){let e=t.getVector4("u_BaseColorFactor");e.fromArray(i.baseColorFactor),t.setVector4("u_BaseColorFactor",e)}i.baseColorTexture&&this.setMaterialTextureProperty(t,i.baseColorTexture,"u_BaseColorTexture",glTFShader.Define_BaseColorMap,"u_BaseColorMapTransform",glTFShader.Define_BaseColorMapTransform);let e=null!==(n=i.metallicFactor)&&void 0!==n?n:1;t.setFloat("u_MetallicFactor",e);let r=null!==(a=i.roughnessFactor)&&void 0!==a?a:1;t.setFloat("u_RoughnessFactor",r),i.metallicRoughnessTexture&&this.setMaterialTextureProperty(t,i.metallicRoughnessTexture,"u_MetallicRoughnessTexture",glTFShader.Define_MetallicRoughnessMap,"u_MetallicRoughnessMapTransform",glTFShader.Define_MetallicRoughnessMapTransform)}if(e.normalTexture){this.setMaterialTextureProperty(t,e.normalTexture,"u_NormalTexture",glTFShader.Define_NormalMap,"u_NormalMapTransform",glTFShader.Define_NormalMapTransform);let r=null!==(s=e.normalTexture.scale)&&void 0!==s?s:1;t.setFloat("u_NormalScale",r)}if(e.occlusionTexture){this.setMaterialTextureProperty(t,e.occlusionTexture,"u_OcclusionTexture",glTFShader.Define_OcclusionMap,"u_OcclusionMapTransform",glTFShader.Define_OcclusionMapTransform);let r=null!==(o=e.occlusionTexture.strength)&&void 0!==o?o:1;t.setFloat("u_OcclusionStrength",r)}if(e.emissiveFactor){let n=t.getVector3("u_EmissionFactor");n.fromArray(e.emissiveFactor),t.setVector3("u_EmissionFactor",n),t.setDefine(r.PBRShaderLib.DEFINE_EMISSION,!0)}e.emissiveTexture&&(t.setDefine(r.PBRShaderLib.DEFINE_EMISSION,!0),this.setMaterialTextureProperty(t,e.emissiveTexture,"u_EmissionTexture",glTFShader.Define_EmissionMap,"u_EmissionMapTransform",glTFShader.Define_EmissionMapTransform)),this.applyMaterialRenderState(e,t)}createDefaultMaterial(e){let t=new r.Material;return t.setShaderName(glTFShader.ShaderName),t.name=e.name?e.name:"",this.applyDefaultMaterialProperties(e,t),t}createMaterial(e){let r=null,t=[];for(const n in e.extensions){let a=this._extensions.get(n);a&&(a.createMaterial&&(r=a.createMaterial(e)),a.additionMaterialProperties&&t.push(a))}return r||(r=this.createDefaultMaterial(e)),t.forEach((t=>{t.additionMaterialProperties(e,r)})),r}pickMeshMaterials(e){let t=[];return e.primitives.forEach((e=>{if(null!=e.material){let r=this._materials[e.material];t.push(r)}else{let n=new r.PBRStandardMaterial;t.push(n),this._materials.push(n),e.material=this._materials.indexOf(n)}})),t}loadScenes(e){e&&e.forEach(((e,r)=>{this._scenes[r]=this._loadScene(e)}))}_loadScene(e){return this._createSceneNode(e)}_createSceneNode(e){let t=new r.Sprite3D(e.name||"Scene");return e.nodes.forEach((e=>{let r=this._nodes[e];t.addChild(r)})),t}applyTransform(e,r){if(e.matrix){let t=r.transform.localMatrix;t.elements.set(e.matrix),r.transform.localMatrix=t}else{let t=r.transform.localPosition,n=r.transform.localRotation,a=r.transform.localScale;e.translation&&t.fromArray(e.translation),e.rotation&&n.fromArray(e.rotation),e.scale&&a.fromArray(e.scale),r.transform.localPosition=t,r.transform.localRotation=n,r.transform.localScale=a}}buildHierarchy(e){e.forEach(((e,r)=>{let t=this._nodes[r];e.children&&e.children.forEach((e=>{let r=this._nodes[e];t.addChild(r)}))})),e.forEach(((e,t)=>{let n=this._nodes[t];n instanceof r.SkinnedMeshSprite3D&&this.fixSkinnedSprite(e,n)}))}loadNodes(e){e&&e.forEach(((e,r)=>{this._nodes[r]=this.loadNode(e)}))}loadNode(e){return this.createSprite3D(e)}createSprite3D(e){let t;null!=e.skin?(t=this.createSkinnedMeshSprite3D(e),this.applyTransform(e,t)):null!=e.mesh?(t=this.createMeshSprite3D(e),this.applyTransform(e,t)):(t=new r.Sprite3D(e.name),this.applyTransform(e,t));let n=this.generateId("node");return t.name=e.name||`node_${n}`,t._extra.storeId="#"+n,t}createMeshSprite3D(e){let t=this._data.meshes[e.mesh],n=this._meshes[e.mesh],a=this.pickMeshMaterials(t),s=new r.MeshSprite3D(n,e.name);if(s.meshRenderer.sharedMaterials=a,s.meshRenderer.receiveShadow=!0,s.meshRenderer.castShadow=!0,t.weights){let e=s.meshRenderer;t.weights.forEach(((r,t)=>{let a=n.morphTargetData.getMorphChannelbyIndex(t);e.setMorphChannelWeight(a.name,r)}))}return s}createSkinnedMeshSprite3D(e){let t=this._data.meshes[e.mesh],n=this._meshes[e.mesh+"_"+e.skin],a=this.pickMeshMaterials(t),s=new r.SkinnedMeshSprite3D(n,e.name);if(s.skinnedMeshRenderer.sharedMaterials=a,s.skinnedMeshRenderer.receiveShadow=!0,s.skinnedMeshRenderer.castShadow=!0,t.weights){let e=s.skinnedMeshRenderer;t.weights.forEach(((r,t)=>{let a=n.morphTargetData.getMorphChannelbyIndex(t);e.setMorphChannelWeight(a.name,r)}))}return s}getArrributeBuffer(e,r,t,n){let a=this.getBufferwithAccessorIndex(e);if(!a)return null;n.push(r);let s=a;return t.set(r,s),s}getIndexBuffer(e,r){let t=this.getBufferwithAccessorIndex(e);if(t)return new Uint32Array(t).reverse();{let e=new Uint32Array(r);for(let t=0;t<r;t++)e[t]=r-1-t;return e}}calculateFlatNormal(e,r){let t=new Float32Array(e.length);for(let n=0;n<r.length;n+=3){let a=r[n],s=r[n+1],o=r[n+2],i=e[3*a],l=e[3*a+1],u=e[3*a+2],c=e[3*s]-i,h=e[3*s+1]-l,f=e[3*s+2]-u,d=e[3*o]-i,m=e[3*o+1]-l,p=e[3*o+2]-u,_=h*p-f*m,T=f*d-c*p,S=c*m-h*d,g=-1/Math.sqrt(_*_+T*T+S*S),M=_*g,x=T*g,A=S*g;t[3*a]=M,t[3*s]=M,t[3*o]=M,t[3*a+1]=x,t[3*s+1]=x,t[3*o+1]=x,t[3*a+2]=A,t[3*s+2]=A,t[3*o+2]=A}return t}parseMeshwithSubMeshData(e,t){let n,a=0,s=0;e.forEach((e=>{a+=e.vertexCount,s+=e.indices.length,n=n||e.vertexDecler}));let o,i=r.VertexMesh.getVertexDeclaration(n,!1),l=i.vertexStride/4,u=new Float32Array(l*a),c=r.IndexFormat.UInt32;a<65536?(o=new Uint16Array(s),c=r.IndexFormat.UInt16):o=new Uint32Array(s),this.fillMeshBuffers(e,u,o,l),this.generateMesh(u,o,i,c,e,t)}fillMeshBuffers(e,r,t,n){let a=0,s=0,o=0;e.forEach((e=>{let i=a,l=e.vertexCount,u=e.indices;for(let e=0;e<u.length;e++)t[i+e]=u[e]+s;a+=u.length,s+=l;const fillAttributeBuffer=(e,t,a=0)=>{let s=o+t;for(let t=0;t<l;t++)for(let o=0;o<a;o++)r[s+t*n+o]=e[t*a+o]};let c=0,h=e.attributeMap,f=h.get("POSITION");f&&(fillAttributeBuffer(f,c,3),c+=3);let d=h.get("NORMAL");d&&(fillAttributeBuffer(d,c,3),c+=3);let m=h.get("COLOR");m&&(fillAttributeBuffer(m,c,4),c+=4);let p=h.get("UV");p&&(fillAttributeBuffer(p,c,2),c+=2);let _=h.get("UV1");_&&(fillAttributeBuffer(_,c,2),c+=2);let T=h.get("BLENDWEIGHT");T&&(fillAttributeBuffer(T,c,4),c+=4);let S=h.get("BLENDINDICES");if(S){let e=new Uint8Array(S);fillAttributeBuffer(new Float32Array(e.buffer),c,1),c+=1}let g=h.get("TANGENT");g&&(fillAttributeBuffer(g,c,4),c+=4),o+=l*n}))}splitSubMeshByBonesCount(e,r,t,n,a,s){let o=0,i=new Set,l=e.get("BLENDINDICES"),u=l.length/4,c=new Float32Array(l.length),h=new Array(u).fill(!1);for(let e=0,r=t.length;e<r;e+=3){let u=new Set;for(let r=e;r<e+3;r++){let e=4*t[r];for(let r=0;r<4;r++)u.add(l[e+r])}let c=new Set([...i,...u]);if(c.size>24){let r=e-o;a.push(o),s.push(r);let t=Array.from(i);n.push(new Uint16Array(t)),o=e,i=new Set(u)}else i=c;if(e==r-3){let r=e-o+3;a.push(o),s.push(r),o=e;let t=Array.from(i);n.push(new Uint16Array(t))}}let f=n.length,d=new Map;e.forEach(((e,r)=>{let t=new Array;d.set(r,t)}));let m={};for(const e in r.targets){let t=m[e]=new Map;r.targets[e].forEach(((e,r)=>{t.set(r,new Array)}))}let p=u-1;for(let o=0;o<f;o++){let i=a[o],f=s[o],_=n[o],T=new Array(u).fill(!1),S=new Map;for(let n=0;n<f;n++){let a=t[n+i],s=4*a;for(let e=s;e<s+4;e++){let r=l[e],t=_.indexOf(r);t=-1==t?0:t,h[a]&&!T[a]?d.get("BLENDINDICES").push(t):h[a]&&T[a]||(c[e]=t)}if(h[a]||T[a])if(!h[a]&&T[a])t[n+i]=S.get(a);else if(h[a]&&!T[a]){T[a]=!0,p++,S.set(a,p),t[n+i]=p,d.forEach(((r,t)=>{let n=this.getAttributeNum(t),s=e.get(t);if("BLENDINDICES"!==t)for(let e=0;e<n;e++)r.push(s[e+a*n])}));for(const e in m){let t=m[e],n=r.targets[e];t.forEach(((e,r)=>{let t=this.getAttributeNum(r),s=n.get(r);for(let r=0;r<t;r++)e.push(s[r+a*t])}))}}else h[a]&&T[a]&&(t[n+i]=S.get(a));else T[a]=!0,S.set(a,a)}T.forEach(((e,r)=>{h[r]=e||h[r]}))}d.forEach(((r,t)=>{let n=e.get(t);"BLENDINDICES"==t&&(n=c);let a=n.length+r.length,s=new Float32Array(a);s.set(n,0),s.set(r,n.length),e.set(t,s)}));for(const e in m){let t=m[e],n=r.targets[e];t.forEach(((e,r)=>{let t=n.get(r),a=e.length+t.length,s=new Float32Array(a);s.set(t,0),s.set(e,t.length),n.set(r,s)}))}l=null}generateMesh(e,t,n,a,s,o){let i=r.Laya3DRender.renderOBJCreate.createVertexBuffer3D(e.byteLength,r.BufferUsage.Static,!0);i.vertexDeclaration=n,i.setData(e.buffer);let l=r.Laya3DRender.renderOBJCreate.createIndexBuffer3D(a,t.length,r.BufferUsage.Static,!0);l.setData(t),o._indexFormat=a,o._indexBuffer=l,o._vertexBuffer=i,o._setBuffer(i,l),o._vertexCount=i._byteLength/n.vertexStride;let u=!1,c=new r.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),h=new r.Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),f=0,d=s.length,m=new Array(d);for(let e=0;e<d;e++){let t=s[e],n=new r.SubMesh(o);m[e]=n,n._vertexBuffer=i,n._indexBuffer=l;let d=f;f+=t.indices.length;let p=t.indices.length;n._setIndexRange(d,p,a),n._boneIndicesList=t.boneIndicesList,n._subIndexBufferStart=t.subIndexStartArray,n._subIndexBufferCount=t.subIndexCountArray;for(let e=0;e<n._subIndexBufferStart.length;e++)n._subIndexBufferStart[e]+=d;t.boundMax&&t.boundMin?(c.x=Math.min(t.boundMin[0],c.x),c.y=Math.min(t.boundMin[1],c.y),c.z=Math.min(t.boundMin[2],c.z),h.x=Math.max(t.boundMax[0],h.x),h.y=Math.max(t.boundMax[1],h.y),h.z=Math.max(t.boundMax[2],h.z)):u=!0}o._setSubMeshes(m),u?o.calculateBounds():(o.bounds.setMin(c),o.bounds.setMax(h));let p=i._byteLength+l._byteLength;o._setCPUMemory(p),o._setGPUMemory(p)}applyglTFSkinData(e,t,n){if(!n)return;let a=n.joints,s=new Float32Array(this.getBufferwithAccessorIndex(n.inverseBindMatrices)),o=a.length,i=e._boneNames=[];a.forEach((e=>{let r=this._data.nodes[e];i.push(r.name)})),e._inverseBindPoses=[],e._inverseBindPosesBuffer=s.buffer;for(let t=0;t<o;t++){let n=16*t,a=s.slice(n,n+16);e._inverseBindPoses[t]=new r.Matrix4x4(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15],a)}let l=t.length,u=e._skinnedMatrixCaches;u.length=e._inverseBindPoses.length;for(let t=0;t<l;t++){let n=e.getSubMesh(t),a=n._subIndexBufferStart.length;for(let e=0;e<a;e++){let a=n._boneIndicesList[e];for(let n=0;n<a.length;n++){let s=a[n];u[s]||(u[s]=new r.skinnedMatrixCache(t,e,n))}}}for(let e=0;e<u.length;e++)u[e]||(u[e]=new r.skinnedMatrixCache(0,0,0))}applyMorphTarget(e,t){let n=!1,a=!1,s=!1;if(t.forEach((e=>{n=e.morphtargets.position||n,a=e.morphtargets.normal||a,s=e.morphtargets.tangent||s})),!(n||s||s))return;let o=e.vertexCount,i=new r.MorphTargetData;i.vertexCount=o;let l=[];n&&l.push("POSITION"),a&&l.push("NORMAL"),s&&l.push("TANGENT");let u=r.VertexMesh.getVertexDeclaration(l.toLocaleString()),c=u.vertexStride/4;i.vertexDec=u;let h=i.bounds,f=h.getMin(),d=h.getMax();f.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),d.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);let m=0;for(let e=0;e<t.length;e++){let n=t[e];f.x=Math.min(f.x,n.morphtargets.boundMin[0]),f.y=Math.min(f.y,n.morphtargets.boundMin[1]),f.z=Math.min(f.z,n.morphtargets.boundMin[2]),d.x=Math.max(d.x,n.morphtargets.boundMax[0]),d.y=Math.max(d.y,n.morphtargets.boundMax[1]),d.z=Math.max(d.z,n.morphtargets.boundMax[2]);let a=n.morphtargets.targets;for(const e in a){let t=i.getMorphChannel(e);if(!t){t=new r.MorphTargetChannel,t.name=e;let n=new r.MorphTarget;n.name=e,n.data=new Float32Array(o*c).fill(0),t.addTarget(n),i.addMorphChannel(t)}let s=t.getTargetByIndex(0),l=a[e];for(let e=0;e<n.vertexCount;e++){let t=l.get("POSITION");if(t){let n=u.getVertexElementByUsage(r.VertexMesh.MESH_POSITION0).offset/4;s.data[(e+m)*c+n]=t[3*e],s.data[(e+m)*c+n+1]=t[3*e+1],s.data[(e+m)*c+n+2]=t[3*e+2]}let a=l.get("NORMAL");if(a){let t=u.getVertexElementByUsage(r.VertexMesh.MESH_NORMAL0).offset/4;s.data[(e+m)*c+t]=a[3*e],s.data[(e+m)*c+t+1]=a[3*e+1],s.data[(e+m)*c+t+2]=a[3*e+2]}let o=l.get("TANGENT");if(o){let t=u.getVertexElementByUsage(r.VertexMesh.MESH_TANGENT0).offset/4;s.data[(e+m)*c+t]=o[3*e],s.data[(e+m)*c+t+1]=o[3*e+1],s.data[(e+m)*c+t+2]=o[3*e+2],s.data[(e+m)*c+t+3]=n.attributeMap.get("TANGENT")[4*e+3]}}}m+=n.vertexCount}h.setMin(f),h.setMax(d),e.morphTargetData=i,i.initData()}createMesh(e,t){let n=new r.Mesh,a=e.primitives,s=e.weights,o=t?t.joints.length:0,i=[];return a.forEach((r=>{var n;let a=r.mode;null==a&&(a=4),4!=a&&console.warn("glTF Loader: only support gl.TRIANGLES.");let l,u=[],c=new Map,h=r.attributes,f=this.getArrributeBuffer(h.POSITION,"POSITION",c,u),d=f.length/3,m=this.getIndexBuffer(r.indices,d),p=this._data.accessors[h.POSITION],_=this.getArrributeBuffer(h.NORMAL,"NORMAL",c,u);if(_||(_=this.calculateFlatNormal(f,m),u.push("NORMAL"),c.set("NORMAL",_)),this.getArrributeBuffer(h.COLOR_0,"COLOR",c,u),this.getArrributeBuffer(h.TEXCOORD_0,"UV",c,u),this.getArrributeBuffer(h.TEXCOORD_1,"UV1",c,u),this.getArrributeBuffer(h.WEIGHTS_0,"BLENDWEIGHT",c,u),this.getArrributeBuffer(h.JOINTS_0,"BLENDINDICES",c,u),l=this.getArrributeBuffer(h.TANGENT,"TANGENT",c,u),l)for(let e=0;e<l.length;e+=4)l[e+3]*=-1;let T=r.targets,S={weights:s,position:!1,normal:!1,tangent:!1,targets:{},boundMin:[Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE],boundMax:[-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE]};if(T){let r,t=(null===(n=e.extras)||void 0===n?void 0:n.targetNames)||[];r=S.targets,T.forEach(((e,n)=>{let a=t[n]||`target_${n}`,s=new Map;r[a]=s;let o=this.getBufferwithAccessorIndex(e.POSITION),i=this.getBufferwithAccessorIndex(e.NORMAL),l=this.getBufferwithAccessorIndex(e.TANGENT);if(o&&(s.set("POSITION",o),S.position=!0,f)){let e=f.length/3;for(let r=0;r<e;r++){let e=3*r,t=f[e]+o[e],n=f[e+1]+o[e+1],a=f[e+2]+o[e+2];S.boundMin[0]=Math.min(t,S.boundMin[0]),S.boundMin[1]=Math.min(n,S.boundMin[1]),S.boundMin[2]=Math.min(a,S.boundMin[2]),S.boundMax[0]=Math.max(t,S.boundMax[0]),S.boundMax[1]=Math.max(n,S.boundMax[1]),S.boundMax[2]=Math.max(a,S.boundMax[2])}}i&&(s.set("NORMAL",i),S.normal=!0),l&&(s.set("TANGENT",l),S.tangent=!0)}))}let g=new Array,M=[],x=[];if(t)if(o>24)this.splitSubMeshByBonesCount(c,S,m,g,M,x),d=c.get("POSITION").length/3;else{M[0]=0,x[0]=m.length,g[0]=new Uint16Array(o);for(let e=0;e<o;e++)g[0][e]=e}else M[0]=0,x[0]=m.length;let A=u.toString(),C=new PrimitiveSubMesh;i.push(C),C.attributeMap=c,C.boundMax=p.max,C.boundMin=p.min,C.morphtargets=S,C.indices=m,C.vertexCount=d,C.vertexDecler=A,C.boneIndicesList=g,C.subIndexStartArray=M,C.subIndexCountArray=x})),this.parseMeshwithSubMeshData(i,n),this.applyglTFSkinData(n,i,t),this.applyMorphTarget(n,i),n}calSkinnedSpriteLocalBounds(e){let t=e.skinnedMeshRenderer,n=e.meshFilter.sharedMesh,a=t.rootBone.transform.worldMatrix,s=new r.Matrix4x4;a.invert(s);let o=n.getIndices(),i=[],l=[],u=[];n.getPositions(i),n.getBoneIndices(l),n.getBoneWeights(u);let c=[];n._subMeshes.forEach(((e,t)=>{e._boneIndicesList.forEach(((t,n)=>{let a=e._subIndexBufferStart[n],s=e._subIndexBufferCount[n]+a;for(let e=a;e<s;e++){let n=o[e],a=l[n],s=t[a.x],i=t[a.y],u=t[a.z],h=t[a.w];c[n]=new r.Vector4(s,i,u,h)}}))}));let h=n._inverseBindPoses,f=t.bones,d=[],m=new r.Matrix4x4;f.forEach(((e,t)=>{d[t]=new r.Matrix4x4,r.Matrix4x4.multiply(s,e.transform.worldMatrix,m),r.Matrix4x4.multiply(m,h[t],d[t])}));let p=new r.Matrix4x4,_=new r.Vector3,T=new r.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),S=new r.Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let e=0;e<i.length;e++){let t=i[e],n=c[e],a=u[e];if(n&&a){for(let e=0;e<16;e++)p.elements[e]=d[n.x].elements[e]*a.x,p.elements[e]+=d[n.y].elements[e]*a.y,p.elements[e]+=d[n.z].elements[e]*a.z,p.elements[e]+=d[n.w].elements[e]*a.w;r.Vector3.transformV3ToV3(t,p,_),r.Vector3.min(T,_,T),r.Vector3.max(S,_,S)}}i=null,l=u=c=null,o=null,d=null,t.localBounds.setMin(T),t.localBounds.setMax(S),t.localBounds=t.localBounds}fixSkinnedSprite(e,r){let t=this._data.skins[e.skin],n=r.skinnedMeshRenderer;t.joints.forEach((e=>{let r=this._nodes[e];n.bones.push(r)})),null==t.skeleton&&(t.skeleton=t.joints[0]),n.rootBone=this._nodes[t.skeleton],this.calSkinnedSpriteLocalBounds(r)}getAnimationRoot(e){const isContainNode=(e,r)=>{if(!e)return!1;if(-1==e.indexOf(r))for(let t=0;t<e.length;t++){let n=this._data.nodes[e[t]];if(isContainNode(n.children,r))return!0}return!0};let r=e[0].target.node;for(let e=0;e<this._data.scenes.length;e++){let t=this._data.scenes[e];if(isContainNode(t.nodes,r))return this._scenes[e]}return null}getAnimationPath(e,r){let t=[];if(e==r)return t;let n=r;for(;n.parent!=e;)n=n.parent,t.push(n.name);return t=t.reverse(),t.push(r.name),t}loadAnimations(e){e&&e.forEach(((e,r)=>{this.loadAnimation(e)}))}loadAnimation(e){return this.createAnimator(e)}createAnimator(e){let t=e.channels;e.samplers;let n=this.getAnimationRoot(t);if(!n)return null;let a=n.getComponent(r.Animator);if(!a){a=n.addComponent(r.Animator);let e=new r.AnimatorControllerLayer("AnimatorLayer");a.addControllerLayer(e),e.defaultWeight=1}let s=this.createAnimatorClip(e,n),o=a.getControllerLayer(),i=s.name;o.getAnimatorState(i)&&(i=s.name=`${i}_${this.generateId(i)}`);let l=new r.AnimatorState;return l.name=i,l.clip=s,o.addState(l),o.defaultState=l,o.playOnWake=!0,a}createAnimatorClip(e,t){let n=new r.AnimationClip,a=0,s=e.channels,o=e.samplers,i=[];s.forEach(((e,n)=>{var s;let l=e.target,u=o[e.sampler],c=l.path,h=this.getBufferwithAccessorIndex(u.input),f=this.getBufferwithAccessorIndex(u.output),d=new Float32Array(h),m=new Float32Array(f),p=this._nodes[l.node],_=this.getAnimationPath(t,p);if("weights"==c){let e=null===(s=p.getComponent(r.MeshFilter))||void 0===s?void 0:s.sharedMesh;if(e&&e.morphTargetData){let t=p.getComponent(r.SkinnedMeshRenderer)?"SkinnedMeshRenderer":"MeshRenderer",n=e.morphTargetData,s=n.channelCount;if(m.length/d.length==s)for(let e=0;e<s;e++){let r=n.getMorphChannelbyIndex(e).name,o={};i.push(o),o.paths=_,o.interpolation=u.interpolation,o.timeArray=d,o.valueArray=new Float32Array(d.length);for(let r=0;r<d.length;r++)o.valueArray[r]=m[r*s+e];o.propertyOwner=t,o.propertise=[],o.propertise.push("morphTargetValues"),o.propertise.push(r),o.propertyLength=o.propertise.length,o.type=0,o.callbackFunc="_changeMorphTargetValue",o.callbackParams=[r],o.propertyChangePath="morphTargetValues",o.duration=o.timeArray[o.timeArray.length-1],a=Math.max(a,o.duration)}}}else{let e={};i.push(e),e.timeArray=d,e.valueArray=m;let r=u.interpolation;switch(e.interpolation=r,e.paths=_,c){case"translation":e.propertyOwner="transform",e.propertyLength=1,e.propertise=[],e.propertise.push("localPosition"),e.type=1;break;case"rotation":e.propertyOwner="transform",e.propertyLength=1,e.propertise=[],e.propertise.push("localRotation"),e.type=2;break;case"scale":e.propertyOwner="transform",e.propertyLength=1,e.propertise=[],e.propertise.push("localScale"),e.type=3}e.duration=e.timeArray[e.timeArray.length-1],a=Math.max(a,e.duration)}})),n.name=e.name?e.name:`Animation_${this.generateId("Animation")}`,n._duration=a,n.islooping=!0,n._frameRate=30;let l=i.length,u=n._nodes;u.count=l;let c=n._nodesMap={},h=n._nodesDic={};for(let e=0;e<l;e++){let t=new r.KeyframeNode,n=i[e];u.setNodeByIndex(e,t),t._indexInList=e;let a=t.type=n.type,s=n.paths.length;t._setOwnerPathCount(s);let o=n.paths;for(let e=0;e<s;e++)t._setOwnerPathByIndex(e,o[e]);let l=t._joinOwnerPath("/"),f=c[l];f||(c[l]=f=[]),f.push(t),t.propertyOwner=n.propertyOwner;let d=n.propertyLength;t._setPropertyCount(d);for(let e=0;e<d;e++)t._setPropertyByIndex(e,n.propertise[e]);let m=l+"."+t.propertyOwner+"."+t._joinProperty(".");h[m]=m,t.fullPath=m,t.callbackFunData=n.callbackFunc,t.callParams=n.callbackParams,t.propertyChangePath=n.propertyChangePath;let p=n.timeArray.length;for(let e=0;e<p;e++)switch(a){case 0:let a=new r.FloatKeyframe;switch(t._setKeyframeByIndex(e,a),a.time=n.timeArray[e],n.interpolation){case"CUBICSPLINE":a.value=n.valueArray[3*e+1],a.inTangent=n.valueArray[3*e+0],a.outTangent=n.valueArray[3*e+2];break;case"STEP":a.value=n.valueArray[e],a.inTangent=1/0,a.outTangent=1/0;break;default:{a.value=n.valueArray[e];let r=0==e?e:e-1,t=n.timeArray[r],s=n.valueArray[r],o=r==e?1:a.time-t;a.inTangent=(a.value-s)/o;let i=e==p-1?e:e+1,l=n.timeArray[i],u=n.valueArray[i],c=i==e?1:l-a.time;a.outTangent=(u-a.value)/c,r==e&&(a.inTangent=a.outTangent),i==e&&(a.outTangent=a.inTangent)}}break;case 1:case 3:case 4:let s=new r.Vector3Keyframe;t._setKeyframeByIndex(e,s);let o=s.time=n.timeArray[e],i=s.inTangent,l=s.outTangent,u=s.value;switch(n.interpolation){case"CUBICSPLINE":u.setValue(n.valueArray[9*e+3],n.valueArray[9*e+4],n.valueArray[9*e+5]),i.setValue(n.valueArray[9*e+0],n.valueArray[9*e+1],n.valueArray[9*e+2]),l.setValue(n.valueArray[9*e+6],n.valueArray[9*e+7],n.valueArray[9*e+8]);break;case"STEP":u.setValue(n.valueArray[3*e],n.valueArray[3*e+1],n.valueArray[3*e+2]),i.setValue(1/0,1/0,1/0),l.setValue(1/0,1/0,1/0);break;default:{u.setValue(n.valueArray[3*e],n.valueArray[3*e+1],n.valueArray[3*e+2]);let r=0==e?e:e-1,t=n.timeArray[r],a=n.valueArray[3*r],s=n.valueArray[3*r+1],c=n.valueArray[3*r+2],h=r==e?1:o-t;i.x=(u.x-a)/h,i.y=(u.y-s)/h,i.z=(u.z-c)/h;let f=e==p-1?e:e+1,d=n.timeArray[f],m=n.valueArray[3*f],_=n.valueArray[3*f+1],T=n.valueArray[3*f+2],S=f==e?1:d-o;l.x=(m-u.x)/S,l.y=(_-u.y)/S,l.z=(T-u.z)/S,r==e&&l.cloneTo(i),f==e&&i.cloneTo(l)}}break;case 2:let c=new r.QuaternionKeyframe;t._setKeyframeByIndex(e,c);let h=c.time=n.timeArray[e],f=c.inTangent,d=c.outTangent,m=c.value;switch(n.interpolation){case"CUBICSPLINE":m.set(n.valueArray[12*e+4],n.valueArray[12*e+5],n.valueArray[12*e+6],n.valueArray[12*e+7]),f.setValue(n.valueArray[12*e+0],n.valueArray[12*e+1],n.valueArray[12*e+2],n.valueArray[12*e+3]),d.setValue(n.valueArray[12*e+8],n.valueArray[12*e+9],n.valueArray[12*e+10],n.valueArray[12*e+11]);break;case"STEP":m.set(n.valueArray[4*e+0],n.valueArray[4*e+1],n.valueArray[4*e+2],n.valueArray[4*e+3]),f.setValue(1/0,1/0,1/0,1/0),d.setValue(1/0,1/0,1/0,1/0);break;default:{m.set(n.valueArray[4*e+0],n.valueArray[4*e+1],n.valueArray[4*e+2],n.valueArray[4*e+3]);let r=0==e?e:e-1,t=n.timeArray[r],a=n.valueArray[4*r],s=n.valueArray[4*r+1],o=n.valueArray[4*r+2],i=n.valueArray[4*r+3],l=r==e?1:h-t;f.x=(m.x-a)/l,f.y=(m.y-s)/l,f.z=(m.z-o)/l,f.w=(m.w-i)/l;let u=e==p-1?e:e+1,c=n.timeArray[u],_=n.valueArray[4*u],T=n.valueArray[4*u+1],S=n.valueArray[4*u+2],g=n.valueArray[4*u+3];m.x*_+m.y*T+m.z*S+m.w*g<0&&(_*=-1,T*=-1,S*=-1,g*=-1,n.valueArray[4*u]=_,n.valueArray[4*u+1]=T,n.valueArray[4*u+2]=S,n.valueArray[4*u+3]=g);let M=u==e?1:c-h;d.x=(_-m.x)/M,d.y=(T-m.y)/M,d.z=(S-m.z)/M,d.w=(g-m.w)/M,r==e&&d.cloneTo(f),u==e&&f.cloneTo(d)}}}}return i=null,n}}glTFResource._Extensions={};class PrimitiveSubMesh{constructor(){}}r.Laya.onInitModule((()=>{glTFShader.init()}));const t="KHR_texture_transform",n=new r.Matrix3x3,a=new r.Matrix3x3,s=new r.Vector2,o=new r.Vector2;class KHR_texture_transform{constructor(e){this.name=t,this._resource=e}createTransform(e){var t;s.setValue(0,0),e.offset&&s.fromArray(e.offset),r.Matrix3x3.createFromTranslation(s,n);let i=null!==(t=e.rotation)&&void 0!==t?t:0;r.Matrix3x3.createFromRotation(-i,a),o.setValue(1,1),e.scale&&o.fromArray(e.scale);let l=new r.Matrix3x3;return r.Matrix3x3.multiply(n,a,l),l.scale(o,l),l}loadExtensionTextureInfo(e){var r;let t=null===(r=e.extensions)||void 0===r?void 0:r.KHR_texture_transform;return{transform:this.createTransform(t),texCoord:t.texCoord}}}glTFResource.registerExtension(t,(e=>new KHR_texture_transform(e)));const i="KHR_materials_anisotropy";class KHR_materials_anisotropy{constructor(e){this.name=i,this._resource=e}loadAdditionTextures(e,r){let t=this._resource.data.materials,n=this._resource.data.textures;if(t&&n){let n=[];return t.forEach((t=>{var a;let s=null===(a=t.extensions)||void 0===a?void 0:a.KHR_materials_anisotropy;if(s&&s.anisotropyTexture){let t=this._resource.loadTextureFromInfo(s.anisotropyTexture,!1,e,r);n.push(t)}})),Promise.all(n)}return Promise.resolve()}additionMaterialProperties(e,t){var n,a;let s=e.extensions.KHR_materials_anisotropy,o=null!==(n=s.anisotropyStrength)&&void 0!==n?n:0,i=null!==(a=s.anisotropyRotation)&&void 0!==a?a:0;if(t.setDefine(r.PBRShaderLib.DEFINE_ANISOTROPY,!0),t.setFloat("u_AnisotropyStrength",o),t.setFloat("u_AnisotropyRotation",i),s.anisotropyTexture){let e=this._resource.getTextureWithInfo(s.anisotropyTexture);t.setTexture("u_AnisotropyTexture",e),t.setDefine(glTFShader.Define_AnisotropyMap,!0)}}}glTFResource.registerExtension(i,(e=>new KHR_materials_anisotropy(e)));const l="KHR_materials_clearcoat";class KHR_materials_clearcoat{constructor(e){this.name=l,this._resource=e}loadAdditionTextures(e,r){let t=this._resource.data.materials,n=this._resource.data.textures;if(t&&n){let n=[];return t.forEach((t=>{var a;let s=null===(a=t.extensions)||void 0===a?void 0:a.KHR_materials_clearcoat;if(s){if(s.clearcoatTexture){let t=this._resource.loadTextureFromInfo(s.clearcoatTexture,!1,e,r);n.push(t)}if(s.clearcoatRoughnessTexture){let t=this._resource.loadTextureFromInfo(s.clearcoatRoughnessTexture,!1,e,r);n.push(t)}if(s.clearcoatNormalTexture){let t=this._resource.loadTextureFromInfo(s.clearcoatNormalTexture,!1,e,r);n.push(t)}}})),Promise.all(n)}return Promise.resolve()}additionMaterialProperties(e,t){var n,a,s;let o=e.extensions.KHR_materials_clearcoat,i=null!==(n=o.clearcoatFactor)&&void 0!==n?n:0,l=null!==(a=o.clearcoatRoughnessFactor)&&void 0!==a?a:0;if(t.setDefine(r.PBRShaderLib.DEFINE_CLEARCOAT,!0),t.setFloat("u_ClearCoatFactor",i),o.clearcoatTexture&&this._resource.setMaterialTextureProperty(t,o.clearcoatTexture,"u_ClearCoatTexture",glTFShader.Define_ClearCoatMap,"u_ClearCoatMapTransform",glTFShader.Define_ClearCoatMapTransform),t.setFloat("u_ClearCoatRoughness",l),o.clearcoatRoughnessTexture&&this._resource.setMaterialTextureProperty(t,o.clearcoatRoughnessTexture,"u_ClearCoatRoughnessTexture",glTFShader.Define_ClearCoatRoughnessMap,"u_ClearCoatRoughnessMapTransform",glTFShader.Define_ClearCoatRoughnessMapTransform),o.clearcoatNormalTexture){t.setDefine(r.PBRShaderLib.DEFINE_CLEARCOAT_NORMAL,!0),this._resource.setMaterialTextureProperty(t,o.clearcoatNormalTexture,"u_ClearCoatNormalTexture",null,"u_ClearCoatNormalMapTransform",glTFShader.Define_ClearCoatNormalMapTransform);let e=null!==(s=o.clearcoatNormalTexture.scale)&&void 0!==s?s:1;t.setFloat("u_ClearCoatNormalScale",e)}}}glTFResource.registerExtension(l,(e=>new KHR_materials_clearcoat(e)));const u="KHR_materials_emissive_strength";class KHR_materials_emissive_strength{constructor(e){this.name=u,this._resource=e}additionMaterialProperties(e,r){var t;let n=null!==(t=e.extensions.KHR_materials_emissive_strength.emissiveStrength)&&void 0!==t?t:1;r.setFloat("u_EmissionStrength",n)}}glTFResource.registerExtension(u,(e=>new KHR_materials_emissive_strength(e)));const c="KHR_materials_ior";class KHR_materials_ior{constructor(e){this.name=c,this._resource=e}additionMaterialProperties(e,t){var n;let a=null!==(n=e.extensions.KHR_materials_ior.ior)&&void 0!==n?n:1.5;t.setDefine(r.PBRShaderLib.DEFINE_IOR,!0),t.setFloat("u_Ior",a)}}glTFResource.registerExtension(c,(e=>new KHR_materials_ior(e)));const h="KHR_materials_iridescence";class KHR_materials_iridescence{constructor(e){this.name=h,this._resource=e}loadAdditionTextures(e,r){let t=this._resource.data.materials,n=this._resource.data.textures;if(t&&n){let n=[];return t.forEach((t=>{var a;let s=null===(a=t.extensions)||void 0===a?void 0:a.KHR_materials_iridescence;if(s){if(s.iridescenceTexture){let t=this._resource.loadTextureFromInfo(s.iridescenceTexture,!1,e,r);n.push(t)}if(s.iridescenceThicknessTexture){let t=this._resource.loadTextureFromInfo(s.iridescenceThicknessTexture,!1,e,r);n.push(t)}}})),Promise.all(n)}return Promise.resolve()}additionMaterialProperties(e,t){var n,a,s,o;let i=e.extensions.KHR_materials_iridescence,l=null!==(n=i.iridescenceFactor)&&void 0!==n?n:0,u=null!==(a=i.iridescenceIor)&&void 0!==a?a:1.3,c=null!==(s=i.iridescenceThicknessMinimum)&&void 0!==s?s:100,h=null!==(o=i.iridescenceThicknessMaximum)&&void 0!==o?o:400;t.setDefine(r.PBRShaderLib.DEFINE_IRIDESCENCE,!0),t.setFloat("u_IridescenceFactor",l),t.setFloat("u_IridescenceIor",u),t.setFloat("u_IridescenceThicknessMinimum",c),t.setFloat("u_IridescenceThicknessMaximum",h),i.iridescenceTexture&&this._resource.setMaterialTextureProperty(t,i.iridescenceTexture,"u_IridescenceTexture",glTFShader.Define_IridescenceMap,"u_IridescenceMapTransform",glTFShader.Define_IridescenceMapTransform),i.iridescenceThicknessTexture&&this._resource.setMaterialTextureProperty(t,i.iridescenceThicknessTexture,"u_IridescenceThicknessTexture",glTFShader.Define_IridescenceThicknessMap,"u_IridescenceThicknessMapTransform",glTFShader.Define_IridescenceThicknessMapTransform)}}glTFResource.registerExtension(h,(e=>new KHR_materials_iridescence(e)));const f="KHR_materials_sheen";class KHR_materials_sheen{constructor(e){this.name=f,this._resource=e}loadAdditionTextures(e,r){let t=this._resource.data.materials,n=this._resource.data.textures;if(t&&n){let n=[];return t.forEach((t=>{var a;let s=null===(a=t.extensions)||void 0===a?void 0:a.KHR_materials_sheen;if(s){if(s.sheenColorTexture){let t=!1,a=this._resource.loadTextureFromInfo(s.sheenColorTexture,t,e,r);n.push(a)}if(s.sheenRoughnessTexture){let t=!1,a=this._resource.loadTextureFromInfo(s.sheenRoughnessTexture,t,e,r);n.push(a)}}})),Promise.all(n)}return Promise.resolve()}additionMaterialProperties(e,t){var n;let a=e.extensions.KHR_materials_sheen;t.setDefine(r.PBRShaderLib.DEFINE_SHEEN,!0);let s=new r.Vector3(0,0,0);a.sheenColorFactor&&s.fromArray(a.sheenColorFactor);let o=null!==(n=a.sheenRoughnessFactor)&&void 0!==n?n:0;t.setVector3("u_SheenColorFactor",s),t.setFloat("u_SheenRoughness",o),a.sheenColorTexture&&this._resource.setMaterialTextureProperty(t,a.sheenColorTexture,"u_SheenColorTexture",glTFShader.Define_SheenColorMap,"u_SheenColorMapTransform",glTFShader.Define_SheenColorMapTransform),a.sheenRoughnessTexture&&this._resource.setMaterialTextureProperty(t,a.sheenRoughnessTexture,"u_SheenRoughnessTexture",glTFShader.Define_SheenRoughnessMap,"u_SheenRoughnessMapTransform",glTFShader.Define_SheenRoughnessMapTransform)}}glTFResource.registerExtension(f,(e=>new KHR_materials_sheen(e)));const d="KHR_materials_transmission";class KHR_materials_transmission{constructor(e){this.name=d,this._resource=e}loadAdditionTextures(e,r){let t=this._resource.data.materials,n=this._resource.data.textures;if(t&&n){let n=[];return t.forEach((t=>{var a;let s=null===(a=t.extensions)||void 0===a?void 0:a.KHR_materials_transmission;if(s&&s.transmissionTexture){let t=!1,a=this._resource.loadTextureFromInfo(s.transmissionTexture,t,e,r);n.push(a)}})),Promise.all(n)}return Promise.resolve()}additionMaterialProperties(e,t){var n;let a=e.extensions.KHR_materials_transmission,s=null!==(n=a.transmissionFactor)&&void 0!==n?n:0;t.materialRenderMode=r.MaterialRenderMode.RENDERMODE_CUSTOME,t.renderQueue=3e3,t.setDefine(r.PBRShaderLib.DEFINE_TRANSMISSION,!0),t.setFloat("u_TransmissionFactor",s),a.transmissionTexture&&this._resource.setMaterialTextureProperty(t,a.transmissionTexture,"u_TransmissionTexture",glTFShader.Define_TransmissionMap,"u_TransmissionMapTransform",glTFShader.Define_TransmissionMapTransform)}}glTFResource.registerExtension(d,(e=>new KHR_materials_transmission(e)));const m="KHR_materials_volume";class KHR_materials_volume{constructor(e){this.name=m,this._resource=e}loadAdditionTextures(e,r){let t=this._resource.data.materials,n=this._resource.data.textures;if(t&&n){let n=[];return t.forEach((t=>{var a;let s=null===(a=t.extensions)||void 0===a?void 0:a.KHR_materials_volume;if(s&&s.thicknessTexture){let t=!1,a=this._resource.loadTextureFromInfo(s.thicknessTexture,t,e,r);n.push(a)}})),Promise.all(n)}return Promise.resolve()}additionMaterialProperties(e,t){var n,a;let s=e.extensions.KHR_materials_volume;t.setDefine(r.PBRShaderLib.DEFINE_THICKNESS,!0);let o=null!==(n=s.thicknessFactor)&&void 0!==n?n:0,i=null!==(a=s.attenuationDistance)&&void 0!==a?a:65504;t.setFloat("u_VolumeThicknessFactor",o),t.setFloat("u_VolumeAttenuationDistance",i);let l=new r.Vector3(1,1,1);s.attenuationColor&&l.fromArray(s.attenuationColor),t.setVector3("u_VolumeAttenuationColor",l),s.thicknessTexture&&this._resource.setMaterialTextureProperty(t,s.thicknessTexture,"u_VolumeThicknessTexture",glTFShader.Define_VolumeThicknessMap,"u_VoluemThicknessMapTransform",glTFShader.Define_VolumeThicknessMapTransform)}}glTFResource.registerExtension(m,(e=>new KHR_materials_volume(e)));const p="KHR_materials_specular";class KHR_materials_specular{constructor(e){this.name=p,this._resource=e}loadAdditionTextures(e,r){let t=[],n=this._resource.data.materials,a=this._resource.data.textures;return n&&a&&n.forEach((n=>{var a;let s=null===(a=n.extensions)||void 0===a?void 0:a.KHR_materials_specular;if(s){if(s.specularTexture){let n=!1,a=this._resource.loadTextureFromInfo(s.specularTexture,n,e,r);t.push(a)}if(s.specularColorTexture){let n=!0,a=this._resource.loadTextureFromInfo(s.specularColorTexture,n,e,r);t.push(a)}}})),Promise.all(t)}additionMaterialProperties(e,t){var n;let a=e.extensions.KHR_materials_specular,s=null!==(n=a.specularFactor)&&void 0!==n?n:1,o=new r.Vector3(1,1,1);a.specularColorFactor&&o.fromArray(a.specularColorFactor),t.setDefine(r.Shader3D.getDefineByName("SPECULAR"),!0),t.setFloat("u_SpecularFactor",s),t.setVector3("u_SpecularColorFactor",o),a.specularTexture&&this._resource.setMaterialTextureProperty(t,a.specularTexture,"u_SpecularFactorTexture",glTFShader.Define_SpecularFactorMap,"u_SpecularFactorMapTransfrom",glTFShader.Define_SpecularFactorMapTransform),a.specularColorTexture&&this._resource.setMaterialTextureProperty(t,a.specularColorTexture,"u_SpecularColorTexture",glTFShader.Define_SpecularColorMap,"u_SpecularColorMapTransform",glTFShader.Define_SpecularColorMapTransform)}}glTFResource.registerExtension(p,(e=>new KHR_materials_specular(e)));const _="KHR_materials_unlit";class KHR_materials_unlit{constructor(e){this.name=_,this._resource=e}createMaterial(e){let t=new r.UnlitMaterial,n=e.pbrMetallicRoughness;if(n){if(n.baseColorFactor){let e=t.albedoColor;e.fromArray(n.baseColorFactor),e.toGamma(e),t.albedoColor=e}n.baseColorTexture&&(t.albedoTexture=this._resource.getTextureWithInfo(n.baseColorTexture))}return this._resource.applyMaterialRenderState(e,t),t}}glTFResource.registerExtension(_,(e=>new KHR_materials_unlit(e)));r.Loader.registerLoader(["gltf"],class{load(e){return e.loader.fetch(e.url,"json",e.progress.createCallback(.5),e.options).then((r=>{let t=new glTFResource;return t._parse(r,e.url,e.progress).then((()=>t))}))}});r.Loader.registerLoader(["glb"],class{load(e){return e.loader.fetch(e.url,"arraybuffer",e.progress.createCallback(.5),e.options).then((r=>{let t=new glTFResource;return t._parseglb(r,e.url,e.progress).then((()=>t))}))}}),e.KHR_materials_anisotropy=KHR_materials_anisotropy,e.KHR_materials_clearcoat=KHR_materials_clearcoat,e.KHR_materials_emissive_strength=KHR_materials_emissive_strength,e.KHR_materials_ior=KHR_materials_ior,e.KHR_materials_iridescence=KHR_materials_iridescence,e.KHR_materials_sheen=KHR_materials_sheen,e.KHR_materials_specular=KHR_materials_specular,e.KHR_materials_transmission=KHR_materials_transmission,e.KHR_materials_unlit=KHR_materials_unlit,e.KHR_materials_volume=KHR_materials_volume,e.KHR_texture_transform=KHR_texture_transform,e.glTFResource=glTFResource,e.glTFShader=glTFShader}(window.Laya=window.Laya||{},Laya);
//# sourceMappingURL=laya.gltf.js.map