{"version":3,"names":["ExternalSkin","source","this","_source","value","ILaya","loader","load","Loader","SPINE","then","templet","isCreateFromURL","items","_items","_templet","init","flush","target","skeletonData","_textures","i","length","o","attachmentStr","attachment","slot","skinStr","skin","skins","j","name","attachments","regionPage","region","page","texture","slotObj","getSkeleton","findSlot","setAttachment","ExternalSkinItem","_skin","_slot","_attachment","SpineTexture","constructor","tex","realTexture","getImage","width","_b","_a","sourceWidth","height","_d","_c","sourceHeight","setFilters","minFilter","magFilter","filterMode","spine","TextureFilter","Nearest","FilterMode","Point","Bilinear","bitmap","convertWrapMode","mode","TextureWrap","ClampToEdge","WrapMode","Clamp","MirroredRepeat","Mirrored","Repeat","setWraps","uWrap","vWrap","tex2D","wrapModeU","wrapModeV","SpineTemplet","Resource","super","ns","_ns","basePath","_basePath","getTexture","_parse","desc","atlasText","createURL","progress","parseAtlas","URL","getPath","getRuntimeVersion","startsWith","parseAtlas4","parseAtlas3","call","atlas","atlasLoader","AtlasAttachmentLoader","ArrayBuffer","skeletonBinary","SkeletonBinary","readSkeletonData","Uint8Array","skeletonJson","SkeletonJson","RuntimeVersion","atlasPages","TextureAtlas","path","push","url","createCallback","res","_addReference","spineTex","pages","map","setTexture","getAniNameByIndex","index","tAni","animations","getSkinIndexByName","skinName","tSkinData","n","_disposeResource","k","_removeReference","QUAD_TRIANGLES","SpineSkeletonRenderer","twoColorTint","vertexEffect","tempColor","Color","tempColor2","vertexSize","temp","Vector2","temp2","temp3","temp4","vertices","Utils","newFloatArray","renderable","numVertices","numFloats","clipper","SkeletonClipping","draw","skeleton","graphics","slotRangeStart","slotRangeEnd","premultipliedAlpha","tempPos","tempUv","tempLight","tempDark","uvs","triangles","drawOrder","attachmentColor","skeletonColor","color","inRange","clippedVertexSize","isClipping","data","clipEndWithSlot","getAttachment","RegionAttachment","computeWorldVertices","bone","renderObject","MeshAttachment","ClippingAttachment","clip","clipStart","mesh","worldVerticesLength","slotColor","finalColor","r","g","b","a","slotBlendMode","blendMode","clipTriangles","clippedVertices","Float32Array","clippedTriangles","mVertices","mUVs","colorNum","alpha","verts","v","x","y","set","transform","vi","Number","isFinite","drawTriangles","Uint16Array","Matrix","EMPTY","u","setFromColor","clipEnd","SpineSkeleton","Sprite","_currentPlayTime","_pause","_currAniName","_playbackRate","_playAudio","_soundChannelArr","trackIndex","_skinName","_animationName","_loop","externalSkins","_externalSkins","resetExternalSkin","_skeleton","Skeleton","_flushExtSkin","showSkinByName","animationName","play","loop","currentTime","_playStart","_playEnd","_duration","Error","_state","update","playState","PAUSED","PLAYING","STOPPED","reset","clear","_stateData","AnimationStateData","AnimationState","_renerer","_timeKeeper","TimeKeeper","skinIndex","showSkinByIndex","addListener","start","entry","interrupt","end","dispose","complete","event","Event","COMPLETE","eventData","audioValue","audioPath","floatValue","intValue","stringValue","time","balance","volume","LABEL","channel","SoundManager","playSound","Handler","create","_onAniSoundStoped","playbackRate","READY","LayaEnv","isPlaying","nameOrIndex","force","freshSkin","playAudio","setAnimation","trackEntry","getCurrent","animationStart","animationEnd","animationDuration","animation","duration","timer","frameLoop","_update","delta","apply","animationLast","Math","max","updateWorldTransform","getAnimNum","getSlotByName","slotName","newSkine","setSkin","setSlotsToSetupPose","stop","paused","len","isStopped","pause","resume","audioBuffer","splice","clearListeners","destroy","destroyChild","addAnimation","delay","setMix","fromNameOrIndex","toNameOrIndex","fromName","toName","getBoneByName","boneName","findBone","setSlotAttachment","attachmentName","registerLoader","task","atlasUrl","replaceFileExtension","Promise","all","fetch","ext","c","ClassUtils","regClass"],"sources":["../../src/layaAir/laya/spine/ExternalSkin.ts","../../src/layaAir/laya/spine/ExternalSkinItem.ts","../../src/layaAir/laya/spine/SpineTexture.ts","../../src/layaAir/laya/spine/SpineTemplet.ts","../../src/layaAir/laya/spine/SpineSkeletonRenderer.ts","../../src/layaAir/laya/spine/SpineSkeleton.ts","../../src/layaAir/laya/spine/SpineTempletLoader.ts","../../src/layaAir/laya/spine/ModuleDef.ts"],"sourcesContent":["import { ILaya } from \"../../ILaya\";\r\nimport { Loader } from \"../net/Loader\";\r\nimport { ExternalSkinItem } from \"./ExternalSkinItem\";\r\nimport { SpineSkeleton } from \"./SpineSkeleton\";\r\nimport { SpineTemplet } from \"./SpineTemplet\";\r\n\r\nexport class ExternalSkin {\r\n    protected _source: string;\r\n    protected _templet: SpineTemplet;\r\n    protected _items: ExternalSkinItem[];\r\n    target: SpineSkeleton;\r\n\r\n    get source(): string {\r\n        return this._source;\r\n    }\r\n\r\n    set source(value: string) {\r\n        this._source = value;\r\n        if (value) {\r\n            ILaya.loader.load(value, Loader.SPINE).then((templet: SpineTemplet) => {\r\n                if (!this._source || templet && !templet.isCreateFromURL(this._source))\r\n                    return;\r\n\r\n                this.templet = templet;\r\n            });\r\n        }\r\n        else\r\n            this.templet = null;\r\n    }\r\n\r\n    set items(value: ExternalSkinItem[]) {\r\n        this._items = value;\r\n    }\r\n    get items() {\r\n        return this._items;\r\n    }\r\n\r\n\r\n    /**\r\n    * 得到动画模板的引用\r\n    * @return templet\r\n    */\r\n    get templet(): SpineTemplet {\r\n        return this._templet;\r\n    }\r\n    set templet(value: SpineTemplet) {\r\n        this.init(value);\r\n    }\r\n    protected init(templet: SpineTemplet): void {\r\n        this._templet = templet;\r\n        if (!this._templet) {\r\n            return;\r\n        }\r\n        this.flush();\r\n    }\r\n    flush() {\r\n        if (this.target && this.target.templet && this._items && this._templet && this._templet.skeletonData) {\r\n            if (null == (this.target.templet as any)._textures) return;\r\n            for (let i = this._items.length - 1; i >= 0; i--) {\r\n                let o = this._items[i];\r\n                let attachmentStr = o.attachment;\r\n                let slot = o.slot;\r\n                let skinStr = o.skin;\r\n\r\n                if (attachmentStr && slot && skinStr) {\r\n                    let attachment: spine.Attachment = null;\r\n                    let skins = this._templet.skeletonData.skins;\r\n                    for (let j = skins.length - 1; j >= 0; j--) {\r\n                        if (skins[j].name == skinStr) {\r\n                            let skin = skins[j];\r\n                            let attachments = skin.attachments;\r\n                            for (let j = attachments.length - 1; j >= 0; j--) {\r\n                                attachment = attachments[j][attachmentStr];\r\n                                if (attachment) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (attachment) {\r\n                        let regionPage = (attachment as any).region.page;\r\n                        (this.target.templet as any)._textures[regionPage.name] = regionPage.texture;\r\n                        let slotObj = this.target.getSkeleton().findSlot(slot);\r\n                        if (slotObj) {\r\n                            slotObj.setAttachment(attachment);\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n}","export class ExternalSkinItem {\r\n    protected _skin: string;\r\n    protected _slot: string;\r\n    protected _attachment: string;\r\n\r\n    get skin() {\r\n        return this._skin;\r\n    }\r\n    set skin(value: string) {\r\n        this._skin = value;\r\n    }\r\n    set slot(value: string) {\r\n        this._slot = value;\r\n    }\r\n    get slot() {\r\n        return this._slot;\r\n    }\r\n    set attachment(value: string) {\r\n        this._attachment = value;\r\n    }\r\n    get attachment() {\r\n        return this._attachment;\r\n    }\r\n\r\n}","import { FilterMode } from \"../RenderEngine/RenderEnum/FilterMode\";\r\nimport { WrapMode } from \"../RenderEngine/RenderEnum/WrapMode\";\r\nimport { Texture } from \"../resource/Texture\";\r\nimport { Texture2D } from \"../resource/Texture2D\";\r\n\r\nexport class SpineTexture {\r\n    realTexture: Texture;\r\n\r\n    constructor(tex: Texture) {\r\n        this.realTexture = tex;\r\n    }\r\n\r\n    getImage(): Object {\r\n        return {\r\n            width: (this.realTexture?.sourceWidth) ?? 16,\r\n            height: (this.realTexture?.sourceHeight) ?? 16,\r\n        };\r\n    }\r\n\r\n    setFilters(minFilter: spine.TextureFilter, magFilter: spine.TextureFilter) {\r\n        if (!this.realTexture)\r\n            return;\r\n\r\n        let filterMode: number;\r\n        if (magFilter === spine.TextureFilter.Nearest)\r\n            filterMode = FilterMode.Point;\r\n        else\r\n            filterMode = FilterMode.Bilinear;\r\n        (<Texture2D>this.realTexture.bitmap).filterMode = filterMode;\r\n    }\r\n\r\n    convertWrapMode(mode: spine.TextureWrap) {\r\n        return mode == spine.TextureWrap.ClampToEdge ? WrapMode.Clamp : (mode == spine.TextureWrap.MirroredRepeat ? WrapMode.Mirrored : WrapMode.Repeat);\r\n    }\r\n\r\n    setWraps(uWrap: spine.TextureWrap, vWrap: spine.TextureWrap) {\r\n        if (!this.realTexture)\r\n            return;\r\n\r\n        let tex2D = <Texture2D>this.realTexture.bitmap;\r\n        tex2D.wrapModeU = this.convertWrapMode(uWrap);\r\n        tex2D.wrapModeV = this.convertWrapMode(vWrap);\r\n    }\r\n}","import { ILaya } from \"../../ILaya\";\r\nimport { Resource } from \"../resource/Resource\";\r\nimport { Texture } from \"../resource/Texture\";\r\nimport { URL } from \"../net/URL\";\r\nimport { ILoadURL } from \"../net/Loader\";\r\nimport { SpineTexture } from \"./SpineTexture\";\r\nimport { IBatchProgress } from \"../net/BatchProgress\";\r\n\r\n/**\r\n * Spine动画模板基类\r\n */\r\nexport class SpineTemplet extends Resource {\r\n    public static RuntimeVersion: string = \"3.8\";\r\n\r\n    public skeletonData: spine.SkeletonData;\r\n\r\n    private _textures: Record<string, SpineTexture>;\r\n    private _basePath: string;\r\n    private _ns: any;\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        this._textures = {};\r\n    }\r\n\r\n    get ns(): typeof spine {\r\n        return this._ns;\r\n    }\r\n\r\n    get basePath(): string {\r\n        return this._basePath;\r\n    }\r\n\r\n    getTexture(name: string): SpineTexture {\r\n        return this._textures[name];\r\n    }\r\n\r\n    _parse(desc: string | ArrayBuffer, atlasText: string, createURL: string, progress?: IBatchProgress): Promise<void> {\r\n        this._basePath = URL.getPath(createURL);\r\n        let version = this.getRuntimeVersion(desc);\r\n        let parseAtlas;\r\n        if (version.startsWith('4.'))\r\n            parseAtlas = this.parseAtlas4;\r\n        else\r\n            parseAtlas = this.parseAtlas3;\r\n\r\n        return parseAtlas.call(this, atlasText, progress).then((atlas: any) => {\r\n            let atlasLoader = new this._ns.AtlasAttachmentLoader(atlas);\r\n            if (desc instanceof ArrayBuffer) {\r\n                let skeletonBinary = new this._ns.SkeletonBinary(atlasLoader);\r\n                this.skeletonData = skeletonBinary.readSkeletonData(new Uint8Array(desc));\r\n            } else {\r\n                let skeletonJson = new this._ns.SkeletonJson(atlasLoader);\r\n                this.skeletonData = skeletonJson.readSkeletonData(desc);\r\n            }\r\n        });\r\n    }\r\n\r\n    private getRuntimeVersion(desc: string | ArrayBuffer): string {\r\n        this._ns = spine;\r\n        return SpineTemplet.RuntimeVersion;\r\n    }\r\n\r\n    private parseAtlas3(atlasText: string, progress?: IBatchProgress): Promise<spine.TextureAtlas> {\r\n        let atlasPages: Array<ILoadURL> = [];\r\n        new this._ns.TextureAtlas(atlasText, (path: string) => {\r\n            atlasPages.push({ url: this._basePath + path });\r\n            return new SpineTexture(null);\r\n        });\r\n        return ILaya.loader.load(atlasPages, null, progress?.createCallback()).then((res: Array<Texture>) => {\r\n            let i = 0;\r\n            let atlas = new this._ns.TextureAtlas(atlasText, (path: string) => {\r\n                let tex = res[i++];\r\n                if (tex)\r\n                    tex._addReference();\r\n                let spineTex = new SpineTexture(tex);\r\n                this._textures[path] = spineTex;\r\n                return spineTex;\r\n            });\r\n            return atlas;\r\n        });\r\n    }\r\n\r\n    private parseAtlas4(atlasText: string, progress?: IBatchProgress): Promise<spine.TextureAtlas> {\r\n        let atlas = new this._ns.TextureAtlas(atlasText);\r\n        return ILaya.loader.load(atlas.pages.map((page: spine.TextureAtlasPage) => this._basePath + page.name),\r\n            null, progress?.createCallback()).then((res: Array<Texture>) => {\r\n                let i = 0;\r\n                for (let page of atlas.pages) {\r\n                    let tex = res[i++];\r\n                    if (tex)\r\n                        tex._addReference();\r\n                    let spineTex = new SpineTexture(tex);\r\n                    this._textures[page.name] = spineTex;\r\n                    page.setTexture(spineTex);\r\n                }\r\n\r\n                return atlas;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * 通过索引得动画名称\r\n     * @param\tindex\r\n     * @return\r\n     */\r\n    getAniNameByIndex(index: number): string {\r\n        let tAni: any = this.skeletonData.animations[index];\r\n        if (tAni) return tAni.name;\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * 通过皮肤名字得到皮肤索引\r\n     * @param\tskinName 皮肤名称\r\n     * @return\r\n     */\r\n    getSkinIndexByName(skinName: string): number {\r\n        let skins = this.skeletonData.skins;\r\n        let tSkinData: spine.Skin;\r\n        for (let i: number = 0, n: number = skins.length; i < n; i++) {\r\n            tSkinData = skins[i];\r\n            if (tSkinData.name == skinName) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * 释放纹理\r\n     * @override\r\n     */\r\n    protected _disposeResource(): void {\r\n        for (let k in this._textures) {\r\n            this._textures[k].realTexture?._removeReference();\r\n        }\r\n    }\r\n}\r\n","import { Graphics } from \"../display/Graphics\";\r\nimport { Matrix } from \"../maths/Matrix\";\r\nimport { SpineTexture } from \"./SpineTexture\";\r\nimport { SpineTemplet } from \"./SpineTemplet\";\r\n\r\ninterface Renderable {\r\n    vertices: spine.ArrayLike<number>;\r\n    numVertices: number;\r\n    numFloats: number;\r\n}\r\n\r\nconst QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\r\n\r\nexport class SpineSkeletonRenderer {\r\n    premultipliedAlpha: boolean;\r\n    vertexEffect: spine.VertexEffect = null;\r\n    templet: SpineTemplet;\r\n\r\n    private tempColor = new spine.Color();\r\n    private tempColor2 = new spine.Color();\r\n    private vertices: ArrayLike<number>;\r\n    private vertexSize = 2 + 2 + 4;\r\n    private twoColorTint = false;\r\n    private renderable: Renderable;\r\n    private clipper: spine.SkeletonClipping;\r\n    private temp = new spine.Vector2();\r\n    private temp2 = new spine.Vector2();\r\n    private temp3 = new spine.Color();\r\n    private temp4 = new spine.Color();\r\n\r\n    constructor(templet: SpineTemplet, twoColorTint: boolean = true) {\r\n        this.twoColorTint = twoColorTint;\r\n        if (twoColorTint)\r\n            this.vertexSize += 4;\r\n        this.templet = templet;\r\n        this.vertices = templet.ns.Utils.newFloatArray(this.vertexSize * 1024);\r\n        this.renderable = { vertices: null, numVertices: 0, numFloats: 0 };\r\n        this.clipper = new templet.ns.SkeletonClipping();\r\n    }\r\n\r\n    draw(skeleton: spine.Skeleton, graphics: Graphics, slotRangeStart: number = -1, slotRangeEnd: number = -1) {\r\n        let clipper = this.clipper;\r\n        let premultipliedAlpha = this.premultipliedAlpha;\r\n        let twoColorTint = false;\r\n        let blendMode: spine.BlendMode = null;\r\n\r\n        let tempPos = this.temp;\r\n        let tempUv = this.temp2;\r\n        let tempLight = this.temp3;\r\n        let tempDark = this.temp4;\r\n\r\n        let renderable: Renderable = this.renderable;\r\n        let uvs: ArrayLike<number> = null;\r\n        let triangles: Array<number> = null;\r\n        let drawOrder = skeleton.drawOrder;\r\n        let attachmentColor: spine.Color = null;\r\n        let skeletonColor = skeleton.color;\r\n        let vertexSize = twoColorTint ? 12 : 8;\r\n        let inRange = false;\r\n\r\n        if (slotRangeStart == -1) inRange = true;\r\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\r\n            let clippedVertexSize = clipper.isClipping() ? 2 : vertexSize;\r\n            let slot = drawOrder[i];\r\n\r\n            if (slotRangeStart >= 0 && slotRangeStart == slot.data.index) {\r\n                inRange = true;\r\n            }\r\n\r\n            if (!inRange) {\r\n                clipper.clipEndWithSlot(slot);\r\n                continue;\r\n            }\r\n\r\n            if (slotRangeEnd >= 0 && slotRangeEnd == slot.data.index) {\r\n                inRange = false;\r\n            }\r\n\r\n            let attachment = slot.getAttachment();\r\n            let name: string = null;\r\n            let texture: SpineTexture;\r\n            if (attachment instanceof this.templet.ns.RegionAttachment) {\r\n                let region = <spine.RegionAttachment>attachment;\r\n                renderable.vertices = this.vertices;\r\n                renderable.numVertices = 4;\r\n                renderable.numFloats = clippedVertexSize << 2;\r\n                if (\"4.1\" == SpineTemplet.RuntimeVersion) {\r\n                    region.computeWorldVertices(slot as any, renderable.vertices, 0, clippedVertexSize);\r\n                } else {\r\n                    region.computeWorldVertices(slot.bone, renderable.vertices, 0, clippedVertexSize);\r\n                }\r\n                triangles = QUAD_TRIANGLES;\r\n                uvs = region.uvs;\r\n                if (\"4.1\" == SpineTemplet.RuntimeVersion) {\r\n                    name = (region.region as any).page.name;\r\n                } else {\r\n                    name = region.region.renderObject.page.name;\r\n                }\r\n                texture = this.templet.getTexture(name);\r\n                attachmentColor = region.color;\r\n            } else if (attachment instanceof this.templet.ns.MeshAttachment) {\r\n                let mesh = <spine.MeshAttachment>attachment;\r\n                renderable.vertices = this.vertices;\r\n                renderable.numVertices = (mesh.worldVerticesLength >> 1);\r\n                renderable.numFloats = renderable.numVertices * clippedVertexSize;\r\n                if (renderable.numFloats > renderable.vertices.length) {\r\n                    renderable.vertices = this.vertices = this.templet.ns.Utils.newFloatArray(renderable.numFloats);\r\n                }\r\n                mesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, renderable.vertices, 0, clippedVertexSize);\r\n                triangles = mesh.triangles;\r\n                if (\"4.1\" == SpineTemplet.RuntimeVersion) {\r\n                    name = (mesh.region as any).page.name;\r\n                } else {\r\n                    name = mesh.region.renderObject.page.name;\r\n                }\r\n                texture = this.templet.getTexture(name);\r\n                uvs = mesh.uvs;\r\n                attachmentColor = mesh.color;\r\n            } else if (attachment instanceof this.templet.ns.ClippingAttachment) {\r\n                let clip = <spine.ClippingAttachment>(attachment);\r\n                clipper.clipStart(slot, clip);\r\n                continue;\r\n            } else {\r\n                clipper.clipEndWithSlot(slot);\r\n                continue;\r\n            }\r\n\r\n            if (texture != null) {\r\n                let slotColor = slot.color;\r\n                let finalColor = this.tempColor;\r\n                finalColor.r = skeletonColor.r * slotColor.r * attachmentColor.r;\r\n                finalColor.g = skeletonColor.g * slotColor.g * attachmentColor.g;\r\n                finalColor.b = skeletonColor.b * slotColor.b * attachmentColor.b;\r\n                finalColor.a = skeletonColor.a * slotColor.a * attachmentColor.a;\r\n                if (premultipliedAlpha) {\r\n                    finalColor.r *= finalColor.a;\r\n                    finalColor.g *= finalColor.a;\r\n                    finalColor.b *= finalColor.a;\r\n                }\r\n\r\n                let slotBlendMode = slot.data.blendMode;\r\n                if (slotBlendMode != blendMode) {\r\n                    blendMode = slotBlendMode;\r\n                }\r\n\r\n                if (clipper.isClipping()) {\r\n                    clipper.clipTriangles(renderable.vertices, renderable.numFloats, triangles, triangles.length, uvs, finalColor, null, twoColorTint);\r\n                    let clippedVertices = new Float32Array(clipper.clippedVertices);\r\n                    let clippedTriangles = clipper.clippedTriangles;\r\n                    let mVertices = [];\r\n                    let mUVs = [];\r\n                    let colorNum = 0xffffff;\r\n                    let alpha = 1;\r\n                    if (this.vertexEffect != null) {\r\n                        let vertexEffect = this.vertexEffect;\r\n                        let verts = clippedVertices;\r\n                        if (!twoColorTint) {\r\n                            for (let v = 0, n = clippedVertices.length; v < n; v += vertexSize) {\r\n                                tempPos.x = verts[v];\r\n                                tempPos.y = verts[v + 1];\r\n                                tempLight.set(verts[v + 2], verts[v + 3], verts[v + 4], verts[v + 5]);\r\n                                tempUv.x = verts[v + 6];\r\n                                tempUv.y = verts[v + 7];\r\n                                tempDark.set(0, 0, 0, 0);\r\n                                vertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\r\n                                verts[v] = tempPos.x;\r\n                                verts[v + 1] = tempPos.y;\r\n                                verts[v + 2] = tempLight.r;\r\n                                verts[v + 3] = tempLight.g;\r\n                                verts[v + 4] = tempLight.b;\r\n                                verts[v + 5] = tempLight.a;\r\n                                verts[v + 6] = tempUv.x;\r\n                                verts[v + 7] = tempUv.y\r\n\r\n                                mVertices.push(verts[v], -verts[v + 1]);\r\n                                colorNum = (verts[v + 2] * 255 << 16) + (verts[v + 3] * 255 << 8) + verts[v + 4];\r\n                                alpha = verts[v + 5];\r\n                                mUVs.push(verts[v + 6], verts[v + 7]);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        let vi = 0;\r\n                        while (Number.isFinite(clippedVertices[vi + 6]) && Number.isFinite(clippedVertices[vi + 7])) {\r\n                            mVertices.push(clippedVertices[vi]);\r\n                            mVertices.push(-clippedVertices[vi + 1]);\r\n                            colorNum = (clippedVertices[vi + 2] * 255 << 16) + (clippedVertices[vi + 3] * 255 << 8) + clippedVertices[vi + 4] * 255;\r\n                            alpha = clippedVertices[vi + 5];\r\n                            mUVs.push(clippedVertices[vi + 6]);\r\n                            mUVs.push(clippedVertices[vi + 7]);\r\n                            vi += this.vertexSize;\r\n                        }\r\n                    }\r\n                    let blendMode;\r\n                    switch (slotBlendMode) {\r\n                        case 1:\r\n                            blendMode = \"light\";\r\n                            break;\r\n                        case 2:\r\n                            blendMode = \"multiply\";\r\n                            break;\r\n                        case 3:\r\n                            blendMode = \"screen\";\r\n                            break;\r\n                        default:\r\n                            blendMode = \"normal\";\r\n                    }\r\n                    graphics.drawTriangles(texture.realTexture, 0, 0, <any>mVertices, <any>mUVs, new Uint16Array(clippedTriangles), Matrix.EMPTY, alpha, colorNum, blendMode);\r\n                } else {\r\n                    let verts = renderable.vertices;\r\n                    let mVertices = [];\r\n                    let mUVs = [];\r\n                    let colorNum = 0xffffff;\r\n                    let alpha = 1;\r\n                    if (this.vertexEffect != null) {\r\n                        let vertexEffect = this.vertexEffect;\r\n                        if (!twoColorTint) {\r\n                            for (let v = 0, u = 0, n = renderable.numFloats; v < n; v += vertexSize, u += 2) {\r\n                                tempPos.x = verts[v];\r\n                                tempPos.y = verts[v + 1];\r\n                                tempUv.x = uvs[u];\r\n                                tempUv.y = uvs[u + 1]\r\n                                tempLight.setFromColor(finalColor);\r\n                                tempDark.set(0, 0, 0, 0);\r\n                                vertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\r\n                                verts[v] = tempPos.x;\r\n                                verts[v + 1] = tempPos.y;\r\n                                verts[v + 2] = tempLight.r;\r\n                                verts[v + 3] = tempLight.g;\r\n                                verts[v + 4] = tempLight.b;\r\n                                verts[v + 5] = tempLight.a;\r\n                                verts[v + 6] = tempUv.x;\r\n                                verts[v + 7] = tempUv.y\r\n\r\n                                mVertices.push(verts[v], -verts[v + 1]);\r\n                                colorNum = (verts[v + 2] * 255 << 16) + (verts[v + 3] * 255 << 8) + verts[v + 4] * 255;\r\n                                alpha = verts[v + 5];\r\n                                mUVs.push(verts[v + 6], verts[v + 7]);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (!twoColorTint) {\r\n                            for (let v = 2, u = 0, n = renderable.numFloats; v < n; v += vertexSize, u += 2) {\r\n                                verts[v] = finalColor.r;\r\n                                verts[v + 1] = finalColor.g;\r\n                                verts[v + 2] = finalColor.b;\r\n                                verts[v + 3] = finalColor.a;\r\n                                verts[v + 4] = uvs[u];\r\n                                verts[v + 5] = uvs[u + 1];\r\n\r\n                                mVertices.push(verts[v - 2], -verts[v - 1]);\r\n                                colorNum = (verts[v] * 255 << 16) + (verts[v + 1] * 255 << 8) + verts[v + 2] * 255;\r\n                                alpha = verts[v + 3];\r\n                                mUVs.push(verts[v + 4], verts[v + 5]);\r\n                            }\r\n                        }\r\n                    }\r\n                    let blendMode;\r\n                    switch (slotBlendMode) {\r\n                        case 1:\r\n                            blendMode = \"light\";\r\n                            break;\r\n                        case 2:\r\n                            blendMode = \"multiply\";\r\n                            break;\r\n                        case 3:\r\n                            blendMode = \"screen\";\r\n                            break;\r\n                        default:\r\n                            blendMode = \"normal\";\r\n                    }\r\n                    graphics.drawTriangles(texture.realTexture, 0, 0, <any>mVertices, <any>mUVs, new Uint16Array(triangles), Matrix.EMPTY, alpha, colorNum, blendMode);\r\n                }\r\n            }\r\n\r\n            clipper.clipEndWithSlot(slot);\r\n        }\r\n        clipper.clipEnd();\r\n    }\r\n}\r\n","import { ILaya } from \"../../ILaya\";\r\nimport { LayaEnv } from \"../../LayaEnv\";\r\nimport { Sprite } from \"../display/Sprite\";\r\nimport { Event } from \"../events/Event\";\r\nimport { SoundChannel } from \"../media/SoundChannel\";\r\nimport { SoundManager } from \"../media/SoundManager\";\r\nimport { Loader } from \"../net/Loader\";\r\nimport { Handler } from \"../utils/Handler\";\r\nimport { ExternalSkin } from \"./ExternalSkin\";\r\nimport { SpineSkeletonRenderer } from \"./SpineSkeletonRenderer\";\r\nimport { SpineTemplet } from \"./SpineTemplet\";\r\n\r\n/**动画开始播放调度\r\n * @eventType Event.PLAYED\r\n * */\r\n/*[Event(name = \"played\", type = \"laya.events.Event.PLAYED\", desc = \"动画开始播放调度\")]*/\r\n/**动画停止播放调度\r\n * @eventType Event.STOPPED\r\n * */\r\n/*[Event(name = \"stopped\", type = \"laya.events.Event.STOPPED\", desc = \"动画停止播放调度\")]*/\r\n/**动画暂停播放调度\r\n * @eventType Event.PAUSED\r\n * */\r\n/*[Event(name = \"paused\", type = \"laya.events.Event.PAUSED\", desc = \"动画暂停播放调度\")]*/\r\n/**自定义事件。\r\n * @eventType Event.LABEL\r\n */\r\n/*[Event(name = \"label\", type = \"laya.events.Event.LABEL\", desc = \"自定义事件\")]*/\r\n/**\r\n * spine动画由<code>SpineTemplet</code>，<code>SpineSkeletonRender</code>，<code>SpineSkeleton</code>三部分组成。\r\n */\r\nexport class SpineSkeleton extends Sprite {\r\n    static readonly STOPPED: number = 0;\r\n    static readonly PAUSED: number = 1;\r\n    static readonly PLAYING: number = 2;\r\n\r\n    protected _source: string;\r\n    protected _templet: SpineTemplet;\r\n    protected _timeKeeper: spine.TimeKeeper;\r\n    protected _skeleton: spine.Skeleton;\r\n    protected _state: spine.AnimationState;\r\n    protected _stateData: spine.AnimationStateData;\r\n    protected _currentPlayTime: number = 0;\r\n    protected _renerer: SpineSkeletonRenderer;\r\n\r\n    /** @internal */\r\n    private _pause: boolean = true;\r\n    /** @internal */\r\n    private _currAniName: string = null;\r\n    /** @internal 动画播放的起始时间位置*/\r\n    private _playStart: number;\r\n    /** @internal 动画播放的结束时间位置*/\r\n    private _playEnd: number;\r\n    /** @internal 动画的总时间*/\r\n    private _duration: number;\r\n    /** 播放速率*/\r\n    private _playbackRate: number = 1.0;\r\n    /** @internal */\r\n    private _playAudio: boolean = true;\r\n    /** @internal */\r\n    private _soundChannelArr: any[] = [];\r\n    // 播放轨道索引\r\n    private trackIndex: number = 0;\r\n\r\n    private _skinName: string = \"default\";\r\n    private _animationName: string = \"\";\r\n    private _loop: boolean = true;\r\n\r\n    private _externalSkins: ExternalSkin[];\r\n\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    get externalSkins() {\r\n        return this._externalSkins;\r\n    }\r\n    set externalSkins(value: ExternalSkin[]) {\r\n        if (value) {\r\n            for (let i = value.length - 1; i >= 0; i--) {\r\n                value[i].target = this;\r\n            }\r\n        }\r\n        this._externalSkins = value;\r\n    }\r\n    /**\r\n     * 重置外部加载的皮肤的样式\r\n     */\r\n    resetExternalSkin() {\r\n        if (this._skeleton) {\r\n            this._skeleton = new this._templet.ns.Skeleton(this._templet.skeletonData);\r\n            this._flushExtSkin();\r\n        }\r\n    }\r\n\r\n    get source(): string {\r\n        return this._source;\r\n    }\r\n\r\n    set source(value: string) {\r\n        this._source = value;\r\n\r\n        if (value) {\r\n            ILaya.loader.load(value, Loader.SPINE).then((templet: SpineTemplet) => {\r\n                if (!this._source || templet && !templet.isCreateFromURL(this._source))\r\n                    return;\r\n\r\n                this.templet = templet;\r\n            });\r\n        }\r\n        else\r\n            this.templet = null;\r\n    }\r\n\r\n    get skinName(): string {\r\n        return this._skinName;\r\n    }\r\n\r\n    set skinName(value: string) {\r\n        this._skinName = value;\r\n        if (this._templet)\r\n            this.showSkinByName(value);\r\n    }\r\n\r\n    get animationName(): string {\r\n        return this._animationName;\r\n    }\r\n\r\n    set animationName(value: string) {\r\n        this._animationName = value;\r\n        if (this._templet)\r\n            this.play(value, this._loop, true);\r\n    }\r\n\r\n    get loop(): boolean {\r\n        return this._loop;\r\n    }\r\n\r\n    set loop(value: boolean) {\r\n        this._loop = value;\r\n        if (this._templet)\r\n            this.play(this._animationName, this._loop, true);\r\n    }\r\n\r\n    /**\r\n     * 得到动画模板的引用\r\n     * @return templet\r\n     */\r\n    get templet(): SpineTemplet {\r\n        return this._templet;\r\n    }\r\n\r\n    /**\r\n     * \r\n     */\r\n    set templet(value: SpineTemplet) {\r\n        this.init(value);\r\n    }\r\n\r\n    /**\r\n     * 设置当前播放位置\r\n     * @param\tvalue 当前时间\r\n     */\r\n    set currentTime(value: number) {\r\n        if (!this._currAniName || !this._templet)\r\n            return;\r\n\r\n        value /= 1000;\r\n        if (value < this._playStart || (!!this._playEnd && value > this._playEnd) || value > this._duration)\r\n            throw new Error(\"AnimationPlayer: value must large than playStartTime,small than playEndTime.\");\r\n\r\n        this._state.update(value - this._currentPlayTime);\r\n        this._currentPlayTime = value;\r\n    }\r\n\r\n    /**\r\n     * 获取当前播放状态\r\n     * @return\t当前播放状态\r\n     */\r\n    get playState(): number {\r\n        if (!this._currAniName)\r\n            return SpineSkeleton.STOPPED;\r\n        if (this._pause)\r\n            return SpineSkeleton.PAUSED;\r\n        return SpineSkeleton.PLAYING;\r\n    }\r\n\r\n    protected init(templet: SpineTemplet): void {\r\n        if (this._templet) {\r\n            this.reset();\r\n            this.graphics.clear();\r\n        }\r\n\r\n        this._templet = templet;\r\n        if (!this._templet)\r\n            return;\r\n\r\n        this._templet._addReference();\r\n        this._skeleton = new templet.ns.Skeleton(this._templet.skeletonData);\r\n        this._stateData = new templet.ns.AnimationStateData(this._skeleton.data);\r\n        // 动画状态类\r\n        this._state = new templet.ns.AnimationState(this._stateData);\r\n        this._renerer = new SpineSkeletonRenderer(templet, false);\r\n        this._timeKeeper = new templet.ns.TimeKeeper();\r\n\r\n        let skinIndex = this._templet.getSkinIndexByName(this._skinName);\r\n        if (skinIndex != -1)\r\n            this.showSkinByIndex(skinIndex);\r\n\r\n        this._state.addListener({\r\n            start: (entry: any) => {\r\n                // console.log(\"started:\", entry);\r\n            },\r\n            interrupt: (entry: any) => {\r\n                // console.log(\"interrupt:\", entry);\r\n            },\r\n            end: (entry: any) => {\r\n                // console.log(\"end:\", entry);\r\n            },\r\n            dispose: (entry: any) => {\r\n                // console.log(\"dispose:\", entry);\r\n            },\r\n            complete: (entry: any) => {\r\n                // console.log(\"complete:\", entry);\r\n                if (entry.loop) { // 如果多次播放,发送complete事件\r\n                    this.event(Event.COMPLETE);\r\n                } else { // 如果只播放一次，就发送stop事件\r\n                    this._currAniName = null;\r\n                    this.event(Event.STOPPED);\r\n                }\r\n            },\r\n            event: (entry: any, event: any) => {\r\n                let eventData = {\r\n                    audioValue: event.data.audioPath,\r\n                    audioPath: event.data.audioPath,\r\n                    floatValue: event.floatValue,\r\n                    intValue: event.intValue,\r\n                    name: event.data.name,\r\n                    stringValue: event.stringValue,\r\n                    time: event.time * 1000,\r\n                    balance: event.balance,\r\n                    volume: event.volume\r\n                };\r\n                // console.log(\"event:\", entry, event);\r\n                this.event(Event.LABEL, eventData);\r\n                if (this._playAudio && eventData.audioValue) {\r\n                    let channel = SoundManager.playSound(templet.basePath + eventData.audioValue, 1, Handler.create(this, this._onAniSoundStoped), null, (this._currentPlayTime * 1000 - eventData.time) / 1000);\r\n                    SoundManager.playbackRate = this._playbackRate;\r\n                    channel && this._soundChannelArr.push(channel);\r\n                }\r\n            },\r\n        });\r\n        this._flushExtSkin();\r\n        this.event(Event.READY);\r\n\r\n        if (LayaEnv.isPlaying && this._animationName)\r\n            this.play(this._animationName, this._loop, true);\r\n    }\r\n\r\n    /**\r\n     * 播放动画\r\n     *\r\n     * @param\tnameOrIndex\t动画名字或者索引\r\n     * @param\tloop\t\t是否循环播放\r\n     * @param\tforce\t\tfalse,如果要播的动画跟上一个相同就不生效,true,强制生效\r\n     * @param\tstart\t\t起始时间\r\n     * @param\tend\t\t\t结束时间\r\n     * @param\tfreshSkin\t是否刷新皮肤数据\r\n     * @param\tplayAudio\t是否播放音频\r\n     */\r\n    play(nameOrIndex: any, loop: boolean, force: boolean = true, start: number = 0, end: number = 0, freshSkin: boolean = true, playAudio: boolean = true) {\r\n        this._playAudio = playAudio;\r\n        start /= 1000;\r\n        end /= 1000;\r\n        let animationName = nameOrIndex;\r\n        if (start < 0 || end < 0)\r\n            throw new Error(\"SpineSkeleton: start and end must large than zero.\");\r\n        if ((end !== 0) && (start > end))\r\n            throw new Error(\"SpineSkeleton: start must less than end.\");\r\n\r\n        if (typeof animationName == \"number\") {\r\n            animationName = this.getAniNameByIndex(nameOrIndex);\r\n        }\r\n\r\n        if (force || this._pause || this._currAniName != animationName) {\r\n            this._currAniName = animationName;\r\n            // 设置执行哪个动画\r\n            this._state.setAnimation(this.trackIndex, animationName, loop);\r\n            // 设置起始和结束时间\r\n            let trackEntry = this._state.getCurrent(this.trackIndex);\r\n            trackEntry.animationStart = start;\r\n            if (!!end && end < trackEntry.animationEnd)\r\n                trackEntry.animationEnd = end;\r\n\r\n            let animationDuration = trackEntry.animation.duration;\r\n            this._duration = animationDuration;\r\n            this._playStart = start;\r\n            this._playEnd = end <= animationDuration ? end : animationDuration;\r\n\r\n            if (this._pause) {\r\n                this._pause = false;\r\n                this.timer.frameLoop(1, this, this._update, null, true);\r\n            }\r\n            this._update();\r\n        }\r\n    }\r\n\r\n    private _update(): void {\r\n        this._timeKeeper.update();\r\n        let delta = this._timeKeeper.delta * this._playbackRate;\r\n        let trackEntry = this._state.getCurrent(this.trackIndex);\r\n        // 在游戏循环中，update被调用，这样AnimationState就可以跟踪时间\r\n        this._state.update(delta);\r\n        // 使用当前动画和事件设置骨架\r\n        this._state.apply(this._skeleton);\r\n\r\n        let animationLast = trackEntry.animationLast;\r\n        this._currentPlayTime = Math.max(0, animationLast);\r\n\r\n        // spine在state.apply中发送事件，开发者可能会在事件中进行destory等操作，导致无法继续执行\r\n        if (!this._state || !this._skeleton) {\r\n            return;\r\n        }\r\n        // 计算骨骼的世界SRT(world SRT)\r\n        this._skeleton.updateWorldTransform();\r\n\r\n        this.graphics.clear();\r\n        this._renerer.draw(this._skeleton, this.graphics, -1, -1);\r\n    }\r\n\r\n    private _flushExtSkin() {\r\n        if (null == this._skeleton) return;\r\n        let skins = this._externalSkins;\r\n        if (skins) {\r\n            for (let i = skins.length - 1; i >= 0; i--) {\r\n                skins[i].flush();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 得到当前动画的数量\r\n     * @return 当前动画的数量\r\n     */\r\n    getAnimNum(): number {\r\n        return this._templet.skeletonData.animations.length;\r\n    }\r\n\r\n    /**\r\n     * 得到指定动画的名字\r\n     * @param\tindex\t动画的索引\r\n     */\r\n    getAniNameByIndex(index: number): string {\r\n        return this._templet.getAniNameByIndex(index);\r\n    }\r\n\r\n    /**\r\n     * 通过名字得到插槽的引用\r\n     * @param slotName \r\n     */\r\n    getSlotByName(slotName: string) {\r\n        return this._skeleton.findSlot(slotName)\r\n    }\r\n\r\n    /**\r\n     * 设置动画播放速率\r\n     * @param\tvalue\t1为标准速率\r\n     */\r\n    playbackRate(value: number): void {\r\n        this._playbackRate = value;\r\n    }\r\n\r\n    /**\r\n     * 通过名字显示一套皮肤\r\n     * @param\tname\t皮肤的名字\r\n     */\r\n    showSkinByName(name: string): void {\r\n        this.showSkinByIndex(this._templet.getSkinIndexByName(name));\r\n    }\r\n\r\n    /**\r\n     * 通过索引显示一套皮肤\r\n     * @param\tskinIndex\t皮肤索引\r\n     */\r\n    showSkinByIndex(skinIndex: number): void {\r\n        let newSkine = this._skeleton.data.skins[skinIndex];\r\n        this._skeleton.setSkin(newSkine);\r\n        this._skeleton.setSlotsToSetupPose();\r\n    }\r\n\r\n    /**\r\n     * 停止动画\r\n     */\r\n    stop(): void {\r\n        if (!this._pause) {\r\n            this._pause = true;\r\n            this._currAniName = null;\r\n            this.timer.clear(this, this._update);\r\n            this._state.update(-this._currentPlayTime);\r\n            this._currentPlayTime = 0;\r\n            this.event(Event.STOPPED);\r\n\r\n            if (this._soundChannelArr.length > 0) { // 有正在播放的声音\r\n                this._onAniSoundStoped(true);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 暂停动画的播放\r\n     */\r\n    paused(): void {\r\n        if (!this._pause) {\r\n            this._pause = true;\r\n            this.timer.clear(this, this._update);\r\n            this.event(Event.PAUSED);\r\n            if (this._soundChannelArr.length > 0) { // 有正在播放的声音\r\n                for (let len = this._soundChannelArr.length, i = 0; i < len; i++) {\r\n                    let channel = this._soundChannelArr[i];\r\n                    if (!channel.isStopped) {\r\n                        channel.pause();\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 恢复动画的播放\r\n     */\r\n    resume(): void {\r\n        if (this._pause) {\r\n            this._pause = false;\r\n            this.timer.frameLoop(1, this, this._update, null, true);\r\n            if (this._soundChannelArr.length > 0) { // 有正在播放的声音\r\n                for (let len = this._soundChannelArr.length, i = 0; i < len; i++) {\r\n                    let channel = this._soundChannelArr[i];\r\n                    if ((channel as any).audioBuffer) {\r\n                        channel.resume();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 清掉播放完成的音频\r\n     * @param force 是否强制删掉所有的声音channel\r\n     */\r\n    private _onAniSoundStoped(force: boolean): void {\r\n        for (let len = this._soundChannelArr.length, i = 0; i < len; i++) {\r\n            let channel = this._soundChannelArr[i];\r\n            if (channel.isStopped || force) {\r\n                !channel.isStopped && channel.stop();\r\n                this._soundChannelArr.splice(i, 1);\r\n                // SoundManager.removeChannel(_channel); // TODO 是否需要? 去掉有什么好处? 是否还需要其他操作?\r\n                len--; i--;\r\n            }\r\n        }\r\n    }\r\n\r\n    private reset() {\r\n        this._templet._removeReference(1);\r\n        this._templet = null;\r\n        this._timeKeeper = null;\r\n        this._skeleton = null;\r\n        this._state.clearListeners();\r\n        this._state = null;\r\n        this._renerer = null;\r\n        this._currAniName = null;\r\n        this._pause = true;\r\n        this.timer.clear(this, this._update);\r\n        if (this._soundChannelArr.length > 0)\r\n            this._onAniSoundStoped(true);\r\n    }\r\n\r\n    /**\r\n     * 销毁当前动画\r\n     * @override\r\n     */\r\n    destroy(destroyChild: boolean = true): void {\r\n        super.destroy(destroyChild);\r\n        if (this._templet)\r\n            this.reset();\r\n    }\r\n\r\n    // ------------------------------------新增加的接口----------------------------------------------------\r\n    /**\r\n     * 添加一个动画\r\n     * @param nameOrIndex   动画名字或者索引\r\n     * @param loop          是否循环播放\r\n     * @param delay         延迟调用，可以为负数\r\n     */\r\n    addAnimation(nameOrIndex: any, loop: boolean = false, delay: number = 0) {\r\n        delay /= 1000;\r\n        let animationName = nameOrIndex;\r\n        if (typeof animationName == \"number\") {\r\n            animationName = this.getAniNameByIndex(animationName);\r\n        }\r\n        this._currAniName = animationName;\r\n        this._state.addAnimation(this.trackIndex, animationName, loop, delay);\r\n    }\r\n\r\n    /**\r\n     * 设置当动画被改变时，存储混合(交叉淡出)的持续时间\r\n     * @param fromNameOrIndex \r\n     * @param toNameOrIndex \r\n     * @param duration\r\n     */\r\n    setMix(fromNameOrIndex: any, toNameOrIndex: any, duration: number) {\r\n        duration /= 1000;\r\n        let fromName = fromNameOrIndex;\r\n        if (typeof fromName == \"number\") {\r\n            fromName = this.getAniNameByIndex(fromName);\r\n        }\r\n        let toName = toNameOrIndex;\r\n        if (typeof toName == \"number\") {\r\n            toName = this.getAniNameByIndex(toName);\r\n        }\r\n        this._stateData.setMix(fromName, toName, duration);\r\n    }\r\n\r\n    /**\r\n     * 获取骨骼信息(spine.Bone)\r\n     * 注意: 获取到的是spine运行时的骨骼信息(spine.Bone)，不适用引擎的方法\r\n     * @param boneName \r\n     */\r\n    getBoneByName(boneName: string) {\r\n        return this._skeleton.findBone(boneName);\r\n    }\r\n\r\n    /**\r\n     * 获取Skeleton(spine.Skeleton)\r\n     */\r\n    getSkeleton() {\r\n        return this._skeleton;\r\n    }\r\n\r\n    /**\r\n     * 替换插槽皮肤\r\n     * @param slotName \r\n     * @param attachmentName \r\n     */\r\n    setSlotAttachment(slotName: string, attachmentName: string) {\r\n        this._skeleton.setAttachment(slotName, attachmentName);\r\n    }\r\n}","import { IResourceLoader, ILoadTask, Loader } from \"../net/Loader\";\r\nimport { Utils } from \"../utils/Utils\";\r\nimport { SpineTemplet } from \"./SpineTemplet\";\r\n\r\nclass SpineTempletLoader implements IResourceLoader {\r\n    load(task: ILoadTask) {\r\n        let atlasUrl = Utils.replaceFileExtension(task.url, \"atlas\");\r\n\r\n        return Promise.all([\r\n            task.loader.fetch(task.url, task.ext == \"skel\" ? \"arraybuffer\" : \"json\", task.progress.createCallback()),\r\n            task.loader.fetch(atlasUrl, \"text\", task.progress.createCallback())\r\n        ]).then(res => {\r\n            if (!res[0] || !res[1])\r\n                return null;\r\n\r\n            let templet = new SpineTemplet();\r\n            return templet._parse(res[0], res[1], task.url, task.progress).then(() => templet);\r\n        });\r\n    }\r\n}\r\n\r\nLoader.registerLoader([\"skel\"], SpineTempletLoader, Loader.SPINE);","import { ClassUtils } from \"../utils/ClassUtils\";\r\nimport { ExternalSkin } from \"./ExternalSkin\";\r\nimport { ExternalSkinItem } from \"./ExternalSkinItem\";\r\nimport { SpineSkeleton } from \"./SpineSkeleton\";\r\nimport \"./SpineTempletLoader\";\r\n\r\nlet c = ClassUtils.regClass;\r\n\r\nc(\"SpineSkeleton\", SpineSkeleton);\r\nc(\"ExternalSkin\", ExternalSkin);\r\nc(\"ExternalSkinItem\", ExternalSkinItem);"],"mappings":"kCAMaA,aAMLC,aACA,OAAOC,KAAKC,O,CAGZF,WAAOG,GACPF,KAAKC,QAAUC,EACXA,EACAC,QAAMC,OAAOC,KAAKH,EAAOI,SAAOC,OAAOC,MAAMC,KACpCT,KAAKC,SAAWQ,IAAYA,EAAQC,gBAAgBV,KAAKC,WAG9DD,KAAKS,QAAUA,EAAO,IAI1BT,KAAKS,QAAU,I,CAGnBE,UAAMT,GACNF,KAAKY,OAASV,C,CAEdS,YACA,OAAOX,KAAKY,M,CAQZH,cACA,OAAOT,KAAKa,Q,CAEZJ,YAAQP,GACRF,KAAKc,KAAKZ,E,CAEJY,KAAKL,GACXT,KAAKa,SAAWJ,EACXT,KAAKa,UAGVb,KAAKe,O,CAETA,QACI,GAAIf,KAAKgB,QAAUhB,KAAKgB,OAAOP,SAAWT,KAAKY,QAAUZ,KAAKa,UAAYb,KAAKa,SAASI,aAAc,CAClG,GAAI,MAASjB,KAAKgB,OAAOP,QAAgBS,UAAW,OACpD,IAAK,IAAIC,EAAInB,KAAKY,OAAOQ,OAAS,EAAGD,GAAK,EAAGA,IAAK,CAC9C,IAAIE,EAAIrB,KAAKY,OAAOO,GAChBG,EAAgBD,EAAEE,WAClBC,EAAOH,EAAEG,KACTC,EAAUJ,EAAEK,KAEhB,GAAIJ,GAAiBE,GAAQC,EAAS,CAClC,IAAIF,EAA+B,KAC/BI,EAAQ3B,KAAKa,SAASI,aAAaU,MACvC,IAAK,IAAIC,EAAID,EAAMP,OAAS,EAAGQ,GAAK,EAAGA,IACnC,GAAID,EAAMC,GAAGC,MAAQJ,EAAS,CAC1B,IACIK,EADOH,EAAMC,GACME,YACvB,IAAK,IAAIF,EAAIE,EAAYV,OAAS,EAAGQ,GAAK,IACtCL,EAAaO,EAAYF,GAAGN,IACxBC,GAFqCK,KAM7C,KACH,CAEL,GAAIL,EAAY,CACZ,IAAIQ,EAAcR,EAAmBS,OAAOC,KAC3CjC,KAAKgB,OAAOP,QAAgBS,UAAUa,EAAWF,MAAQE,EAAWG,QACrE,IAAIC,EAAUnC,KAAKgB,OAAOoB,cAAcC,SAASb,GAC7CW,GACAA,EAAQG,cAAcf,EAE7B,CACJ,CAEJ,CACJ,C,QC3FIgB,iBAKLb,WACA,OAAO1B,KAAKwC,K,CAEZd,SAAKxB,GACLF,KAAKwC,MAAQtC,C,CAEbsB,SAAKtB,GACLF,KAAKyC,MAAQvC,C,CAEbsB,WACA,OAAOxB,KAAKyC,K,CAEZlB,eAAWrB,GACXF,KAAK0C,YAAcxC,C,CAEnBqB,iBACA,OAAOvB,KAAK0C,W,QChBPC,aAGTC,YAAYC,GACR7C,KAAK8C,YAAcD,C,CAGvBE,W,YACI,MAAO,CACHC,MAAsC,QAA/BC,EAAmB,QAAlBC,EAAAlD,KAAK8C,mBAAa,IAAAI,OAAA,EAAAA,EAAAC,mBAAY,IAAAF,IAAI,GAC1CG,OAAwC,QAAhCC,EAAmB,QAAlBC,EAAAtD,KAAK8C,mBAAa,IAAAQ,OAAA,EAAAA,EAAAC,oBAAa,IAAAF,IAAI,G,CAIpDG,WAAWC,EAAgCC,GACvC,IAAK1D,KAAK8C,YACN,OAEJ,IAAIa,EAEAA,EADAD,IAAcE,MAAMC,cAAcC,QACrBC,aAAWC,MAEXD,aAAWE,SAChBjE,KAAK8C,YAAYoB,OAAQP,WAAaA,C,CAGtDQ,gBAAgBC,GACZ,OAAOA,GAAQR,MAAMS,YAAYC,YAAcC,WAASC,MAASJ,GAAQR,MAAMS,YAAYI,eAAiBF,WAASG,SAAWH,WAASI,M,CAG7IC,SAASC,EAA0BC,GAC/B,IAAK9E,KAAK8C,YACN,OAEJ,IAAIiC,EAAmB/E,KAAK8C,YAAYoB,OACxCa,EAAMC,UAAYhF,KAAKmE,gBAAgBU,GACvCE,EAAME,UAAYjF,KAAKmE,gBAAgBW,E,EC9BzC,MAAOI,qBAAqBC,WAS9BvC,cACIwC,QAEApF,KAAKkB,UAAY,E,CAGjBmE,SACA,OAAOrF,KAAKsF,G,CAGZC,eACA,OAAOvF,KAAKwF,S,CAGhBC,WAAW5D,GACP,OAAO7B,KAAKkB,UAAUW,E,CAG1B6D,OAAOC,EAA4BC,EAAmBC,EAAmBC,GAErE,IACIC,EAMJ,OARA/F,KAAKwF,UAAYQ,MAAIC,QAAQJ,GAIzBE,EAHU/F,KAAKkG,kBAAkBP,GAEzBQ,WAAW,MACNnG,KAAKoG,YAELpG,KAAKqG,YAEfN,EAAWO,KAAKtG,KAAM4F,EAAWE,GAAUtF,MAAM+F,IACpD,IAAIC,EAAc,IAAIxG,KAAKsF,IAAImB,sBAAsBF,GACrD,GAAIZ,aAAgBe,YAAa,CAC7B,IAAIC,EAAiB,IAAI3G,KAAKsF,IAAIsB,eAAeJ,GACjDxG,KAAKiB,aAAe0F,EAAeE,iBAAiB,IAAIC,WAAWnB,GACtE,KAAM,CACH,IAAIoB,EAAe,IAAI/G,KAAKsF,IAAI0B,aAAaR,GAC7CxG,KAAKiB,aAAe8F,EAAaF,iBAAiBlB,EACrD,I,CAIDO,kBAAkBP,GAEtB,OADA3F,KAAKsF,IAAM1B,MACJsB,aAAa+B,c,CAGhBZ,YAAYT,EAAmBE,GACnC,IAAIoB,EAA8B,GAKlC,OAJA,IAAIlH,KAAKsF,IAAI6B,aAAavB,GAAYwB,IAClCF,EAAWG,KAAK,CAAEC,IAAKtH,KAAKwF,UAAY4B,IACjC,IAAIzE,aAAa,SAErBxC,QAAMC,OAAOC,KAAK6G,EAAY,KAAMpB,aAAA,EAAAA,EAAUyB,kBAAkB/G,MAAMgH,IACzE,IAAIrG,EAAI,EASR,OARY,IAAInB,KAAKsF,IAAI6B,aAAavB,GAAYwB,IAC9C,IAAIvE,EAAM2E,EAAIrG,KACV0B,GACAA,EAAI4E,gBACR,IAAIC,EAAW,IAAI/E,aAAaE,GAEhC,OADA7C,KAAKkB,UAAUkG,GAAQM,EAChBA,CAAQ,GAEP,G,CAIZtB,YAAYR,EAAmBE,GACnC,IAAIS,EAAQ,IAAIvG,KAAKsF,IAAI6B,aAAavB,GACtC,OAAOzF,QAAMC,OAAOC,KAAKkG,EAAMoB,MAAMC,KAAK3F,GAAiCjC,KAAKwF,UAAYvD,EAAKJ,OAC7F,KAAMiE,aAAA,EAAAA,EAAUyB,kBAAkB/G,MAAMgH,IACpC,IAAIrG,EAAI,EACR,IAAK,IAAIc,KAAQsE,EAAMoB,MAAO,CAC1B,IAAI9E,EAAM2E,EAAIrG,KACV0B,GACAA,EAAI4E,gBACR,IAAIC,EAAW,IAAI/E,aAAaE,GAChC7C,KAAKkB,UAAUe,EAAKJ,MAAQ6F,EAC5BzF,EAAK4F,WAAWH,EACnB,CAED,OAAOnB,CAAK,G,CASxBuB,kBAAkBC,GACd,IAAIC,EAAYhI,KAAKiB,aAAagH,WAAWF,GAC7C,OAAIC,EAAaA,EAAKnG,KACf,I,CAQXqG,mBAAmBC,GACf,IACIC,EADAzG,EAAQ3B,KAAKiB,aAAaU,MAE9B,IAAK,IAAIR,EAAY,EAAGkH,EAAY1G,EAAMP,OAAQD,EAAIkH,EAAGlH,IAErD,GADAiH,EAAYzG,EAAMR,GACdiH,EAAUvG,MAAQsG,EAClB,OAAOhH,EAGf,OAAQ,C,CAOFmH,mB,MACN,IAAK,IAAIC,KAAKvI,KAAKkB,UACc,QAA7BgC,EAAAlD,KAAKkB,UAAUqH,GAAGzF,mBAAW,IAAAI,KAAEsF,kB,EA5HzBtD,aAAc+B,eAAW,MCD3C,MAAMwB,EAAiB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,G,MAE1BC,sBAiBT9F,YAAYnC,EAAuBkI,GAAwB,GAf3D3I,KAAY4I,aAAuB,KAG3B5I,KAAA6I,UAAY,IAAIjF,MAAMkF,MACtB9I,KAAA+I,WAAa,IAAInF,MAAMkF,MAEvB9I,KAAAgJ,WAAa,EACbhJ,KAAY2I,cAAG,EAGf3I,KAAAiJ,KAAO,IAAIrF,MAAMsF,QACjBlJ,KAAAmJ,MAAQ,IAAIvF,MAAMsF,QAClBlJ,KAAAoJ,MAAQ,IAAIxF,MAAMkF,MAClB9I,KAAAqJ,MAAQ,IAAIzF,MAAMkF,MAGtB9I,KAAK2I,aAAeA,EAChBA,IACA3I,KAAKgJ,YAAc,GACvBhJ,KAAKS,QAAUA,EACfT,KAAKsJ,SAAW7I,EAAQ4E,GAAGkE,MAAMC,cAAgC,KAAlBxJ,KAAKgJ,YACpDhJ,KAAKyJ,WAAa,CAAEH,SAAU,KAAMI,YAAa,EAAGC,UAAW,GAC/D3J,KAAK4J,QAAU,IAAInJ,EAAQ4E,GAAGwE,gB,CAGlCC,KAAKC,EAA0BC,EAAoBC,GAAyB,EAAIC,GAAuB,GACnG,IAAIN,EAAU5J,KAAK4J,QACfO,EAAqBnK,KAAKmK,mBAI1BC,EAAUpK,KAAKiJ,KACfoB,EAASrK,KAAKmJ,MACdmB,EAAYtK,KAAKoJ,MACjBmB,EAAWvK,KAAKqJ,MAEhBI,EAAyBzJ,KAAKyJ,WAC9Be,EAAyB,KACzBC,EAA2B,KAC3BC,EAAYX,EAASW,UACrBC,EAA+B,KAC/BC,EAAgBb,EAASc,MAEzBC,GAAU,GAES,GAAnBb,IAAsBa,GAAU,GACpC,IAAK,IAAI3J,EAAI,EAAGkH,EAAIqC,EAAUtJ,OAAQD,EAAIkH,EAAGlH,IAAK,CAC9C,IAAI4J,EAAoBnB,EAAQoB,aAAe,EALd,EAM7BxJ,EAAOkJ,EAAUvJ,GAMrB,GAJI8I,GAAkB,GAAKA,GAAkBzI,EAAKyJ,KAAKlD,QACnD+C,GAAU,IAGTA,EAAS,CACVlB,EAAQsB,gBAAgB1J,GACxB,QACH,CAEG0I,GAAgB,GAAKA,GAAgB1I,EAAKyJ,KAAKlD,QAC/C+C,GAAU,GAGd,IAEI5I,EAFAX,EAAaC,EAAK2J,gBAClBtJ,EAAe,KAEnB,GAAIN,aAAsBvB,KAAKS,QAAQ4E,GAAG+F,iBAAkB,CACxD,IAAIpJ,EAAiCT,EACrCkI,EAAWH,SAAWtJ,KAAKsJ,SAC3BG,EAAWC,YAAc,EACzBD,EAAWE,UAAYoB,GAAqB,EACxC,OAAS7F,aAAa+B,eACtBjF,EAAOqJ,qBAAqB7J,EAAaiI,EAAWH,SAAU,EAAGyB,GAEjE/I,EAAOqJ,qBAAqB7J,EAAK8J,KAAM7B,EAAWH,SAAU,EAAGyB,GAEnEN,EAAYhC,EACZ+B,EAAMxI,EAAOwI,IAET3I,EADA,OAASqD,aAAa+B,eACdjF,EAAOA,OAAeC,KAAKJ,KAE5BG,EAAOA,OAAOuJ,aAAatJ,KAAKJ,KAE3CK,EAAUlC,KAAKS,QAAQgF,WAAW5D,GAClC8I,EAAkB3I,EAAO6I,KAC5B,KAAM,MAAItJ,aAAsBvB,KAAKS,QAAQ4E,GAAGmG,gBAkB1C,IAAIjK,aAAsBvB,KAAKS,QAAQ4E,GAAGoG,mBAAoB,CACjE,IAAIC,EAAI,EACR9B,EAAQ+B,UAAUnK,EAAMkK,GACxB,QACH,CACG9B,EAAQsB,gBAAgB1J,GACxB,QACH,CAzBgE,CAC7D,IAAIoK,EAA6BrK,EACjCkI,EAAWH,SAAWtJ,KAAKsJ,SAC3BG,EAAWC,YAAekC,EAAKC,qBAAuB,EACtDpC,EAAWE,UAAYF,EAAWC,YAAcqB,EAC5CtB,EAAWE,UAAYF,EAAWH,SAASlI,SAC3CqI,EAAWH,SAAWtJ,KAAKsJ,SAAWtJ,KAAKS,QAAQ4E,GAAGkE,MAAMC,cAAcC,EAAWE,YAEzFiC,EAAKP,qBAAqB7J,EAAM,EAAGoK,EAAKC,oBAAqBpC,EAAWH,SAAU,EAAGyB,GACrFN,EAAYmB,EAAKnB,UAEb5I,EADA,OAASqD,aAAa+B,eACd2E,EAAK5J,OAAeC,KAAKJ,KAE1B+J,EAAK5J,OAAOuJ,aAAatJ,KAAKJ,KAEzCK,EAAUlC,KAAKS,QAAQgF,WAAW5D,GAClC2I,EAAMoB,EAAKpB,IACXG,EAAkBiB,EAAKf,KAC1B,CAOA,CAED,GAAe,MAAX3I,EAAiB,CACjB,IAAI4J,EAAYtK,EAAKqJ,MACjBkB,EAAa/L,KAAK6I,UACtBkD,EAAWC,EAAIpB,EAAcoB,EAAIF,EAAUE,EAAIrB,EAAgBqB,EAC/DD,EAAWE,EAAIrB,EAAcqB,EAAIH,EAAUG,EAAItB,EAAgBsB,EAC/DF,EAAWG,EAAItB,EAAcsB,EAAIJ,EAAUI,EAAIvB,EAAgBuB,EAC/DH,EAAWI,EAAIvB,EAAcuB,EAAIL,EAAUK,EAAIxB,EAAgBwB,EAC3DhC,IACA4B,EAAWC,GAAKD,EAAWI,EAC3BJ,EAAWE,GAAKF,EAAWI,EAC3BJ,EAAWG,GAAKH,EAAWI,GAG/B,IAAIC,EAAgB5K,EAAKyJ,KAAKoB,UAK9B,GAAIzC,EAAQoB,aAAc,CACtBpB,EAAQ0C,cAAc7C,EAAWH,SAAUG,EAAWE,UAAWc,EAAWA,EAAUrJ,OAAQoJ,EAAKuB,EAAY,KAvGxG,OAwGP,IA6CIM,EA7CAE,EAAkB,IAAIC,aAAa5C,EAAQ2C,iBAC3CE,EAAmB7C,EAAQ6C,iBAC3BC,EAAY,GACZC,EAAO,GACPC,EAAW,SACXC,EAAQ,EACZ,GAAyB,MAArB7M,KAAK4I,aAAsB,CAC3B,IAAIA,EAAe5I,KAAK4I,aACpBkE,EAAQP,EAER,IAAK,IAAIQ,EAAI,EAAG1E,EAAIkE,EAAgBnL,OAAQ2L,EAAI1E,EAAG0E,GApGlC,EAqGb3C,EAAQ4C,EAAIF,EAAMC,GAClB3C,EAAQ6C,EAAIH,EAAMC,EAAI,GACtBzC,EAAU4C,IAAIJ,EAAMC,EAAI,GAAID,EAAMC,EAAI,GAAID,EAAMC,EAAI,GAAID,EAAMC,EAAI,IAClE1C,EAAO2C,EAAIF,EAAMC,EAAI,GACrB1C,EAAO4C,EAAIH,EAAMC,EAAI,GACrBxC,EAAS2C,IAAI,EAAG,EAAG,EAAG,GACtBtE,EAAauE,UAAU/C,EAASC,EAAQC,EAAWC,GACnDuC,EAAMC,GAAK3C,EAAQ4C,EACnBF,EAAMC,EAAI,GAAK3C,EAAQ6C,EACvBH,EAAMC,EAAI,GAAKzC,EAAU0B,EACzBc,EAAMC,EAAI,GAAKzC,EAAU2B,EACzBa,EAAMC,EAAI,GAAKzC,EAAU4B,EACzBY,EAAMC,EAAI,GAAKzC,EAAU6B,EACzBW,EAAMC,EAAI,GAAK1C,EAAO2C,EACtBF,EAAMC,EAAI,GAAK1C,EAAO4C,EAEtBP,EAAUrF,KAAKyF,EAAMC,IAAKD,EAAMC,EAAI,IACpCH,GAA2B,IAAfE,EAAMC,EAAI,IAAY,KAAsB,IAAfD,EAAMC,EAAI,IAAY,GAAKD,EAAMC,EAAI,GAC9EF,EAAQC,EAAMC,EAAI,GAClBJ,EAAKtF,KAAKyF,EAAMC,EAAI,GAAID,EAAMC,EAAI,GAG7C,KAAM,CACH,IAAIK,EAAK,EACT,KAAOC,OAAOC,SAASf,EAAgBa,EAAK,KAAOC,OAAOC,SAASf,EAAgBa,EAAK,KACpFV,EAAUrF,KAAKkF,EAAgBa,IAC/BV,EAAUrF,MAAMkF,EAAgBa,EAAK,IACrCR,GAAsC,IAA1BL,EAAgBa,EAAK,IAAY,KAAiC,IAA1Bb,EAAgBa,EAAK,IAAY,GAA+B,IAA1Bb,EAAgBa,EAAK,GAC/GP,EAAQN,EAAgBa,EAAK,GAC7BT,EAAKtF,KAAKkF,EAAgBa,EAAK,IAC/BT,EAAKtF,KAAKkF,EAAgBa,EAAK,IAC/BA,GAAMpN,KAAKgJ,UAElB,CAED,OAAQoD,GACJ,KAAK,EACDC,EAAY,QACZ,MACJ,KAAK,EACDA,EAAY,WACZ,MACJ,KAAK,EACDA,EAAY,SACZ,MACJ,QACIA,EAAY,SAEpBrC,EAASuD,cAAcrL,EAAQY,YAAa,EAAG,EAAQ4J,EAAgBC,EAAM,IAAIa,YAAYf,GAAmBgB,SAAOC,MAAOb,EAAOD,EAAUP,EAClJ,KAAM,CACH,IAgDIA,EAhDAS,EAAQrD,EAAWH,SACnBoD,EAAY,GACZC,EAAO,GACPC,EAAW,SACXC,EAAQ,EACZ,GAAyB,MAArB7M,KAAK4I,aAAsB,CAC3B,IAAIA,EAAe5I,KAAK4I,aAEpB,IAAK,IAAImE,EAAI,EAAGY,EAAI,EAAGtF,EAAIoB,EAAWE,UAAWoD,EAAI1E,EAAG0E,GA/JvC,EA+JwDY,GAAK,EAC1EvD,EAAQ4C,EAAIF,EAAMC,GAClB3C,EAAQ6C,EAAIH,EAAMC,EAAI,GACtB1C,EAAO2C,EAAIxC,EAAImD,GACftD,EAAO4C,EAAIzC,EAAImD,EAAI,GACnBrD,EAAUsD,aAAa7B,GACvBxB,EAAS2C,IAAI,EAAG,EAAG,EAAG,GACtBtE,EAAauE,UAAU/C,EAASC,EAAQC,EAAWC,GACnDuC,EAAMC,GAAK3C,EAAQ4C,EACnBF,EAAMC,EAAI,GAAK3C,EAAQ6C,EACvBH,EAAMC,EAAI,GAAKzC,EAAU0B,EACzBc,EAAMC,EAAI,GAAKzC,EAAU2B,EACzBa,EAAMC,EAAI,GAAKzC,EAAU4B,EACzBY,EAAMC,EAAI,GAAKzC,EAAU6B,EACzBW,EAAMC,EAAI,GAAK1C,EAAO2C,EACtBF,EAAMC,EAAI,GAAK1C,EAAO4C,EAEtBP,EAAUrF,KAAKyF,EAAMC,IAAKD,EAAMC,EAAI,IACpCH,GAA2B,IAAfE,EAAMC,EAAI,IAAY,KAAsB,IAAfD,EAAMC,EAAI,IAAY,GAAoB,IAAfD,EAAMC,EAAI,GAC9EF,EAAQC,EAAMC,EAAI,GAClBJ,EAAKtF,KAAKyF,EAAMC,EAAI,GAAID,EAAMC,EAAI,GAG7C,MAEO,IAAK,IAAIA,EAAI,EAAGY,EAAI,EAAGtF,EAAIoB,EAAWE,UAAWoD,EAAI1E,EAAG0E,GAxLvC,EAwLwDY,GAAK,EAC1Eb,EAAMC,GAAKhB,EAAWC,EACtBc,EAAMC,EAAI,GAAKhB,EAAWE,EAC1Ba,EAAMC,EAAI,GAAKhB,EAAWG,EAC1BY,EAAMC,EAAI,GAAKhB,EAAWI,EAC1BW,EAAMC,EAAI,GAAKvC,EAAImD,GACnBb,EAAMC,EAAI,GAAKvC,EAAImD,EAAI,GAEvBjB,EAAUrF,KAAKyF,EAAMC,EAAI,IAAKD,EAAMC,EAAI,IACxCH,GAAuB,IAAXE,EAAMC,IAAY,KAAsB,IAAfD,EAAMC,EAAI,IAAY,GAAoB,IAAfD,EAAMC,EAAI,GAC1EF,EAAQC,EAAMC,EAAI,GAClBJ,EAAKtF,KAAKyF,EAAMC,EAAI,GAAID,EAAMC,EAAI,IAK9C,OAAQX,GACJ,KAAK,EACDC,EAAY,QACZ,MACJ,KAAK,EACDA,EAAY,WACZ,MACJ,KAAK,EACDA,EAAY,SACZ,MACJ,QACIA,EAAY,SAEpBrC,EAASuD,cAAcrL,EAAQY,YAAa,EAAG,EAAQ4J,EAAgBC,EAAM,IAAIa,YAAY/C,GAAYgD,SAAOC,MAAOb,EAAOD,EAAUP,EAC3I,CACJ,CAEDzC,EAAQsB,gBAAgB1J,EAC3B,CACDoI,EAAQiE,S,ECrPV,MAAOC,sBAAsBC,SAuC/BnL,cACIwC,QA7BMpF,KAAgBgO,iBAAW,EAI7BhO,KAAMiO,QAAY,EAElBjO,KAAYkO,aAAW,KAQvBlO,KAAamO,cAAW,EAExBnO,KAAUoO,YAAY,EAEtBpO,KAAgBqO,iBAAU,GAE1BrO,KAAUsO,WAAW,EAErBtO,KAASuO,UAAW,UACpBvO,KAAcwO,eAAW,GACzBxO,KAAKyO,OAAY,C,CAQrBC,oBACA,OAAO1O,KAAK2O,c,CAEZD,kBAAcxO,GACd,GAAIA,EACA,IAAK,IAAIiB,EAAIjB,EAAMkB,OAAS,EAAGD,GAAK,EAAGA,IACnCjB,EAAMiB,GAAGH,OAAShB,KAG1BA,KAAK2O,eAAiBzO,C,CAK1B0O,oBACQ5O,KAAK6O,YACL7O,KAAK6O,UAAY,IAAI7O,KAAKa,SAASwE,GAAGyJ,SAAS9O,KAAKa,SAASI,cAC7DjB,KAAK+O,gB,CAIThP,aACA,OAAOC,KAAKC,O,CAGZF,WAAOG,GACPF,KAAKC,QAAUC,EAEXA,EACAC,QAAMC,OAAOC,KAAKH,EAAOI,SAAOC,OAAOC,MAAMC,KACpCT,KAAKC,SAAWQ,IAAYA,EAAQC,gBAAgBV,KAAKC,WAG9DD,KAAKS,QAAUA,EAAO,IAI1BT,KAAKS,QAAU,I,CAGnB0H,eACA,OAAOnI,KAAKuO,S,CAGZpG,aAASjI,GACTF,KAAKuO,UAAYrO,EACbF,KAAKa,UACLb,KAAKgP,eAAe9O,E,CAGxB+O,oBACA,OAAOjP,KAAKwO,c,CAGZS,kBAAc/O,GACdF,KAAKwO,eAAiBtO,EAClBF,KAAKa,UACLb,KAAKkP,KAAKhP,EAAOF,KAAKyO,OAAO,E,CAGjCU,WACA,OAAOnP,KAAKyO,K,CAGZU,SAAKjP,GACLF,KAAKyO,MAAQvO,EACTF,KAAKa,UACLb,KAAKkP,KAAKlP,KAAKwO,eAAgBxO,KAAKyO,OAAO,E,CAO/ChO,cACA,OAAOT,KAAKa,Q,CAMZJ,YAAQP,GACRF,KAAKc,KAAKZ,E,CAOVkP,gBAAYlP,GACZ,GAAKF,KAAKkO,cAAiBlO,KAAKa,SAAhC,CAIA,IADAX,GAAS,KACGF,KAAKqP,YAAiBrP,KAAKsP,UAAYpP,EAAQF,KAAKsP,UAAapP,EAAQF,KAAKuP,UACtF,MAAM,IAAIC,MAAM,gFAEpBxP,KAAKyP,OAAOC,OAAOxP,EAAQF,KAAKgO,kBAChChO,KAAKgO,iBAAmB9N,CAPpB,C,CAcJyP,gBACA,OAAK3P,KAAKkO,aAENlO,KAAKiO,OACEH,cAAc8B,OAClB9B,cAAc+B,QAHV/B,cAAcgC,O,CAMnBhP,KAAKL,GAOX,GANIT,KAAKa,WACLb,KAAK+P,QACL/P,KAAKgK,SAASgG,SAGlBhQ,KAAKa,SAAWJ,GACXT,KAAKa,SACN,OAEJb,KAAKa,SAAS4G,gBACdzH,KAAK6O,UAAY,IAAIpO,EAAQ4E,GAAGyJ,SAAS9O,KAAKa,SAASI,cACvDjB,KAAKiQ,WAAa,IAAIxP,EAAQ4E,GAAG6K,mBAAmBlQ,KAAK6O,UAAU5D,MAEnEjL,KAAKyP,OAAS,IAAIhP,EAAQ4E,GAAG8K,eAAenQ,KAAKiQ,YACjDjQ,KAAKoQ,SAAW,IAAI1H,sBAAsBjI,GAAS,GACnDT,KAAKqQ,YAAc,IAAI5P,EAAQ4E,GAAGiL,WAElC,IAAIC,EAAYvQ,KAAKa,SAASqH,mBAAmBlI,KAAKuO,YACpC,GAAdgC,GACAvQ,KAAKwQ,gBAAgBD,GAEzBvQ,KAAKyP,OAAOgB,YAAY,CACpBC,MAAQC,IAAD,EAGPC,UAAYD,IAAD,EAGXE,IAAMF,IAAD,EAGLG,QAAUH,IAAD,EAGTI,SAAWJ,IAEHA,EAAMxB,KACNnP,KAAKgR,MAAMC,QAAMC,WAEjBlR,KAAKkO,aAAe,KACpBlO,KAAKgR,MAAMC,QAAMnB,SACpB,EAELkB,MAAO,CAACL,EAAYK,KAChB,IAAIG,EAAY,CACZC,WAAYJ,EAAM/F,KAAKoG,UACvBA,UAAWL,EAAM/F,KAAKoG,UACtBC,WAAYN,EAAMM,WAClBC,SAAUP,EAAMO,SAChB1P,KAAMmP,EAAM/F,KAAKpJ,KACjB2P,YAAaR,EAAMQ,YACnBC,KAAmB,IAAbT,EAAMS,KACZC,QAASV,EAAMU,QACfC,OAAQX,EAAMW,QAIlB,GADA3R,KAAKgR,MAAMC,QAAMW,MAAOT,GACpBnR,KAAKoO,YAAc+C,EAAUC,WAAY,CACzC,IAAIS,EAAUC,eAAaC,UAAUtR,EAAQ8E,SAAW4L,EAAUC,WAAY,EAAGY,UAAQC,OAAOjS,KAAMA,KAAKkS,mBAAoB,MAA+B,IAAxBlS,KAAKgO,iBAA0BmD,EAAUM,MAAQ,KACvLK,eAAaK,aAAenS,KAAKmO,cACjC0D,GAAW7R,KAAKqO,iBAAiBhH,KAAKwK,EACzC,KAGT7R,KAAK+O,gBACL/O,KAAKgR,MAAMC,QAAMmB,OAEbC,UAAQC,WAAatS,KAAKwO,gBAC1BxO,KAAKkP,KAAKlP,KAAKwO,eAAgBxO,KAAKyO,OAAO,E,CAcnDS,KAAKqD,EAAkBpD,EAAeqD,GAAiB,EAAM9B,EAAgB,EAAGG,EAAc,EAAG4B,GAAqB,EAAMC,GAAqB,GAC7I1S,KAAKoO,WAAasE,EAElB7B,GAAO,IACP,IAAI5B,EAAgBsD,EACpB,IAHA7B,GAAS,KAGG,GAAKG,EAAM,EACnB,MAAM,IAAIrB,MAAM,sDACpB,GAAa,IAARqB,GAAeH,EAAQG,EACxB,MAAM,IAAIrB,MAAM,4CAMpB,GAJ4B,iBAAjBP,IACPA,EAAgBjP,KAAK8H,kBAAkByK,IAGvCC,GAASxS,KAAKiO,QAAUjO,KAAKkO,cAAgBe,EAAe,CAC5DjP,KAAKkO,aAAee,EAEpBjP,KAAKyP,OAAOkD,aAAa3S,KAAKsO,WAAYW,EAAeE,GAEzD,IAAIyD,EAAa5S,KAAKyP,OAAOoD,WAAW7S,KAAKsO,YAC7CsE,EAAWE,eAAiBpC,EACtBG,GAAOA,EAAM+B,EAAWG,eAC1BH,EAAWG,aAAelC,GAE9B,IAAImC,EAAoBJ,EAAWK,UAAUC,SAC7ClT,KAAKuP,UAAYyD,EACjBhT,KAAKqP,WAAaqB,EAClB1Q,KAAKsP,SAAWuB,GAAOmC,EAAoBnC,EAAMmC,EAE7ChT,KAAKiO,SACLjO,KAAKiO,QAAS,EACdjO,KAAKmT,MAAMC,UAAU,EAAGpT,KAAMA,KAAKqT,QAAS,MAAM,IAEtDrT,KAAKqT,SACR,C,CAGGA,UACJrT,KAAKqQ,YAAYX,SACjB,IAAI4D,EAAQtT,KAAKqQ,YAAYiD,MAAQtT,KAAKmO,cACtCyE,EAAa5S,KAAKyP,OAAOoD,WAAW7S,KAAKsO,YAE7CtO,KAAKyP,OAAOC,OAAO4D,GAEnBtT,KAAKyP,OAAO8D,MAAMvT,KAAK6O,WAEvB,IAAI2E,EAAgBZ,EAAWY,cAC/BxT,KAAKgO,iBAAmByF,KAAKC,IAAI,EAAGF,GAG/BxT,KAAKyP,QAAWzP,KAAK6O,YAI1B7O,KAAK6O,UAAU8E,uBAEf3T,KAAKgK,SAASgG,QACdhQ,KAAKoQ,SAAStG,KAAK9J,KAAK6O,UAAW7O,KAAKgK,UAAW,GAAI,G,CAGnD+E,gBACJ,GAAI,MAAQ/O,KAAK6O,UAAW,OAC5B,IAAIlN,EAAQ3B,KAAK2O,eACjB,GAAIhN,EACA,IAAK,IAAIR,EAAIQ,EAAMP,OAAS,EAAGD,GAAK,EAAGA,IACnCQ,EAAMR,GAAGJ,O,CAQrB6S,aACI,OAAO5T,KAAKa,SAASI,aAAagH,WAAW7G,M,CAOjD0G,kBAAkBC,GACd,OAAO/H,KAAKa,SAASiH,kBAAkBC,E,CAO3C8L,cAAcC,GACV,OAAO9T,KAAK6O,UAAUxM,SAASyR,E,CAOnC3B,aAAajS,GACTF,KAAKmO,cAAgBjO,C,CAOzB8O,eAAenN,GACX7B,KAAKwQ,gBAAgBxQ,KAAKa,SAASqH,mBAAmBrG,G,CAO1D2O,gBAAgBD,GACZ,IAAIwD,EAAW/T,KAAK6O,UAAU5D,KAAKtJ,MAAM4O,GACzCvQ,KAAK6O,UAAUmF,QAAQD,GACvB/T,KAAK6O,UAAUoF,qB,CAMnBC,OACSlU,KAAKiO,SACNjO,KAAKiO,QAAS,EACdjO,KAAKkO,aAAe,KACpBlO,KAAKmT,MAAMnD,MAAMhQ,KAAMA,KAAKqT,SAC5BrT,KAAKyP,OAAOC,QAAQ1P,KAAKgO,kBACzBhO,KAAKgO,iBAAmB,EACxBhO,KAAKgR,MAAMC,QAAMnB,SAEb9P,KAAKqO,iBAAiBjN,OAAS,GAC/BpB,KAAKkS,mBAAkB,G,CAQnCiC,SACI,IAAKnU,KAAKiO,SACNjO,KAAKiO,QAAS,EACdjO,KAAKmT,MAAMnD,MAAMhQ,KAAMA,KAAKqT,SAC5BrT,KAAKgR,MAAMC,QAAMrB,QACb5P,KAAKqO,iBAAiBjN,OAAS,GAC/B,IAAK,IAAIgT,EAAMpU,KAAKqO,iBAAiBjN,OAAQD,EAAI,EAAGA,EAAIiT,EAAKjT,IAAK,CAC9D,IAAI0Q,EAAU7R,KAAKqO,iBAAiBlN,GAC/B0Q,EAAQwC,WACTxC,EAAQyC,OAGf,C,CAQbC,SACI,GAAIvU,KAAKiO,SACLjO,KAAKiO,QAAS,EACdjO,KAAKmT,MAAMC,UAAU,EAAGpT,KAAMA,KAAKqT,QAAS,MAAM,GAC9CrT,KAAKqO,iBAAiBjN,OAAS,GAC/B,IAAK,IAAIgT,EAAMpU,KAAKqO,iBAAiBjN,OAAQD,EAAI,EAAGA,EAAIiT,EAAKjT,IAAK,CAC9D,IAAI0Q,EAAU7R,KAAKqO,iBAAiBlN,GAC/B0Q,EAAgB2C,aACjB3C,EAAQ0C,QAEf,C,CAULrC,kBAAkBM,GACtB,IAAK,IAAI4B,EAAMpU,KAAKqO,iBAAiBjN,OAAQD,EAAI,EAAGA,EAAIiT,EAAKjT,IAAK,CAC9D,IAAI0Q,EAAU7R,KAAKqO,iBAAiBlN,IAChC0Q,EAAQwC,WAAa7B,MACpBX,EAAQwC,WAAaxC,EAAQqC,OAC9BlU,KAAKqO,iBAAiBoG,OAAOtT,EAAG,GAEhCiT,IAAOjT,IAEd,C,CAGG4O,QACJ/P,KAAKa,SAAS2H,iBAAiB,GAC/BxI,KAAKa,SAAW,KAChBb,KAAKqQ,YAAc,KACnBrQ,KAAK6O,UAAY,KACjB7O,KAAKyP,OAAOiF,iBACZ1U,KAAKyP,OAAS,KACdzP,KAAKoQ,SAAW,KAChBpQ,KAAKkO,aAAe,KACpBlO,KAAKiO,QAAS,EACdjO,KAAKmT,MAAMnD,MAAMhQ,KAAMA,KAAKqT,SACxBrT,KAAKqO,iBAAiBjN,OAAS,GAC/BpB,KAAKkS,mBAAkB,E,CAO/ByC,QAAQC,GAAwB,GAC5BxP,MAAMuP,QAAQC,GACV5U,KAAKa,UACLb,KAAK+P,O,CAUb8E,aAAatC,EAAkBpD,GAAgB,EAAO2F,EAAgB,GAClEA,GAAS,IACT,IAAI7F,EAAgBsD,EACQ,iBAAjBtD,IACPA,EAAgBjP,KAAK8H,kBAAkBmH,IAE3CjP,KAAKkO,aAAee,EACpBjP,KAAKyP,OAAOoF,aAAa7U,KAAKsO,WAAYW,EAAeE,EAAM2F,E,CASnEC,OAAOC,EAAsBC,EAAoB/B,GAC7CA,GAAY,IACZ,IAAIgC,EAAWF,EACQ,iBAAZE,IACPA,EAAWlV,KAAK8H,kBAAkBoN,IAEtC,IAAIC,EAASF,EACQ,iBAAVE,IACPA,EAASnV,KAAK8H,kBAAkBqN,IAEpCnV,KAAKiQ,WAAW8E,OAAOG,EAAUC,EAAQjC,E,CAQ7CkC,cAAcC,GACV,OAAOrV,KAAK6O,UAAUyG,SAASD,E,CAMnCjT,cACI,OAAOpC,KAAK6O,S,CAQhB0G,kBAAkBzB,EAAkB0B,GAChCxV,KAAK6O,UAAUvM,cAAcwR,EAAU0B,E,EAjgB3B1H,cAAOgC,QAAW,EAClBhC,cAAM8B,OAAW,EACjB9B,cAAO+B,QAAW,ECbtCvP,SAAOmV,eAAe,CAAC,QAjBvB,MACIpV,KAAKqV,GACD,IAAIC,EAAWpM,QAAMqM,qBAAqBF,EAAKpO,IAAK,SAEpD,OAAOuO,QAAQC,IAAI,CACfJ,EAAKtV,OAAO2V,MAAML,EAAKpO,IAAiB,QAAZoO,EAAKM,IAAgB,cAAgB,OAAQN,EAAK5P,SAASyB,kBACvFmO,EAAKtV,OAAO2V,MAAMJ,EAAU,OAAQD,EAAK5P,SAASyB,oBACnD/G,MAAKgH,IACJ,IAAKA,EAAI,KAAOA,EAAI,GAChB,OAAO,KAEX,IAAI/G,EAAU,IAAIyE,aAClB,OAAOzE,EAAQiF,OAAO8B,EAAI,GAAIA,EAAI,GAAIkO,EAAKpO,IAAKoO,EAAK5P,UAAUtF,MAAK,IAAMC,GAAQ,G,GAK1CH,SAAOC,OCf3D,IAAI0V,EAAIC,aAAWC,SAEnBF,EAAE,gBAAiBnI,eACnBmI,EAAE,eAAgBnW,cAClBmW,EAAE,mBAAoB1T,kB"}