{"version":3,"file":"laya.gltf.js","sources":["../../bin/tsc/layaAir/laya/gltf/shader/glTFPBR.vs","../../bin/tsc/layaAir/laya/gltf/shader/glTFPBR.fs","../../bin/tsc/layaAir/laya/gltf/shader/glTFPBRDepth.vs","../../bin/tsc/layaAir/laya/gltf/shader/glTFPBRDepth.fs","../../bin/tsc/layaAir/laya/gltf/shader/glTFPBRDepthNormal.vs","../../bin/tsc/layaAir/laya/gltf/shader/glTFPBRDepthNormal.fs","../../src/layaAir/laya/gltf/shader/glTFShader.ts","../../src/layaAir/laya/gltf/glTFResource.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_anisotropy.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_clearcoat.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_emissive_strength.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_unlit.ts","../../src/layaAir/laya/gltf/glTFLoader.ts"],"sourcesContent":["#define SHADER_NAME glTFPBRVS\r\n\r\n#include \"Math.glsl\";\r\n\r\n#include \"Scene.glsl\";\r\n#include \"SceneFogInput.glsl\";\r\n\r\n#include \"Camera.glsl\";\r\n#include \"Sprite3DVertex.glsl\";\r\n\r\n#include \"VertexCommon.glsl\";\r\n\r\n#include \"PBRVertex.glsl\";\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    PixelParams pixel;\r\n    initPixelParams(pixel, vertex);\r\n\r\n    gl_Position = getPositionCS(pixel.positionWS);\r\n\r\n    gl_Position = remapPositionZ(gl_Position);\r\n\r\n#ifdef FOG\r\n    FogHandle(gl_Position.z);\r\n#endif\r\n}","#define SHADER_NAME glTFPBRFS\r\n\r\n#include \"Color.glsl\";\r\n\r\n#include \"Scene.glsl\";\r\n#include \"SceneFog.glsl\";\r\n\r\n#include \"Camera.glsl\";\r\n#include \"Sprite3DFrag.glsl\";\r\n\r\n#include \"PBRMetallicFrag.glsl\";\r\n\r\nvoid initSurfaceInputs(inout SurfaceInputs inputs, const in PixelParams pixel)\r\n{\r\n    vec2 uv = vec2(0.0);\r\n#ifdef UV\r\n    uv = pixel.uv0;\r\n#endif //\r\n\r\n    // render state\r\n    inputs.alphaTest = u_AlphaTestValue;\r\n\r\n    // surface\r\n    inputs.diffuseColor = u_BaseColorFactor.xyz;\r\n    inputs.alpha = u_BaseColorFactor.w;\r\n\r\n#ifdef COLOR\r\n    #ifdef ENABLEVERTEXCOLOR\r\n    inputs.diffuseColor *= pixel.vertexColor.xyz;\r\n    inputs.alpha *= pixel.vertexColor.a;\r\n    #endif // ENABLEVERTEXCOLOR\r\n#endif // COLOR\r\n\r\n#ifdef BASECOLORMAP\r\n    vec4 baseColorSampler = texture2D(u_BaseColorTexture, uv);\r\n#ifdef Gamma_u_BaseColorTexture\r\n    baseColorSampler = gammaToLinear(baseColorSampler);\r\n#endif // u_BaseColorTexture_Gamma\r\n    inputs.diffuseColor *= baseColorSampler.rgb;\r\n    inputs.alpha *= baseColorSampler.a;\r\n#endif // BASECOLORMAP\r\n\r\n    inputs.metallic = u_MetallicFactor;\r\n    float roughness = u_RoughnessFactor;\r\n#ifdef METALLICROUGHNESSMAP\r\n    vec4 metallicRoughnessSampler = texture2D(u_MetallicRoughnessTexture, uv);\r\n    inputs.metallic *= metallicRoughnessSampler.b;\r\n    roughness *= metallicRoughnessSampler.g;\r\n#endif // METALLICROUGHNESSMAP\r\n    inputs.smoothness = 1.0 - roughness;\r\n\r\n    float occlusion = 1.0;\r\n#ifdef OCCLUSIONMAP\r\n    vec4 occlusionSampler = texture2D(u_OcclusionTexture, uv);\r\n    #ifdef Gamma_u_OcclusionTexture\r\n    occlusionSampler = gammaToLinear(occlusionSampler);\r\n    #endif // Gamma_u_OcclusionTexture\r\n    occlusion = occlusionSampler.r;\r\n#endif // OCCLUSIONMAP\r\n    inputs.occlusion = (1.0 - u_OcclusionStrength) + occlusion * u_OcclusionStrength;\r\n\r\n    inputs.emissionColor = u_EmissionFactor * u_EmissionStrength;\r\n#ifdef EMISSIONMAP\r\n    vec4 emissionSampler = texture2D(u_EmissionTexture, uv);\r\n    #ifdef Gamma_u_EmissionTexture\r\n    emissionSampler = gammaToLinear(emissionSampler);\r\n    #endif // Gamma_u_EmissionTexture\r\n    inputs.emissionColor *= emissionSampler.rgb;\r\n#endif // EMISSIONMAP\r\n\r\n    inputs.normalTS = vec3(0.0, 0.0, 1.0);\r\n#ifdef NORMALMAP\r\n    vec3 normalSampler = texture2D(u_NormalTexture, uv).xyz;\r\n    normalSampler = normalize(normalSampler * 2.0 - 1.0);\r\n    normalSampler.y *= -1.0;\r\n    inputs.normalTS = normalScale(normalSampler, u_NormalScale);\r\n#endif // NORMALMAP\r\n\r\n#ifdef CLEARCOAT\r\n    inputs.clearCoat = u_ClearCoatFactor;\r\n    inputs.clearCoatRoughness = u_ClearCoatRoughness;\r\n\r\n    #ifdef CLEARCOATMAP\r\n    vec4 clearCoatSampler = texture2D(u_ClearCoatTexture, uv);\r\n    inputs.clearCoat *= clearCoatSampler.r;\r\n    #endif // CLEARCOATMAP\r\n\r\n    #ifdef CLEARCOAT_ROUGHNESSMAP\r\n    vec4 clearcoatSampleRoughness = texture2D(u_ClearCoatRoughnessTexture, uv);\r\n    inputs.clearCoatRoughness *= clearcoatSampleRoughness.g;\r\n    #endif // CLEARCOAT_ROUGHNESSMAP\r\n\r\n    #ifdef CLEARCOAT_NORMAL\r\n    vec3 clearCoatNormalSampler = texture2D(u_ClearCoatNormalTexture, uv).rgb;\r\n    clearCoatNormalSampler = normalize(clearCoatNormalSampler * 2.0 - 1.0);\r\n    clearCoatNormalSampler.y *= -1.0;\r\n    // todo scale\r\n    inputs.clearCoatNormalTS = normalScale(clearCoatNormalSampler, u_ClearCoatNormalScale);\r\n    #endif // CLEARCOAT_NORMAL\r\n#endif // CLEARCOAT\r\n\r\n#ifdef ANISOTROPIC\r\n    inputs.anisotropy = u_AnisotropyStrength;\r\n    vec2 direction = vec2(1.0, 0.0);\r\n\r\n    #ifdef ANISOTROPYMAP\r\n    vec3 anisotropySampler = texture2D(u_AnisotropyTexture, uv).rgb;\r\n\r\n    inputs.anisotropy *= anisotropySampler.b;\r\n    direction = anisotropySampler.xy * 2.0 - 1.0;\r\n    #endif // ANISOTROPYMAP\r\n\r\n    vec2 anisotropyRotation = vec2(cos(u_AnisotropyRotation), sin(u_AnisotropyRotation));\r\n    mat2 rotationMatrix = mat2(anisotropyRotation.x, anisotropyRotation.y, -anisotropyRotation.y, anisotropyRotation.x);\r\n    inputs.anisotropyDirection = rotationMatrix * direction;\r\n\r\n#endif // ANISOTROPIC\r\n}\r\n\r\nvoid main()\r\n{\r\n    PixelParams pixel;\r\n    getPixelParams(pixel);\r\n\r\n    SurfaceInputs inputs;\r\n    initSurfaceInputs(inputs, pixel);\r\n\r\n    vec4 surfaceColor = PBR_Metallic_Flow(inputs, pixel);\r\n\r\n#ifdef FOG\r\n    surfaceColor.rgb = sceneLitFog(surfaceColor.rgb);\r\n#endif // FOG\r\n\r\n    gl_FragColor = surfaceColor;\r\n\r\n    // // debug\r\n    // Surface surface;\r\n    // initSurface(surface, inputs, pixel);\r\n\r\n    // // PixelInfo info;\r\n    // // getPixelInfo(info, pixel, surface);\r\n\r\n    // vec3 debug = vec3(0.0);\r\n\r\n    // debug = vec3(1.0 - inputs.smoothness);\r\n\r\n    // debug = gammaToLinear(debug);\r\n    // gl_FragColor = vec4(debug, 1.0);\r\n}","#define SHADER_NAME glTFDepthVS\r\n\r\n#include \"DepthVertex.glsl\";\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    mat4 worldMat = getWorldMatrix();\r\n    vec4 pos = (worldMat * vec4(vertex.positionOS, 1.0));\r\n    vec3 positionWS = pos.xyz / pos.w;\r\n\r\n    mat4 normalMat = transpose(inverse(worldMat));\r\n    vec3 normalWS = normalize((normalMat * vec4(vertex.normalOS, 0.0)).xyz);\r\n\r\n    vec4 positionCS = DepthPositionCS(positionWS, normalWS);\r\n    gl_Position = remapPositionZ(positionCS);\r\n}","#define SHADER_NAME glTFDepthFS\r\n\r\n#include \"DepthFrag.glsl\";\r\n\r\nvoid main()\r\n{\r\n    gl_FragColor = getDepthColor();\r\n}","#define SHADER_NAME glTFPBRDepthNormalVS\r\n\r\n#include \"Math.glsl\";\r\n\r\n#include \"Camera.glsl\";\r\n\r\n#include \"Sprite3DVertex.glsl\";\r\n\r\n#include \"VertexCommon.glsl\";\r\n\r\n#include \"PBRVertex.glsl\";\r\n\r\nvarying vec4 v_PositionCS;\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    PixelParams pixel;\r\n    initPixelParams(pixel, vertex);\r\n\r\n    sharePixelParams(pixel);\r\n\r\n    vec4 positionCS = getPositionCS(pixel.positionWS);\r\n    v_PositionCS = positionCS;\r\n    gl_Position = positionCS;\r\n    gl_Position = remapPositionZ(gl_Position);\r\n}","#define SHADER_NAME glTFPBRDepthNormalFS\r\n\r\n#include \"Color.glsl\";\r\n\r\n#include \"Scene.glsl\";\r\n#include \"SceneFog.glsl\";\r\n\r\n#include \"Camera.glsl\";\r\n#include \"Sprite3DFrag.glsl\";\r\n\r\n#include \"ShadingFrag.glsl\";\r\n\r\n#include \"DepthNormalFrag.glsl\";\r\n\r\nvarying vec4 v_PositionCS;\r\n\r\nvoid main()\r\n{\r\n    PixelParams pixel;\r\n    getPixelParams(pixel);\r\n\r\n    vec3 normalWS = pixel.normalWS;\r\n\r\n#ifdef NORMALMAP\r\n    #ifdef UV\r\n\r\n    vec2 uv = pixel.uv0;\r\n\r\n    vec3 normalSampler = texture2D(u_NormalTexture, uv).xyz;\r\n    normalSampler = normalize(normalSampler * 2.0 - 1.0);\r\n    normalSampler.y *= -1.0;\r\n    vec3 normalTS = normalScale(normalSampler, u_NormalScale);\r\n    normalWS = normalize(pixel.TBN * normalTS);\r\n\r\n    #endif UV\r\n#endif // NORMALMAP\r\n\r\n    vec4 positionCS = v_PositionCS;\r\n\r\n    vec4 dephtNormal = encodeDepthNormal(positionCS, normalWS);\r\n\r\n    gl_FragColor = dephtNormal;\r\n}","import { Shader3D } from \"../../RenderEngine/RenderShader/Shader3D\";\r\nimport { ShaderDataType } from \"../../RenderEngine/RenderShader/ShaderData\";\r\nimport { ShaderDefine } from \"../../RenderEngine/RenderShader/ShaderDefine\";\r\nimport { SubShader } from \"../../RenderEngine/RenderShader/SubShader\";\r\nimport { Vector3 } from \"../../maths/Vector3\";\r\nimport { Vector4 } from \"../../maths/Vector4\";\r\nimport { Texture2D } from \"../../resource/Texture2D\";\r\n\r\nimport glTFPBRVS from \"./glTFPBR.vs\";\r\nimport glTFPBRFS from \"./glTFPBR.fs\";\r\nimport DepthVS from \"./glTFPBRDepth.vs\";\r\nimport DephtFS from \"./glTFPBRDepth.fs\";\r\nimport DepthNormalVS from \"./glTFPBRDepthNormal.vs\";\r\nimport DepthNormalFS from \"./glTFPBRDepthNormal.fs\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class glTFShader {\r\n\r\n    static ShaderName: string = \"glTFPBR\";\r\n\r\n    static Define_BaseMap: ShaderDefine;\r\n\r\n    static Define_MetallicRoughnessMap: ShaderDefine;\r\n\r\n    static Define_NormalMap: ShaderDefine;\r\n\r\n    static Define_OcclusionMap: ShaderDefine;\r\n\r\n    static Define_EmissionMap: ShaderDefine;\r\n\r\n    // clear coat\r\n    static Define_ClearCoatMap: ShaderDefine;\r\n    static Define_ClearCoatRoughnessMap: ShaderDefine;\r\n    static Define_ClearCoatNormalMap: ShaderDefine;\r\n\r\n    // anisotropy\r\n    static Define_AnisotropyMap: ShaderDefine;\r\n\r\n    // todo\r\n    static init() {\r\n        this.Define_BaseMap = Shader3D.getDefineByName(\"BASECOLORMAP\");\r\n        this.Define_MetallicRoughnessMap = Shader3D.getDefineByName(\"METALLICROUGHNESSMAP\");\r\n        this.Define_NormalMap = Shader3D.getDefineByName(\"NORMALMAP\");\r\n        this.Define_OcclusionMap = Shader3D.getDefineByName(\"OCCLUSIONMAP\");\r\n        this.Define_EmissionMap = Shader3D.getDefineByName(\"EMISSIONMAP\");\r\n\r\n        this.Define_ClearCoatMap = Shader3D.getDefineByName(\"CLEARCOATMAP\");\r\n        this.Define_ClearCoatRoughnessMap = Shader3D.getDefineByName(\"CLEARCOAT_ROUGHNESSMAP\");\r\n        this.Define_ClearCoatNormalMap = Shader3D.getDefineByName(\"CLEARCOAT_NORMAL\");\r\n\r\n        this.Define_AnisotropyMap = Shader3D.getDefineByName(\"ANISOTROPYMAP\");\r\n\r\n        let s = Shader3D.find(glTFShader.name);\r\n        if (s) {\r\n            return;\r\n        }\r\n\r\n        let uniformMap = {\r\n            // render \r\n            \"u_AlphaTestValue\": ShaderDataType.Float,\r\n            // surface\r\n            // metallic roughness\r\n            \"u_BaseColorFactor\": ShaderDataType.Vector4,\r\n            \"u_BaseColorTexture\": ShaderDataType.Texture2D,\r\n            \"u_MetallicFactor\": ShaderDataType.Float,\r\n            \"u_RoughnessFactor\": ShaderDataType.Float,\r\n            \"u_MetallicRoughnessTexture\": ShaderDataType.Texture2D,\r\n\r\n            \"u_NormalTexture\": ShaderDataType.Texture2D,\r\n            \"u_NormalScale\": ShaderDataType.Float,\r\n\r\n            \"u_OcclusionTexture\": ShaderDataType.Texture2D,\r\n            \"u_OcclusionStrength\": ShaderDataType.Float,\r\n\r\n            \"u_EmissionFactor\": ShaderDataType.Vector3,\r\n            \"u_EmissionTexture\": ShaderDataType.Texture2D,\r\n            \"u_EmissionStrength\": ShaderDataType.Float,\r\n\r\n            // clear coat\r\n            \"u_ClearCoatFactor\": ShaderDataType.Float,\r\n            \"u_ClearCoatTexture\": ShaderDataType.Texture2D,\r\n            \"u_ClearCoatRoughness\": ShaderDataType.Float,\r\n            \"u_ClearCoatRoughnessTexture\": ShaderDataType.Texture2D,\r\n            \"u_ClearCoatNormalTexture\": ShaderDataType.Texture2D,\r\n            \"u_ClearCoatNormalScale\": ShaderDataType.Float,\r\n\r\n            // anisotropy\r\n            \"u_AnisotropyStrength\": ShaderDataType.Float,\r\n            \"u_AnisotropyRotation\": ShaderDataType.Float,\r\n            \"u_AnisotropyTexture\": ShaderDataType.Texture2D,\r\n        }\r\n\r\n        let defaultValue = {\r\n            // render \r\n            \"u_AlphaTestValue\": 0.5,\r\n            // surface\r\n            \"u_BaseColorFactor\": Vector4.ONE,\r\n            \"u_MetallicFactor\": 1.0,\r\n            \"u_RoughnessFactor\": 1.0,\r\n            \"u_NormalScale\": 1.0,\r\n            \"u_OcclusionStrength\": 1.0,\r\n            \"u_EmissionFactor\": Vector3.ZERO,\r\n            \"u_EmissionStrength\": 1.0,\r\n\r\n            // clear coat\r\n            \"u_ClearCoatFactor\": 0.0,\r\n            \"u_ClearCoatRoughness\": 0.0,\r\n            \"u_ClearCoatNormalScale\": 1.0,\r\n\r\n            // anisotropy\r\n            \"u_AnisotropyStrength\": 0.0,\r\n            \"u_AnisotropyRotation\": 0.0\r\n        }\r\n\r\n        let shader = Shader3D.add(\"glTFPBR\", true, true);\r\n        let subShader = new SubShader(SubShader.DefaultAttributeMap, uniformMap, defaultValue);\r\n        shader.addSubShader(subShader);\r\n\r\n        let shadingPass = subShader.addShaderPass(glTFPBRVS, glTFPBRFS);\r\n        let depthPass = subShader.addShaderPass(DepthVS, DephtFS, \"ShadowCaster\");\r\n        let dephtNormalPass = subShader.addShaderPass(DepthNormalVS, DepthNormalFS, \"DepthNormal\");\r\n\r\n    }\r\n\r\n}","import { AnimationClip } from \"../d3/animation/AnimationClip\";\r\nimport { KeyframeNode } from \"../d3/animation/KeyframeNode\";\r\nimport { KeyframeNodeList } from \"../d3/animation/KeyframeNodeList\";\r\nimport { Material, MaterialRenderMode } from \"../d3/core/material/Material\";\r\nimport { PBRStandardMaterial } from \"../d3/core/material/PBRStandardMaterial\";\r\nimport { Mesh, skinnedMatrixCache } from \"../d3/resource/models/Mesh\";\r\nimport { URL } from \"../net/URL\";\r\nimport { Texture2D, TextureConstructParams, TexturePropertyParams } from \"../resource/Texture2D\";\r\nimport * as glTF from \"./glTFInterface\";\r\n\r\nimport { ILaya } from \"../../ILaya\";\r\nimport { BufferUsage } from \"../RenderEngine/RenderEnum/BufferTargetType\";\r\nimport { HDREncodeFormat } from \"../RenderEngine/RenderEnum/HDREncodeFormat\";\r\nimport { IndexFormat } from \"../RenderEngine/RenderEnum/IndexFormat\";\r\nimport { RenderState } from \"../RenderEngine/RenderShader/RenderState\";\r\nimport { VertexMesh } from \"../RenderEngine/RenderShader/VertexMesh\";\r\nimport { VertexDeclaration } from \"../RenderEngine/VertexDeclaration\";\r\nimport { Animator } from \"../d3/component/Animator/Animator\";\r\nimport { AnimatorControllerLayer } from \"../d3/component/Animator/AnimatorControllerLayer\";\r\nimport { AnimatorState } from \"../d3/component/Animator/AnimatorState\";\r\nimport { FloatKeyframe } from \"../d3/core/FloatKeyframe\";\r\nimport { MeshFilter } from \"../d3/core/MeshFilter\";\r\nimport { MeshSprite3D } from \"../d3/core/MeshSprite3D\";\r\nimport { QuaternionKeyframe } from \"../d3/core/QuaternionKeyframe\";\r\nimport { SkinnedMeshRenderer } from \"../d3/core/SkinnedMeshRenderer\";\r\nimport { SkinnedMeshSprite3D } from \"../d3/core/SkinnedMeshSprite3D\";\r\nimport { Sprite3D } from \"../d3/core/Sprite3D\";\r\nimport { Vector3Keyframe } from \"../d3/core/Vector3Keyframe\";\r\nimport { IndexBuffer3D } from \"../d3/graphics/IndexBuffer3D\";\r\nimport { VertexBuffer3D } from \"../d3/graphics/VertexBuffer3D\";\r\nimport { MorphTarget, MorphTargetChannel } from \"../d3/resource/models/MorphTarget\";\r\nimport { MorphTargetData } from \"../d3/resource/models/MorphTargetData\";\r\nimport { SubMesh } from \"../d3/resource/models/SubMesh\";\r\nimport { Node } from \"../display/Node\";\r\nimport { LayaGL } from \"../layagl/LayaGL\";\r\nimport { Matrix4x4 } from \"../maths/Matrix4x4\";\r\nimport { Quaternion } from \"../maths/Quaternion\";\r\nimport { Vector3 } from \"../maths/Vector3\";\r\nimport { Vector4 } from \"../maths/Vector4\";\r\nimport { IBatchProgress } from \"../net/BatchProgress\";\r\nimport { Loader } from \"../net/Loader\";\r\nimport { Prefab } from \"../resource/HierarchyResource\";\r\nimport { Base64Tool } from \"../utils/Base64Tool\";\r\nimport { Byte } from \"../utils/Byte\";\r\nimport { glTFExtension } from \"./extensions/glTFExtension\";\r\nimport { glTFShader } from \"./shader/glTFShader\";\r\nimport { PBRShaderLib } from \"../d3/shader/pbr/PBRShaderLib\";\r\nimport { Laya } from \"../../Laya\";\r\n\r\nconst maxSubBoneCount = 24;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class glTFResource extends Prefab {\r\n\r\n    private static _Extensions: { [name: string]: (resource: glTFResource) => glTFExtension } = {};\r\n\r\n    static registerExtension(name: string, factory: (resource: glTFResource) => glTFExtension) {\r\n        this._Extensions[name] = factory;\r\n    }\r\n\r\n    protected _data: glTF.glTF;\r\n\r\n    get data(): Readonly<glTF.glTF> {\r\n        return this._data;\r\n    }\r\n\r\n    protected _buffers: Record<string, ArrayBuffer>;\r\n    protected _textures: Texture2D[];\r\n    protected _materials: Material[];\r\n    protected _meshes: Record<string, Mesh>;\r\n\r\n    protected _extensions: Array<glTFExtension>;\r\n\r\n    protected _pendingOps: Array<Promise<any>>;\r\n\r\n    private _scenes: Array<Sprite3D>;\r\n    private _nodes: Array<Sprite3D>;\r\n\r\n    /** @internal */\r\n    private _idCounter: Record<string, number>;\r\n\r\n    constructor() {\r\n        super(3);\r\n\r\n        this._buffers = {};\r\n        this._textures = [];\r\n        this._materials = [];\r\n        this._meshes = {};\r\n        this._extensions = [];\r\n        this._pendingOps = [];\r\n        this._scenes = [];\r\n        this._nodes = [];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @param basePath \r\n     * @param progress \r\n     * @returns \r\n     */\r\n    loadBinary(basePath: string, progress?: IBatchProgress) {\r\n        let data = this._data;\r\n        if (data.buffers) {\r\n            let promises: Array<Promise<any>> = [];\r\n            data.buffers.forEach((buffer, i) => {\r\n                if (Base64Tool.isBase64String(buffer.uri)) {\r\n                    let bin = Base64Tool.decode(buffer.uri.replace(Base64Tool.reghead, \"\"));\r\n                    this._buffers[i] = bin;\r\n                }\r\n                else {\r\n                    let j = i;\r\n                    promises.push(ILaya.loader.fetch(URL.join(basePath, buffer.uri), \"arraybuffer\", progress?.createCallback(0.2))\r\n                        .then(bin => {\r\n                            this._buffers[j] = bin;\r\n                        }));\r\n                }\r\n            });\r\n            return Promise.all(promises);\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n\r\n    loadTextureFromglTF(index: number, sRGB: boolean, basePath: string, progress?: IBatchProgress): Promise<Texture2D> {\r\n        let data = this._data;\r\n\r\n        let tex = data.textures[index];\r\n        let imgSource = tex.source;\r\n        let glTFImg = data.images[imgSource];\r\n        let samplerSource = tex.sampler;\r\n        let glTFSampler = data.samplers ? data.samplers[samplerSource] : undefined;\r\n\r\n        let constructParams = this.getTextureConstructParams(glTFImg, glTFSampler, sRGB);\r\n        let propertyParams = this.getTexturePropertyParams(glTFSampler);\r\n\r\n        if (glTFImg.bufferView != null) {\r\n            let bufferView = data.bufferViews[glTFImg.bufferView];\r\n            let buffer = this._buffers[bufferView.buffer];\r\n            let byteOffset = bufferView.byteOffset || 0;\r\n            let byteLength = bufferView.byteLength;\r\n\r\n            let arraybuffer = buffer.slice(byteOffset, byteOffset + byteLength);\r\n\r\n            return this.loadTextureFromBuffer(arraybuffer, glTFImg.mimeType, constructParams, propertyParams, progress).then(res => {\r\n                this._textures[index] = res;\r\n                this.addDep(res);\r\n                return res;\r\n            });\r\n        }\r\n        else {\r\n            return this.loadTexture(URL.join(basePath, glTFImg.uri), constructParams, propertyParams, progress).then(res => {\r\n                this._textures[index] = res;\r\n                this.addDep(res);\r\n                return res;\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @param basePath \r\n     * @param progress \r\n     * @returns \r\n     */\r\n    loadTextures(basePath: string, progress?: IBatchProgress): Promise<any> {\r\n        let data = this._data;\r\n        let materials = data.materials;\r\n        let textures = data.textures;\r\n        let promises: Array<Promise<Texture2D>> = [];\r\n        if (materials && textures) {\r\n            for (let glTFMaterial of data.materials) {\r\n                let pbrMetallicRoughness = glTFMaterial.pbrMetallicRoughness;\r\n                if (pbrMetallicRoughness) {\r\n                    if (pbrMetallicRoughness.baseColorTexture) {\r\n                        let index = pbrMetallicRoughness.baseColorTexture.index;\r\n                        let sRGB = true;\r\n                        let promise = this.loadTextureFromglTF(index, sRGB, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                    if (pbrMetallicRoughness.metallicRoughnessTexture) {\r\n                        let index = pbrMetallicRoughness.metallicRoughnessTexture.index;\r\n                        let sRGB = false;\r\n                        let promise = this.loadTextureFromglTF(index, sRGB, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                }\r\n                if (glTFMaterial.normalTexture) {\r\n                    let index = glTFMaterial.normalTexture.index;\r\n                    let sRGB = false;\r\n                    let promise = this.loadTextureFromglTF(index, sRGB, basePath, progress);\r\n                    promises.push(promise);\r\n                }\r\n                if (glTFMaterial.occlusionTexture) {\r\n                    let index = glTFMaterial.occlusionTexture.index;\r\n                    let sRGB = false;\r\n                    let promise = this.loadTextureFromglTF(index, sRGB, basePath, progress);\r\n                    promises.push(promise);\r\n                }\r\n                if (glTFMaterial.emissiveTexture) {\r\n                    let index = glTFMaterial.emissiveTexture.index;\r\n                    let sRGB = true;\r\n                    let promise = this.loadTextureFromglTF(index, sRGB, basePath, progress);\r\n                    promises.push(promise);\r\n                }\r\n            }\r\n        }\r\n        this._extensions.forEach(extension => {\r\n            if (extension.loadTextures) {\r\n                let promise = extension.loadTextures(basePath, progress);\r\n                promises.push(promise);\r\n            }\r\n\r\n        });\r\n        return Promise.all(promises);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @returns \r\n     */\r\n    importMaterials() {\r\n        return Promise.resolve().then(() => {\r\n            let data = this._data;\r\n            if (data.materials) {\r\n                data.materials.forEach((glTFMat, index) => {\r\n                    let mat = this.createMaterial(glTFMat);\r\n                    this._materials[index++] = mat;\r\n                    this.addDep(mat);\r\n                })\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @returns \r\n     */\r\n    importMeshes() {\r\n        return Promise.resolve().then(() => {\r\n            let data = this._data;\r\n            if (data.meshes && data.nodes) {\r\n                data.nodes.forEach((glTFNode) => {\r\n                    if (glTFNode.mesh != null) {\r\n                        let glTFMesh = this._data.meshes[glTFNode.mesh];\r\n                        let glTFSkin = this._data.skins?.[glTFNode.skin];\r\n                        let key = glTFNode.mesh + (glTFNode.skin != null ? (\"_\" + glTFNode.skin) : \"\");\r\n                        let mesh = this._meshes[key];\r\n                        if (!mesh) {\r\n                            mesh = this.createMesh(glTFMesh, glTFSkin);\r\n                            this._meshes[key] = mesh;\r\n                            this.addDep(mesh);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @param data \r\n     * @param createURL \r\n     * @param progress \r\n     * @returns \r\n     */\r\n    _parse(data: glTF.glTF, createURL: string, progress?: IBatchProgress): Promise<void> {\r\n        if (!data.asset || data.asset.version !== \"2.0\") {\r\n            throw new Error(\"glTF version wrong!\");\r\n        }\r\n\r\n        this._data = data;\r\n        let basePath = URL.getPath(createURL);\r\n        this._idCounter = {};\r\n\r\n        data.extensionsUsed?.forEach(value => {\r\n            let extensionFactory = glTFResource._Extensions[value];\r\n            if (!extensionFactory) {\r\n                console.warn(`glTF: unsupported extension: ${value}`);\r\n            }\r\n            else {\r\n                this._extensions.push(extensionFactory(this));\r\n            }\r\n        });\r\n\r\n        let promise: Promise<any> = this.loadBinary(basePath, progress);\r\n\r\n        promise = promise.then(() => {\r\n            return this.loadTextures(basePath, progress);\r\n        });\r\n\r\n        promise = promise.then(() => {\r\n            return this.importMeshes();\r\n        });\r\n\r\n        promise = promise.then(() => {\r\n            return this.importMaterials();\r\n        });\r\n\r\n        return promise.then(() => {\r\n            if (this._pendingOps.length > 0) {\r\n                return Promise.all(this._pendingOps).then(() => {\r\n                    this._idCounter = null;\r\n                });\r\n            }\r\n            else {\r\n                this._idCounter = null;\r\n                return Promise.resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param data \r\n     * @param createURL \r\n     * @param progress \r\n     */\r\n    _parseglb(data: ArrayBuffer, createURL: string, progress?: IBatchProgress): Promise<void> {\r\n        let basePath = URL.getPath(createURL);\r\n        // let promise: Promise<any>;\r\n        this._idCounter = {};\r\n\r\n        let byte = new Byte(data);\r\n        let magic = byte.readUint32();\r\n        //  ASCII string glTF\r\n        if (magic != 0x46546C67) {\r\n            throw new Error(\"glb fromat wrong!\");\r\n        }\r\n\r\n        let version = byte.readUint32();\r\n        if (version != 2) {\r\n            throw new Error(\"glb version wrong!\");\r\n        }\r\n\r\n        // total length of the Binary glTF, including header and all chunks, in bytes.\r\n        let length = byte.readUint32();\r\n\r\n        /**\r\n         * first chunk: json \r\n         * second chunk: buffer\r\n         * other chunk: ignore\r\n         */\r\n\r\n        // first chunk json\r\n        let firstChunkLength = byte.readUint32();\r\n        let firstChunkType = byte.readUint32();\r\n        if (firstChunkType != 0x4E4F534A) {\r\n            throw new Error(\"glb json chunk data wrong!\");\r\n        }\r\n\r\n        let firstChunkData = byte.readArrayBuffer(firstChunkLength);\r\n        let texDecoder = new TextDecoder();\r\n        let jsonStr = texDecoder.decode(firstChunkData);\r\n        let glTFObj: glTF.glTF = JSON.parse(jsonStr);\r\n        this._data = glTFObj;\r\n\r\n        // binary data json\r\n        let chunkLength = byte.readUint32();\r\n        let chunkType = byte.readUint32();\r\n        if (chunkType != 0x004E4942) {\r\n            throw new Error(\"glb bin chunk data wrong!\");\r\n        }\r\n        let firstBuffer = glTFObj.buffers?.[0];\r\n        firstBuffer.byteLength = firstBuffer.byteLength ? (Math.min(firstBuffer.byteLength, chunkLength)) : chunkLength;\r\n\r\n        this._buffers[0] = byte.readArrayBuffer(firstBuffer.byteLength);\r\n\r\n        glTFObj.extensionsUsed?.forEach(value => {\r\n            let extensionFactory = glTFResource._Extensions[value];\r\n            if (!extensionFactory) {\r\n                console.warn(`glTF: unsupported extension: ${value}`);\r\n            }\r\n            else {\r\n                this._extensions.push(extensionFactory(this));\r\n            }\r\n            // this._extensions.sort((a, b) => )\r\n        });\r\n\r\n        let promise: Promise<any> = this.loadTextures(basePath, progress);\r\n        promise = promise.then(() => {\r\n            return this.importMeshes();\r\n        });\r\n\r\n        promise = promise.then(() => {\r\n            return this.importMaterials();\r\n        });\r\n\r\n        return promise.then(() => {\r\n            if (this._pendingOps.length > 0) {\r\n                return Promise.all(this._pendingOps).then(() => {\r\n                    this._idCounter = null;\r\n                });\r\n            }\r\n            else {\r\n                this._idCounter = null;\r\n                return Promise.resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    public create(): Node {\r\n        let data = this._data;\r\n\r\n        this._scenes.length = 0;\r\n        this._nodes.length = 0;\r\n        this._idCounter = {};\r\n\r\n        this.loadNodes(data.nodes);\r\n        this.buildHierarchy(data.nodes);\r\n        this.loadScenes(data.scenes);\r\n        this.loadAnimations(data.animations);\r\n\r\n        let defaultSceneIndex = (data.scene != undefined) ? data.scene : 0;\r\n        let defaultScene: Sprite3D = this._scenes[defaultSceneIndex];\r\n        this._scenes.length = 0;\r\n        this._nodes.length = 0;\r\n        this._idCounter = null;\r\n\r\n        return defaultScene;\r\n    }\r\n\r\n    protected loadTextureFromBuffer(buffer: ArrayBuffer, mimeType: glTF.glTFImageMimeType, constructParams: TextureConstructParams, propertyParams: TexturePropertyParams, progress?: IBatchProgress): Promise<Texture2D> {\r\n        let base64: string = Base64Tool.encode(buffer);\r\n        let url: string = `data:${mimeType};base64,${base64}`;\r\n\r\n        return ILaya.loader.load({ url: url, constructParams: constructParams, propertyParams: propertyParams },\r\n            Loader.TEXTURE2D, progress?.createCallback());\r\n    }\r\n\r\n    protected loadTexture(url: string, constructParams: TextureConstructParams, propertyParams: TexturePropertyParams, progress?: IBatchProgress): Promise<Texture2D> {\r\n        return ILaya.loader.load({ url: url, constructParams: constructParams, propertyParams: propertyParams },\r\n            Loader.TEXTURE2D, progress?.createCallback());\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 node name\r\n     */\r\n    protected generateId(context: string): string {\r\n        let i = this._idCounter[context];\r\n        if (i == null)\r\n            i = 0;\r\n        else\r\n            i++;\r\n        this._idCounter[context] = i;\r\n        return i.toString();\r\n    }\r\n\r\n    /**\r\n     * 根据数据类型获取分量\r\n     * @param type \r\n     */\r\n    private getAccessorComponentsNum(type: glTF.glTFAccessorType): number {\r\n        switch (type) {\r\n            case \"SCALAR\": return 1;\r\n            case \"VEC2\": return 2;\r\n            case \"VEC3\": return 3;\r\n            case \"VEC4\": return 4;\r\n            case \"MAT2\": return 4;\r\n            case \"MAT3\": return 9;\r\n            case \"MAT4\": return 16;\r\n            default: return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取 attribute 分量\r\n     * @param attriStr \r\n     */\r\n    private getAttributeNum(attriStr: string): number {\r\n        switch (attriStr) {\r\n            case \"POSITION\": return 3;\r\n            case \"NORMAL\": return 3;\r\n            case \"COLOR\": return 4;\r\n            case \"UV\": return 2;\r\n            case \"UV1\": return 2;\r\n            case \"BLENDWEIGHT\": return 4;\r\n            case \"BLENDINDICES\": return 4;\r\n            case \"TANGENT\": return 4;\r\n            default: return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 buffer constructor\r\n     * @param componentType \r\n     */\r\n    private _getTypedArrayConstructor(componentType: glTF.glTFAccessorComponentType) {\r\n        switch (componentType) {\r\n            case glTF.glTFAccessorComponentType.BYTE: return Int8Array;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_BYTE: return Uint8Array;\r\n            case glTF.glTFAccessorComponentType.SHORT: return Int16Array;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_SHORT: return Uint16Array;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_INT: return Uint32Array;\r\n            case glTF.glTFAccessorComponentType.FLOAT: return Float32Array;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 accessor data Type byte stride\r\n     * @param componentType \r\n     */\r\n    _getAccessorDateByteStride(componentType: glTF.glTFAccessorComponentType) {\r\n        switch (componentType) {\r\n            case glTF.glTFAccessorComponentType.BYTE: return 1;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_BYTE: return 1;\r\n            case glTF.glTFAccessorComponentType.SHORT: return 2;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_SHORT: return 2;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_INT: return 4;\r\n            case glTF.glTFAccessorComponentType.FLOAT: return 4;\r\n        }\r\n    }\r\n\r\n    private getBufferFormBufferView(bufferView: glTF.glTFBufferView, byteOffset: number, accessorType: glTF.glTFAccessorType, componentType: glTF.glTFAccessorComponentType, count: number) {\r\n        let buffer: ArrayBuffer = this._buffers[bufferView.buffer];\r\n\r\n        const constructor = this._getTypedArrayConstructor(componentType);\r\n        let componentCount: number = this.getAccessorComponentsNum(accessorType);\r\n        let res;\r\n        if (bufferView.byteStride) {\r\n            let vertexStride = bufferView.byteStride;\r\n            let dataByteStride = this._getAccessorDateByteStride(componentType);\r\n            let dataStride = vertexStride / dataByteStride;\r\n\r\n            let elementByteOffset = byteOffset || 0;\r\n            let elementOffset = elementByteOffset / dataByteStride;\r\n\r\n            // let d = new ArrayBuffer(dataStride * accessorDataCount);\r\n            let dataReader = new constructor(buffer, bufferView.byteOffset || 0, bufferView.byteLength / dataByteStride);\r\n            res = new constructor(count);\r\n            let resIndex = 0;\r\n            for (let index = 0; index < count; index++) {\r\n                let componentOffset = index * dataStride;\r\n                for (let i = 0; i < componentCount; i++) {\r\n                    res[resIndex++] = dataReader[componentOffset + elementOffset + i];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            let bufferOffset: number = (bufferView.byteOffset || 0) + (byteOffset || 0);\r\n            res = new constructor(buffer, bufferOffset, count);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * 获取 accessor buffer 数据\r\n     * @param accessorIndex \r\n     */\r\n    private getBufferwithAccessorIndex(accessorIndex: number) {\r\n        let accessor: glTF.glTFAccessor = this._data.accessors[accessorIndex];\r\n        if (!accessor)\r\n            return null;\r\n\r\n        let count: number = accessor.count;\r\n        let componentCount: number = this.getAccessorComponentsNum(accessor.type);\r\n        let accessorDataCount: number = count * componentCount;\r\n\r\n        let res;\r\n\r\n        let bufferView: glTF.glTFBufferView = this._data.bufferViews[accessor.bufferView];\r\n        if (bufferView) {\r\n            res = this.getBufferFormBufferView(bufferView, accessor.byteOffset, accessor.type, accessor.componentType, accessorDataCount);\r\n        }\r\n        else {\r\n            const constructor = this._getTypedArrayConstructor(accessor.componentType);\r\n            res = new constructor(accessorDataCount).fill(0);\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            let sparseCount = accessor.sparse.count;\r\n            let sparseIndices = accessor.sparse.indices;\r\n            let sparseIndicesBufferView = this._data.bufferViews[sparseIndices.bufferView];\r\n            let sparseIndicesData = this.getBufferFormBufferView(sparseIndicesBufferView, sparseIndices.byteOffset, accessor.type, sparseIndices.componentType, sparseCount);\r\n\r\n            let sparseValues = accessor.sparse.values;\r\n            let sparseValuesBufferView = this._data.bufferViews[sparseValues.bufferView];\r\n            let sparseValuesData = this.getBufferFormBufferView(sparseValuesBufferView, sparseValues.byteOffset, accessor.type, accessor.componentType, sparseCount * componentCount);\r\n\r\n            for (let index = 0; index < sparseCount; index++) {\r\n                let i = sparseIndicesData[index];\r\n                for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\r\n                    res[i * componentCount + componentIndex] = sparseValuesData[index * componentCount + componentIndex];\r\n                }\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * 判断 Texture 是否需要 mipmap\r\n     * @param glTFImage \r\n     * @param glTFSampler \r\n     */\r\n    private getTextureMipmap(glTFSampler: glTF.glTFSampler): boolean {\r\n        if (glTFSampler)\r\n            return glTFSampler.minFilter != glTF.glTFTextureMinFilter.LINEAR &&\r\n                glTFSampler.minFilter != glTF.glTFTextureMinFilter.NEAREST;\r\n        else\r\n            return true;\r\n    }\r\n\r\n    /**\r\n     * 获取 Texture format\r\n     * @param glTFImage \r\n     */\r\n    private getTextureFormat(glTFImage: glTF.glTFImage): number {\r\n        if (glTFImage.mimeType === glTF.glTFImageMimeType.JPEG) {\r\n            return 0;   // R8G8B8\r\n        }\r\n        else {\r\n            return 1;   // R8G8B8A8\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取 Texture filter mode\r\n     * @param glTFSampler \r\n     */\r\n    private getTextureFilterMode(glTFSampler: glTF.glTFSampler): number {\r\n\r\n        if (!glTFSampler) {\r\n            return 1;\r\n        }\r\n\r\n        if (glTFSampler.magFilter === glTF.glTFTextureMagFilter.NEAREST) {\r\n            return 0;   // FilterMode.Point\r\n        }\r\n        else if (this.getTextureMipmap(glTFSampler)) {\r\n            if (glTFSampler.minFilter === glTF.glTFTextureMinFilter.LINEAR_MIPMAP_LINEAR)\r\n                return 2;   // FilterMode.Trilinear\r\n\r\n            return 1;   // FilterMode.Bilinear\r\n        }\r\n\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * 获取 Texture warp mode\r\n     * @param mode \r\n     */\r\n    private getTextureWrapMode(mode: glTF.glTFTextureWrapMode): number {\r\n        if (mode === glTF.glTFTextureWrapMode.CLAMP_TO_EDGE) {\r\n            return 1;   // WrapMode.Clamp\r\n        }\r\n        return 0;   // WrapMode.Repeat\r\n    }\r\n\r\n    /**\r\n    * 获取 Texture 初始化参数\r\n    * @param glTFImage \r\n    * @param glTFSampler \r\n    */\r\n    private getTextureConstructParams(glTFImage: glTF.glTFImage, glTFSampler: glTF.glTFSampler, sRGB: boolean): ConstructorParameters<typeof Texture2D> {\r\n        let constructParams: ConstructorParameters<typeof Texture2D> = [\r\n            0, // width\r\n            0, // height\r\n            this.getTextureFormat(glTFImage), // format\r\n            this.getTextureMipmap(glTFSampler),  // mipmap\r\n            false, //can read\r\n            sRGB // sRGB\r\n\r\n        ];\r\n        return constructParams;\r\n    }\r\n\r\n    /**\r\n     * 获取 Texture 属性参数\r\n     * @param glTFImage \r\n     * @param glTFSampler \r\n     */\r\n    private getTexturePropertyParams(glTFSampler: glTF.glTFSampler): TexturePropertyParams {\r\n        if (!glTFSampler) {\r\n            return null;\r\n        }\r\n\r\n        let propertyParams: TexturePropertyParams = {\r\n            filterMode: this.getTextureFilterMode(glTFSampler),\r\n            wrapModeU: this.getTextureWrapMode(glTFSampler.wrapS),\r\n            wrapModeV: this.getTextureWrapMode(glTFSampler.wrapT),\r\n            anisoLevel: 1,\r\n            hdrEncodeFormat: HDREncodeFormat.NONE\r\n        };\r\n        return propertyParams;\r\n    }\r\n\r\n    /**\r\n     * 根据 glTFTextureInfo 获取 Texture2D\r\n     * @param glTFTextureInfo \r\n     */\r\n    getTextureWithInfo(glTFTextureInfo: glTF.glTFTextureInfo): Texture2D {\r\n\r\n        // uv 非 0 \r\n        if (glTFTextureInfo.texCoord) {\r\n            // todo 非0 uv \r\n            console.warn(\"glTF Loader: non 0 uv channel unsupported.\");\r\n        }\r\n\r\n        // let glTFImage: glTF.glTFTexture = this._glTF.textures[glTFTextureInfo.index];\r\n        return this._textures[glTFTextureInfo.index];\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param glTFMaterial \r\n     * @param material \r\n     */\r\n    applyMaterialRenderState(glTFMaterial: glTF.glTFMaterial, material: Material) {\r\n        // material render state\r\n        let renderMode: glTF.glTFMaterialAlphaMode = glTFMaterial.alphaMode || glTF.glTFMaterialAlphaMode.OPAQUE;\r\n        switch (renderMode) {\r\n            case glTF.glTFMaterialAlphaMode.OPAQUE: {\r\n                material.materialRenderMode = MaterialRenderMode.RENDERMODE_OPAQUE;\r\n                break;\r\n            }\r\n            case glTF.glTFMaterialAlphaMode.BLEND: {\r\n                material.materialRenderMode = MaterialRenderMode.RENDERMODE_TRANSPARENT;\r\n                break;\r\n            }\r\n            case glTF.glTFMaterialAlphaMode.MASK: {\r\n                material.materialRenderMode = MaterialRenderMode.RENDERMODE_CUTOUT;\r\n                break;\r\n            }\r\n            default: {\r\n                // todo\r\n            }\r\n        }\r\n\r\n        material.alphaTestValue = glTFMaterial.alphaCutoff ?? 0.5;\r\n\r\n        if (glTFMaterial.doubleSided) {\r\n            material.cull = RenderState.CULL_NONE;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @param glTFMaterial \r\n     * @param material \r\n     */\r\n    applyDefaultMaterialProperties(glTFMaterial: glTF.glTFMaterial, material: Material) {\r\n\r\n        {\r\n            let pbrMetallicRoughness = glTFMaterial.pbrMetallicRoughness;\r\n            if (pbrMetallicRoughness) {\r\n                if (pbrMetallicRoughness.baseColorFactor) {\r\n                    let baseColorFactor = material.getVector4(\"u_BaseColorFactor\");\r\n                    baseColorFactor.fromArray(pbrMetallicRoughness.baseColorFactor);\r\n                    material.setVector4(\"u_BaseColorFactor\", baseColorFactor);\r\n                }\r\n                if (pbrMetallicRoughness.baseColorTexture) {\r\n                    let tex = this.getTextureWithInfo(pbrMetallicRoughness.baseColorTexture);\r\n                    material.setTexture(\"u_BaseColorTexture\", tex);\r\n                    material.setDefine(glTFShader.Define_BaseMap, true);\r\n                }\r\n\r\n                let metallicFactor = pbrMetallicRoughness.metallicFactor ?? 1.0;\r\n                material.setFloat(\"u_MetallicFactor\", metallicFactor);\r\n\r\n                let roughnessFactor = pbrMetallicRoughness.roughnessFactor ?? 1.0;\r\n                material.setFloat(\"u_RoughnessFactor\", roughnessFactor);\r\n\r\n                if (pbrMetallicRoughness.metallicRoughnessTexture) {\r\n                    let tex = this.getTextureWithInfo(pbrMetallicRoughness.metallicRoughnessTexture);\r\n                    material.setTexture(\"u_MetallicRoughnessTexture\", tex);\r\n                    material.setDefine(glTFShader.Define_MetallicRoughnessMap, true);\r\n                }\r\n            }\r\n\r\n            if (glTFMaterial.normalTexture) {\r\n                let tex = this.getTextureWithInfo(glTFMaterial.normalTexture);\r\n                material.setTexture(\"u_NormalTexture\", tex);\r\n                material.setDefine(glTFShader.Define_NormalMap, true);\r\n                let normalScale = glTFMaterial.normalTexture.scale ?? 1.0;\r\n                material.setFloat(\"u_NormalScale\", normalScale);\r\n            }\r\n\r\n            if (glTFMaterial.occlusionTexture) {\r\n                let tex = this.getTextureWithInfo(glTFMaterial.occlusionTexture);\r\n                material.setTexture(\"u_OcclusionTexture\", tex);\r\n                material.setDefine(glTFShader.Define_OcclusionMap, true);\r\n                let strength = glTFMaterial.occlusionTexture.strength ?? 1.0;\r\n                material.setFloat(\"u_OcclusionStrength\", strength);\r\n            }\r\n\r\n            if (glTFMaterial.emissiveFactor) {\r\n                let emissionFactor = material.getVector3(\"u_EmissionFactor\");\r\n                emissionFactor.fromArray(glTFMaterial.emissiveFactor);\r\n                material.setVector3(\"u_EmissionFactor\", emissionFactor);\r\n                material.setDefine(PBRShaderLib.DEFINE_EMISSION, true);\r\n            }\r\n\r\n            if (glTFMaterial.emissiveTexture) {\r\n                let tex = this.getTextureWithInfo(glTFMaterial.emissiveTexture);\r\n                material.setTexture(\"u_EmissionTexture\", tex);\r\n                material.setDefine(PBRShaderLib.DEFINE_EMISSION, true);\r\n                material.setDefine(glTFShader.Define_EmissionMap, true);\r\n            }\r\n\r\n            this.applyMaterialRenderState(glTFMaterial, material);\r\n        }\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * 根据 glTFMaterial 节点数据创建 default Material\r\n     * @param glTFMaterial \r\n     */\r\n    createDefaultMaterial(glTFMaterial: glTF.glTFMaterial): Material {\r\n        let material = new Material();\r\n        material.setShaderName(glTFShader.ShaderName);\r\n\r\n        // apply glTF Material property\r\n        material.name = glTFMaterial.name ? glTFMaterial.name : \"\";\r\n\r\n        this.applyDefaultMaterialProperties(glTFMaterial, material);\r\n\r\n        return material;\r\n    }\r\n\r\n    protected createMaterial(glTFMaterial: glTF.glTFMaterial) {\r\n        let mat: Material = null;\r\n        let propertiesExts = [];\r\n        for (const key in glTFMaterial.extensions) {\r\n            let extension = this._extensions.find(value => value.name == key);\r\n            if (extension) {\r\n                if (extension.createMaterial) {\r\n                    mat = extension.createMaterial(glTFMaterial);\r\n                }\r\n                if (extension.additionMaterialProperties) {\r\n                    propertiesExts.push(extension);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!mat) {\r\n            mat = this.createDefaultMaterial(glTFMaterial);\r\n        }\r\n        propertiesExts.forEach(extension => {\r\n            extension.additionMaterialProperties(glTFMaterial, mat);\r\n        });\r\n\r\n        return mat;\r\n    }\r\n\r\n    /**\r\n     * 获取 gltf mesh 中 material \r\n     * @param glTFMesh \r\n     */\r\n    private pickMeshMaterials(glTFMesh: glTF.glTFMesh): Material[] {\r\n        let materials: Material[] = [];\r\n\r\n        glTFMesh.primitives.forEach(primitive => {\r\n            if (primitive.material != undefined) {\r\n                let material: Material = this._materials[primitive.material];\r\n                materials.push(material);\r\n            }\r\n            else {\r\n                let material: Material = new PBRStandardMaterial();\r\n                materials.push(material);\r\n                this._materials.push(material);\r\n                primitive.material = this._materials.indexOf(material);\r\n            }\r\n        });\r\n\r\n        return materials;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载场景节点\r\n     * @param glTFScene \r\n     */\r\n    private loadScenes(glTFScenes?: glTF.glTFScene[]): void {\r\n        if (!glTFScenes)\r\n            return;\r\n\r\n        glTFScenes.forEach((glTFScene, index) => {\r\n            this._scenes[index] = this._loadScene(glTFScene);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载场景节点\r\n     * @param glTFScene \r\n     */\r\n    private _loadScene(glTFScene: glTF.glTFScene): Sprite3D {\r\n        // todo extension and extra\r\n\r\n        return this._createSceneNode(glTFScene);\r\n    }\r\n\r\n    /**\r\n     * 创建 glTFScene 节点\r\n     * @param glTFScene \r\n     */\r\n    private _createSceneNode(glTFScene: glTF.glTFScene): Sprite3D {\r\n        let glTFSceneNode: Sprite3D = new Sprite3D(glTFScene.name || \"Scene\");\r\n        glTFScene.nodes.forEach(nodeIndex => {\r\n            let sprite: Sprite3D = this._nodes[nodeIndex];\r\n            glTFSceneNode.addChild(sprite);\r\n        });\r\n\r\n        return glTFSceneNode;\r\n    }\r\n\r\n    /**\r\n     * 应用 Transform 信息\r\n     * @param glTFNode \r\n     * @param sprite \r\n     */\r\n    private applyTransform(glTFNode: glTF.glTFNode, sprite: Sprite3D): void {\r\n        if (glTFNode.matrix) {\r\n            let localMatrix: Matrix4x4 = sprite.transform.localMatrix;\r\n            localMatrix.elements.set(glTFNode.matrix);\r\n            sprite.transform.localMatrix = localMatrix;\r\n        }\r\n        else {\r\n            let localPosition: Vector3 = sprite.transform.localPosition;\r\n            let localRotation: Quaternion = sprite.transform.localRotation;\r\n            let localScale: Vector3 = sprite.transform.localScale;\r\n            glTFNode.translation && localPosition.fromArray(glTFNode.translation);\r\n            glTFNode.rotation && localRotation.fromArray(glTFNode.rotation);\r\n            glTFNode.scale && localScale.fromArray(glTFNode.scale);\r\n            sprite.transform.localPosition = localPosition;\r\n            sprite.transform.localRotation = localRotation;\r\n            sprite.transform.localScale = localScale;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 构建 当前 glTF 对象 节点树\r\n     * @param glTFNodes \r\n     */\r\n    private buildHierarchy(glTFNodes: glTF.glTFNode[]): void {\r\n        glTFNodes.forEach((glTFNode: glTF.glTFNode, index: number) => {\r\n            let sprite: Sprite3D = this._nodes[index];\r\n            if (glTFNode.children) {\r\n                glTFNode.children.forEach((childIndex: number) => {\r\n                    let child: Sprite3D = this._nodes[childIndex];\r\n                    sprite.addChild(child);\r\n                });\r\n            }\r\n        });\r\n\r\n        glTFNodes.forEach((glTFNode: glTF.glTFNode, index: number) => {\r\n            let sprite: Sprite3D = this._nodes[index];\r\n            if (sprite instanceof SkinnedMeshSprite3D) {\r\n                this.fixSkinnedSprite(glTFNode, sprite);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载 glTF 节点\r\n     * @param glTFNodes \r\n     */\r\n    private loadNodes(glTFNodes?: glTF.glTFNode[]): void {\r\n        if (!glTFNodes)\r\n            return;\r\n\r\n        glTFNodes.forEach((glTFNode: glTF.glTFNode, index: number) => {\r\n            this._nodes[index] = this.loadNode(glTFNode);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载 glTF 节点\r\n     * @param glTFNode \r\n     */\r\n    private loadNode(glTFNode: glTF.glTFNode): Sprite3D {\r\n        // todo extension and extra\r\n\r\n        return this.createSprite3D(glTFNode);\r\n    }\r\n\r\n    /**\r\n     * 创建 节点对象\r\n     * @param glTFNode \r\n     */\r\n    private createSprite3D(glTFNode: glTF.glTFNode): Sprite3D {\r\n        let sprite: Sprite3D;\r\n        if (glTFNode.skin != null) {\r\n            sprite = this.createSkinnedMeshSprite3D(glTFNode);\r\n            this.applyTransform(glTFNode, sprite);\r\n        }\r\n        else if (glTFNode.mesh != null) {\r\n            sprite = this.createMeshSprite3D(glTFNode);\r\n            this.applyTransform(glTFNode, sprite);\r\n        }\r\n        else {\r\n            sprite = new Sprite3D(glTFNode.name);\r\n            this.applyTransform(glTFNode, sprite);\r\n        }\r\n\r\n        let storeId = this.generateId(\"node\");\r\n        sprite.name = glTFNode.name || `node_${storeId}`;\r\n        (<any>sprite._extra).storeId = \"#\" + storeId;\r\n\r\n        return sprite;\r\n    }\r\n\r\n    /**\r\n     * 创建 MeshSprite3D 对象\r\n     * @param glTFNode \r\n     */\r\n    private createMeshSprite3D(glTFNode: glTF.glTFNode): MeshSprite3D {\r\n        let glTFMesh: glTF.glTFMesh = this._data.meshes[glTFNode.mesh];\r\n        let mesh = this._meshes[glTFNode.mesh];\r\n        let materials: Material[] = this.pickMeshMaterials(glTFMesh);\r\n        let sprite: MeshSprite3D = new MeshSprite3D(mesh, glTFNode.name);\r\n        sprite.meshRenderer.sharedMaterials = materials;\r\n        sprite.meshRenderer.receiveShadow = true;\r\n        sprite.meshRenderer.castShadow = true;\r\n\r\n        if (glTFMesh.weights) {\r\n            let render = sprite.meshRenderer;\r\n            glTFMesh.weights.forEach((weight, index) => {\r\n                let target = mesh.morphTargetData.getMorphChannelbyIndex(index);\r\n                render.setMorphChannelWeight(target.name, weight);\r\n            });\r\n        }\r\n\r\n        return sprite;\r\n    }\r\n\r\n    /**\r\n     * 创建 MeshSprite3D 对象\r\n     * @param glTFNode \r\n     */\r\n    private createSkinnedMeshSprite3D(glTFNode: glTF.glTFNode): SkinnedMeshSprite3D {\r\n        let glTFMesh: glTF.glTFMesh = this._data.meshes[glTFNode.mesh];\r\n        let mesh: Mesh = this._meshes[glTFNode.mesh + \"_\" + glTFNode.skin];\r\n        let materials: Material[] = this.pickMeshMaterials(glTFMesh);\r\n        let sprite: SkinnedMeshSprite3D = new SkinnedMeshSprite3D(mesh, glTFNode.name);\r\n        sprite.skinnedMeshRenderer.sharedMaterials = materials;\r\n        sprite.skinnedMeshRenderer.receiveShadow = true;\r\n        sprite.skinnedMeshRenderer.castShadow = true;\r\n\r\n        if (glTFMesh.weights) {\r\n            let render = sprite.skinnedMeshRenderer;\r\n            glTFMesh.weights.forEach((weight, index) => {\r\n                let target = mesh.morphTargetData.getMorphChannelbyIndex(index);\r\n                render.setMorphChannelWeight(target.name, weight);\r\n            });\r\n        }\r\n\r\n        return sprite;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 attribute buffer 数据\r\n     * @param attributeAccessorIndex \r\n     * @param layaDeclarStr \r\n     * @param attributes \r\n     * @param vertexDeclarArr \r\n     * @param func \r\n     */\r\n    private getArrributeBuffer(attributeAccessorIndex: number, layaDeclarStr: string, attributeMap: Map<string, Float32Array>, vertexDeclarArr: string[]): Float32Array {\r\n        let attributeBuffer: Float32Array = <Float32Array>this.getBufferwithAccessorIndex(attributeAccessorIndex);\r\n        if (!attributeBuffer)\r\n            return null;\r\n        vertexDeclarArr.push(layaDeclarStr);\r\n        let res: Float32Array = attributeBuffer;\r\n        attributeMap.set(layaDeclarStr, res);\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 glTFMeshPrimitive index buffer\r\n     * @param attributeAccessorIndex \r\n     * @param vertexCount \r\n     */\r\n    private getIndexBuffer(attributeAccessorIndex: number, vertexCount: number): Uint32Array {\r\n        let indexBuffer: Uint32Array = <Uint32Array>this.getBufferwithAccessorIndex(attributeAccessorIndex);\r\n        if (indexBuffer) {\r\n            return new Uint32Array(indexBuffer).reverse();\r\n            // return indexBuffer;\r\n        }\r\n        else {\r\n            let indices: Uint32Array = new Uint32Array(vertexCount);\r\n            for (let i = 0; i < vertexCount; i++) {\r\n                indices[i] = vertexCount - 1 - i;\r\n            }\r\n            return indices;\r\n        }\r\n    }\r\n\r\n    private calculateFlatNormal(positions: Float32Array, indexArray: Uint32Array): Float32Array {\r\n        let normal = new Float32Array(positions.length);\r\n\r\n        for (let index = 0; index < indexArray.length; index += 3) {\r\n            // todo\r\n            let i0 = indexArray[index];\r\n            let i1 = indexArray[index + 1];\r\n            let i2 = indexArray[index + 2];\r\n\r\n            let p0x = positions[i0 * 3];\r\n            let p0y = positions[i0 * 3 + 1];\r\n            let p0z = positions[i0 * 3 + 2];\r\n\r\n            let p1x = positions[i1 * 3];\r\n            let p1y = positions[i1 * 3 + 1];\r\n            let p1z = positions[i1 * 3 + 2];\r\n\r\n            let p2x = positions[i2 * 3];\r\n            let p2y = positions[i2 * 3 + 1];\r\n            let p2z = positions[i2 * 3 + 2];\r\n\r\n            let x1 = p1x - p0x;\r\n            let y1 = p1y - p0y;\r\n            let z1 = p1z - p0z;\r\n\r\n            let x2 = p2x - p0x;\r\n            let y2 = p2y - p0y;\r\n            let z2 = p2z - p0z;\r\n\r\n            let yz = y1 * z2 - z1 * y2;\r\n            let xz = z1 * x2 - x1 * z2;\r\n            let xy = x1 * y2 - y1 * x2;\r\n\r\n            let invPyth = -1.0 / (Math.sqrt((yz * yz) + (xz * xz) + (xy * xy)));\r\n            let nx = yz * invPyth;\r\n            let ny = xz * invPyth;\r\n            let nz = xy * invPyth;\r\n\r\n            normal[i0 * 3] = nx;\r\n            normal[i1 * 3] = nx;\r\n            normal[i2 * 3] = nx;\r\n\r\n            normal[i0 * 3 + 1] = ny;\r\n            normal[i1 * 3 + 1] = ny;\r\n            normal[i2 * 3 + 1] = ny;\r\n\r\n            normal[i0 * 3 + 2] = nz;\r\n            normal[i1 * 3 + 2] = nz;\r\n            normal[i2 * 3 + 2] = nz;\r\n        }\r\n\r\n        return normal;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 解析 subData 记录数据\r\n     * @param subDatas \r\n     * @param layaMesh \r\n     */\r\n    private parseMeshwithSubMeshData(subDatas: PrimitiveSubMesh[], layaMesh: Mesh): void {\r\n        let vertexCount: number = 0;\r\n        let indexCount: number = 0;\r\n        let vertexDecler: string = undefined;\r\n        subDatas.forEach(subData => {\r\n            vertexCount += subData.vertexCount;\r\n            indexCount += subData.indices.length;\r\n\r\n            vertexDecler = vertexDecler || subData.vertexDecler;\r\n        });\r\n\r\n        let vertexDeclaration: VertexDeclaration = VertexMesh.getVertexDeclaration(vertexDecler, false);\r\n        let vertexByteStride: number = vertexDeclaration.vertexStride;\r\n        let vertexFloatStride: number = vertexByteStride / 4;\r\n\r\n        let vertexArray: Float32Array = new Float32Array(vertexFloatStride * vertexCount);\r\n        let indexArray: Uint16Array | Uint32Array;\r\n        let ibFormat: IndexFormat = IndexFormat.UInt32;\r\n        if (vertexCount < 65536) {\r\n            indexArray = new Uint16Array(indexCount);\r\n            ibFormat = IndexFormat.UInt16;\r\n        }\r\n        else {\r\n            indexArray = new Uint32Array(indexCount);\r\n        }\r\n\r\n        this.fillMeshBuffers(subDatas, vertexArray, indexArray, vertexFloatStride);\r\n        this.generateMesh(vertexArray, indexArray, vertexDeclaration, ibFormat, subDatas, layaMesh);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 填充 mesh buffer 数据\r\n     * @param subDatas \r\n     * @param vertexArray \r\n     * @param indexArray \r\n     * @param vertexFloatStride \r\n     */\r\n    private fillMeshBuffers(subDatas: PrimitiveSubMesh[], vertexArray: Float32Array, indexArray: Uint16Array | Uint32Array, vertexFloatStride: number) {\r\n        let ibPosOffset: number = 0;\r\n        let ibVertexOffset: number = 0;\r\n        let vbPosOffset: number = 0;\r\n        subDatas.forEach((subData) => {\r\n\r\n            let iAOffset: number = ibPosOffset;\r\n\r\n            let vertexCount: number = subData.vertexCount;\r\n\r\n            let subIb: Uint32Array = subData.indices;\r\n            for (let index = 0; index < subIb.length; index++) {\r\n                indexArray[iAOffset + index] = subIb[index] + ibVertexOffset;\r\n            }\r\n            ibPosOffset += subIb.length;\r\n            ibVertexOffset += vertexCount;\r\n\r\n            const fillAttributeBuffer = (value: Float32Array, attriOffset: number, attriFloatCount: number = 0) => {\r\n                let startOffset: number = vbPosOffset + attriOffset;\r\n                for (let index = 0; index < vertexCount; index++) {\r\n                    for (let ac = 0; ac < attriFloatCount; ac++) {\r\n                        vertexArray[startOffset + index * vertexFloatStride + ac] = value[index * attriFloatCount + ac];\r\n                    }\r\n                }\r\n            };\r\n\r\n            let attriOffset: number = 0;\r\n            let attributeMap: Map<string, Float32Array> = subData.attributeMap;\r\n            let position: Float32Array = attributeMap.get(\"POSITION\");\r\n            (position) && (fillAttributeBuffer(position, attriOffset, 3), attriOffset += 3);\r\n            let normal: Float32Array = attributeMap.get(\"NORMAL\");\r\n            (normal) && (fillAttributeBuffer(normal, attriOffset, 3), attriOffset += 3);\r\n            let color: Float32Array = attributeMap.get(\"COLOR\");\r\n            (color) && (fillAttributeBuffer(color, attriOffset, 4), attriOffset += 4);\r\n            let uv: Float32Array = attributeMap.get(\"UV\");\r\n            (uv) && (fillAttributeBuffer(uv, attriOffset, 2), attriOffset += 2);\r\n            let uv1: Float32Array = attributeMap.get(\"UV1\");\r\n            (uv1) && (fillAttributeBuffer(uv1, attriOffset, 2), attriOffset += 2);\r\n            let blendWeight: Float32Array = attributeMap.get(\"BLENDWEIGHT\");\r\n            (blendWeight) && (fillAttributeBuffer(blendWeight, attriOffset, 4), attriOffset += 4);\r\n            let blendIndices: Float32Array = attributeMap.get(\"BLENDINDICES\");\r\n            if (blendIndices) {\r\n                let blendIndicesUint8: Uint8Array = new Uint8Array(blendIndices);\r\n                let blendIndicesFloat32: Float32Array = new Float32Array(blendIndicesUint8.buffer);\r\n                fillAttributeBuffer(blendIndicesFloat32, attriOffset, 1), attriOffset += 1;\r\n            }\r\n            let tangent: Float32Array = attributeMap.get(\"TANGENT\");\r\n            (tangent) && (fillAttributeBuffer(tangent, attriOffset, 4), attriOffset += 4);\r\n\r\n            vbPosOffset += vertexCount * vertexFloatStride;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 根据 单次提交最大骨骼数量 划分 submesh 提交队列\r\n     * @param attributeMap \r\n     * @param indexArray \r\n     * @param boneIndicesList \r\n     * @param subIndexStartArray \r\n     * @param subIndexCountArray \r\n     */\r\n    private splitSubMeshByBonesCount(attributeMap: Map<string, Float32Array>, morphtargets: SubMorphData, indexArray: Uint32Array, boneIndicesList: Array<Uint16Array>, subIndexStartArray: number[], subIndexCountArray: number[]): void {\r\n        let start: number = 0;\r\n        let subIndexSet: Set<number> = new Set();\r\n        let boneIndexArray: Float32Array = attributeMap.get(\"BLENDINDICES\");\r\n\r\n        let vertexCount: number = boneIndexArray.length / 4;\r\n\r\n        let resArray: Float32Array = new Float32Array(boneIndexArray.length);\r\n\r\n        let flagArray: Array<boolean> = new Array(vertexCount).fill(false);\r\n\r\n        // 遍历 ib\r\n        for (let i: number = 0, n: number = indexArray.length; i < n; i += 3) {\r\n            // 每三个顶点 一个三角形 一起判断\r\n            // 三个顶点 ，12 个 bone index\r\n            let triangleSet: Set<number> = new Set();\r\n            for (let j: number = i; j < i + 3; j++) {\r\n                let ibIndex: number = indexArray[j];\r\n                let boneIndexOffset: number = ibIndex * 4;\r\n                for (let k: number = 0; k < 4; k++) {\r\n                    triangleSet.add(boneIndexArray[boneIndexOffset + k]);\r\n                }\r\n            }\r\n            // 判断当前\r\n            let tempSet: Set<number> = new Set([...subIndexSet, ...triangleSet]);\r\n            if (tempSet.size > maxSubBoneCount) {\r\n                // 当前批次不能加 添加 下一三角形\r\n                // 保存当前数据\r\n                let count: number = i - start;\r\n                subIndexStartArray.push(start);\r\n                subIndexCountArray.push(count);\r\n\r\n                let curBoneList: number[] = Array.from(subIndexSet);\r\n                boneIndicesList.push(new Uint16Array(curBoneList));\r\n                // 更新 起始位置\r\n                start = i;\r\n                // 新建数据集， 添加未能添加到上一个节点的数据\r\n                subIndexSet = new Set(triangleSet);\r\n            }\r\n            else {\r\n                // 添加数据 到当前数据集\r\n                subIndexSet = tempSet;\r\n            }\r\n            // 结尾 添加剩余数据\r\n            if (i == n - 3) {\r\n                let count: number = i - start + 3;\r\n                subIndexStartArray.push(start);\r\n                subIndexCountArray.push(count);\r\n                start = i;\r\n                let curBoneList: number[] = Array.from(subIndexSet);\r\n                boneIndicesList.push(new Uint16Array(curBoneList));\r\n            }\r\n        }\r\n\r\n        //根据分离出的范围 更改 biarray\r\n        let drawCount: number = boneIndicesList.length;\r\n        let newAttributeMap: Map<string, Array<number>> = new Map();\r\n        attributeMap.forEach((value, key) => {\r\n            let array: Array<number> = new Array();\r\n            newAttributeMap.set(key, array);\r\n        });\r\n\r\n        let newTargetMap: { [name: string]: Map<string, Array<number>> } = {};\r\n        for (const key in morphtargets.targets) {\r\n            let newMap = newTargetMap[key] = new Map();\r\n\r\n            let target = morphtargets.targets[key];\r\n            target.forEach((value, attri) => {\r\n                newMap.set(attri, new Array<number>());\r\n            });\r\n        }\r\n\r\n        let curMaxIndex: number = vertexCount - 1;\r\n        for (let d: number = 0; d < drawCount; d++) {\r\n            let k: number = subIndexStartArray[d];\r\n            let l: number = subIndexCountArray[d];\r\n            let bl: Uint16Array = boneIndicesList[d];\r\n\r\n            let batchFlag: Array<boolean> = new Array(vertexCount).fill(false);\r\n            let batchMap: Map<number, number> = new Map();\r\n            for (let area: number = 0; area < l; area++) {\r\n                let ci: number = indexArray[area + k];\r\n                let biStart: number = 4 * ci;\r\n                for (let cbi: number = biStart; cbi < biStart + 4; cbi++) {\r\n                    let oldBoneIndex: number = boneIndexArray[cbi];\r\n                    let newBoneIndex: number = bl.indexOf(oldBoneIndex);\r\n                    newBoneIndex = newBoneIndex == -1 ? 0 : newBoneIndex;\r\n                    // 其他batch 出现， 此batch 未出现 新增点数据\r\n                    if (flagArray[ci] && !batchFlag[ci]) {\r\n                        newAttributeMap.get(\"BLENDINDICES\").push(newBoneIndex);\r\n                    }\r\n                    // 其他batch 出现， 此batch 出现, 修改过 跳过\r\n                    else if (flagArray[ci] && batchFlag[ci]) {\r\n\r\n                    }\r\n                    else {\r\n                        resArray[cbi] = newBoneIndex;\r\n                    }\r\n                }\r\n                // 其他batch 未出现， 此batch 未出现 不处理\r\n                if (!flagArray[ci] && !batchFlag[ci]) {\r\n                    batchFlag[ci] = true;\r\n                    batchMap.set(ci, ci);\r\n                }\r\n                // 其他btach 未出现， 此batch 已经出现 index 改为上次更新index\r\n                else if (!flagArray[ci] && batchFlag[ci]) {\r\n                    indexArray[area + k] = batchMap.get(ci);\r\n                }\r\n                //其他batch 出现， 此batch 未出现 新增点数据  更新index\r\n                else if (flagArray[ci] && !batchFlag[ci]) {\r\n                    batchFlag[ci] = true;\r\n                    curMaxIndex++;\r\n                    batchMap.set(ci, curMaxIndex);\r\n                    indexArray[area + k] = curMaxIndex;\r\n                    newAttributeMap.forEach((value: number[], key: string) => {\r\n                        let attOffset: number = this.getAttributeNum(key);\r\n                        let oldArray: Float32Array = attributeMap.get(key);\r\n                        if (key !== \"BLENDINDICES\") {\r\n                            for (let index = 0; index < attOffset; index++) {\r\n                                value.push(oldArray[index + ci * attOffset]);\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                    for (const key in newTargetMap) {\r\n                        let newMap = newTargetMap[key];\r\n                        let oldMap = morphtargets.targets[key];\r\n                        newMap.forEach((value, attri) => {\r\n                            let attOffset = this.getAttributeNum(attri);\r\n                            let oldArray = oldMap.get(attri);\r\n\r\n                            for (let index = 0; index < attOffset; index++) {\r\n                                value.push(oldArray[index + ci * attOffset]);\r\n                            }\r\n\r\n                        });\r\n                    }\r\n\r\n\r\n                }\r\n                //其他batch 出现， 此batch 出现\r\n                else if (flagArray[ci] && batchFlag[ci]) {\r\n                    indexArray[area + k] = batchMap.get(ci);\r\n                }\r\n            }\r\n            // 将此batch 出现的index更新到flagarray\r\n            batchFlag.forEach((value, index) => {\r\n                flagArray[index] = value || flagArray[index];\r\n            });\r\n        }\r\n\r\n        newAttributeMap.forEach((value: number[], key: string) => {\r\n            let oldFloatArray: Float32Array = attributeMap.get(key);\r\n            if (key == \"BLENDINDICES\") {\r\n                oldFloatArray = resArray;\r\n            }\r\n            let newLength: number = oldFloatArray.length + value.length;\r\n            let newFloatArray: Float32Array = new Float32Array(newLength);\r\n            newFloatArray.set(oldFloatArray, 0);\r\n            newFloatArray.set(value, oldFloatArray.length);\r\n            attributeMap.set(key, newFloatArray);\r\n        });\r\n\r\n        for (const key in newTargetMap) {\r\n            let newMap = newTargetMap[key];\r\n            let oldMap = morphtargets.targets[key];\r\n\r\n            newMap.forEach((value, attri) => {\r\n                let oldArray = oldMap.get(attri);\r\n                let newLength = value.length + oldArray.length;\r\n\r\n                let newFloatArray = new Float32Array(newLength);\r\n                newFloatArray.set(oldArray, 0);\r\n                newFloatArray.set(value, oldArray.length);\r\n                oldMap.set(attri, newFloatArray);\r\n            });\r\n        }\r\n\r\n        boneIndexArray = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 生成 mesh\r\n     * @param vertexArray \r\n     * @param indexArray \r\n     * @param vertexDeclaration \r\n     * @param ibFormat \r\n     * @param subDatas \r\n     * @param layaMesh \r\n     */\r\n    private generateMesh(vertexArray: Float32Array, indexArray: Uint16Array | Uint32Array, vertexDeclaration: VertexDeclaration, ibFormat: IndexFormat, subDatas: PrimitiveSubMesh[], layaMesh: Mesh): void {\r\n        let vertexBuffer: VertexBuffer3D = LayaGL.renderOBJCreate.createVertexBuffer3D(vertexArray.byteLength, BufferUsage.Static, true);\r\n        vertexBuffer.vertexDeclaration = vertexDeclaration;\r\n        vertexBuffer.setData(vertexArray.buffer);\r\n\r\n        let indexBuffer: IndexBuffer3D = LayaGL.renderOBJCreate.createIndexBuffer3D(ibFormat, indexArray.length, BufferUsage.Static, true);\r\n        indexBuffer.setData(indexArray);\r\n\r\n        layaMesh._indexFormat = ibFormat;\r\n        layaMesh._indexBuffer = indexBuffer;\r\n        layaMesh._vertexBuffer = vertexBuffer;\r\n        layaMesh._setBuffer(vertexBuffer, indexBuffer);\r\n        layaMesh._vertexCount = vertexBuffer._byteLength / vertexDeclaration.vertexStride;\r\n\r\n        let reCalculateBounds = false;\r\n        let min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        let max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        // subMesh\r\n        let subMeshOffset: number = 0;\r\n        let subMeshCount: number = subDatas.length;\r\n        let subMeshes: SubMesh[] = new Array<SubMesh>(subMeshCount);\r\n        for (let index = 0; index < subMeshCount; index++) {\r\n            let subData: PrimitiveSubMesh = subDatas[index];\r\n\r\n            let subMesh: SubMesh = new SubMesh(layaMesh);\r\n            subMeshes[index] = subMesh;\r\n\r\n            subMesh._vertexBuffer = vertexBuffer;\r\n            subMesh._indexBuffer = indexBuffer;\r\n\r\n            let subIndexStart: number = subMeshOffset;\r\n            subMeshOffset += subData.indices.length;\r\n            let subIndexCount: number = subData.indices.length;\r\n            subMesh._setIndexRange(subIndexStart, subIndexCount, ibFormat);\r\n\r\n            subMesh._boneIndicesList = subData.boneIndicesList;\r\n            subMesh._subIndexBufferStart = subData.subIndexStartArray;\r\n            subMesh._subIndexBufferCount = subData.subIndexCountArray;\r\n\r\n            for (let subIndex = 0; subIndex < subMesh._subIndexBufferStart.length; subIndex++) {\r\n                subMesh._subIndexBufferStart[subIndex] += subIndexStart;\r\n            }\r\n\r\n            if (subData.boundMax && subData.boundMin) {\r\n                min.x = Math.min(subData.boundMin[0], min.x);\r\n                min.y = Math.min(subData.boundMin[1], min.y);\r\n                min.z = Math.min(subData.boundMin[2], min.z);\r\n\r\n                max.x = Math.max(subData.boundMax[0], max.x);\r\n                max.y = Math.max(subData.boundMax[1], max.y);\r\n                max.z = Math.max(subData.boundMax[2], max.z);\r\n            }\r\n            else {\r\n                reCalculateBounds = true;\r\n            }\r\n        }\r\n\r\n        layaMesh._setSubMeshes(subMeshes);\r\n        if (reCalculateBounds) {\r\n            layaMesh.calculateBounds();\r\n        }\r\n        else {\r\n            layaMesh.bounds.setMin(min);\r\n            layaMesh.bounds.setMax(max);\r\n        }\r\n\r\n        //layaMesh._setInstanceBuffer(Mesh.MESH_INSTANCEBUFFER_TYPE_NORMAL);\r\n\r\n        // 资源面板\r\n        // todo mesh.read = flase ? \r\n        let memorySize: number = vertexBuffer._byteLength + indexBuffer._byteLength;\r\n        layaMesh._setCPUMemory(memorySize);\r\n        layaMesh._setGPUMemory(memorySize);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * mesh 应用蒙皮数据\r\n     * @param mesh \r\n     * @param glTFSkin \r\n     */\r\n    private applyglTFSkinData(mesh: Mesh, subDatas: PrimitiveSubMesh[], glTFSkin?: glTF.glTFSkin): void {\r\n        if (!glTFSkin)\r\n            return;\r\n\r\n        let joints: number[] = glTFSkin.joints;\r\n\r\n        let inverseBindMatricesArray: Float32Array = new Float32Array(this.getBufferwithAccessorIndex(glTFSkin.inverseBindMatrices));\r\n\r\n        let boneCount: number = joints.length;\r\n        let boneNames: string[] = mesh._boneNames = [];\r\n        joints.forEach(nodeIndex => {\r\n            let node: glTF.glTFNode = this._data.nodes[nodeIndex];\r\n            boneNames.push(node.name);\r\n        })\r\n\r\n        mesh._inverseBindPoses = [];\r\n        mesh._inverseBindPosesBuffer = inverseBindMatricesArray.buffer;\r\n        for (let index = 0; index < boneCount; index++) {\r\n            let bindPosesArrayOffset: number = 16 * index;\r\n            let matElement: Float32Array = inverseBindMatricesArray.slice(bindPosesArrayOffset, bindPosesArrayOffset + 16);\r\n            mesh._inverseBindPoses[index] = new Matrix4x4(\r\n                matElement[0], matElement[1], matElement[2], matElement[3],\r\n                matElement[4], matElement[5], matElement[6], matElement[7],\r\n                matElement[8], matElement[9], matElement[10], matElement[11],\r\n                matElement[12], matElement[13], matElement[14], matElement[15],\r\n                matElement\r\n            );\r\n        }\r\n\r\n        let subCount: number = subDatas.length;\r\n        let skinnedCache: skinnedMatrixCache[] = mesh._skinnedMatrixCaches;\r\n        skinnedCache.length = mesh._inverseBindPoses.length;\r\n        for (let subIndex: number = 0; subIndex < subCount; subIndex++) {\r\n            let submesh: SubMesh = mesh.getSubMesh(subIndex);\r\n            let drawCount: number = submesh._subIndexBufferStart.length;\r\n            for (let drawIndex: number = 0; drawIndex < drawCount; drawIndex++) {\r\n                let boneIndices: Uint16Array = submesh._boneIndicesList[drawIndex];\r\n                for (let bni: number = 0; bni < boneIndices.length; bni++) {\r\n                    let bn: number = boneIndices[bni];\r\n                    skinnedCache[bn] || (skinnedCache[bn] = new skinnedMatrixCache(subIndex, drawIndex, bni));\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let index = 0; index < skinnedCache.length; index++) {\r\n            if (!skinnedCache[index]) {\r\n                skinnedCache[index] = new skinnedMatrixCache(0, 0, 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    private applyMorphTarget(mesh: Mesh, subDatas: PrimitiveSubMesh[]) {\r\n\r\n        let hasPosition = false;\r\n        let hasNormal = false;\r\n        let hasTangent = false;\r\n\r\n        subDatas.forEach(subData => {\r\n            hasPosition = subData.morphtargets.position || hasPosition;\r\n            hasNormal = subData.morphtargets.normal || hasNormal;\r\n            hasTangent = subData.morphtargets.tangent || hasTangent;\r\n        });\r\n\r\n        if (!(hasPosition || hasTangent || hasTangent)) {\r\n            return;\r\n        }\r\n\r\n        let vertexCount = mesh.vertexCount;\r\n\r\n        let morphData = new MorphTargetData();\r\n        morphData.vertexCount = vertexCount;\r\n\r\n        let decStr = [];\r\n        if (hasPosition)\r\n            decStr.push(\"POSITION\");\r\n        if (hasNormal)\r\n            decStr.push(\"NORMAL\");\r\n        if (hasTangent)\r\n            decStr.push(\"TANGENT\");\r\n\r\n        let morphVertexDec = VertexMesh.getVertexDeclaration(decStr.toLocaleString());\r\n        let targetVertexFloatStride = morphVertexDec.vertexStride / 4;\r\n\r\n        morphData.vertexDec = morphVertexDec;\r\n\r\n        let bounds = morphData.bounds;\r\n        let min = bounds.getMin();\r\n        let max = bounds.getMax();\r\n        min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        let subVertexOffset = 0;\r\n        for (let index = 0; index < subDatas.length; index++) {\r\n            let subData = subDatas[index];\r\n\r\n            min.x = Math.min(min.x, subData.morphtargets.boundMin[0]);\r\n            min.y = Math.min(min.y, subData.morphtargets.boundMin[1]);\r\n            min.z = Math.min(min.z, subData.morphtargets.boundMin[2]);\r\n\r\n            max.x = Math.max(max.x, subData.morphtargets.boundMax[0]);\r\n            max.y = Math.max(max.y, subData.morphtargets.boundMax[1]);\r\n            max.z = Math.max(max.z, subData.morphtargets.boundMax[2]);\r\n\r\n            let targets = subData.morphtargets.targets;\r\n            // glTF do not support in-between blendshape\r\n            for (const targetName in targets) {\r\n\r\n                let channel = morphData.getMorphChannel(targetName);\r\n                if (!channel) {\r\n                    channel = new MorphTargetChannel();\r\n                    channel.name = targetName;\r\n\r\n                    let target = new MorphTarget();\r\n                    target.name = targetName;\r\n                    target.data = new Float32Array(vertexCount * targetVertexFloatStride).fill(0);\r\n\r\n                    channel.addTarget(target);\r\n                    morphData.addMorphChannel(channel);\r\n                }\r\n\r\n                let target = channel.getTargetByIndex(0);\r\n                let morphMap = targets[targetName];\r\n\r\n                for (let vertexIndex = 0; vertexIndex < subData.vertexCount; vertexIndex++) {\r\n                    let morphPosition = morphMap.get(\"POSITION\");\r\n                    if (morphPosition) {\r\n                        let posElement = morphVertexDec.getVertexElementByUsage(VertexMesh.MESH_POSITION0);\r\n                        let offset = posElement.offset / 4;\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset] = morphPosition[vertexIndex * 3];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 1] = morphPosition[vertexIndex * 3 + 1];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 2] = morphPosition[vertexIndex * 3 + 2];\r\n                    }\r\n\r\n                    let morphNormal = morphMap.get(\"NORMAL\");\r\n                    if (morphNormal) {\r\n                        let normalElement = morphVertexDec.getVertexElementByUsage(VertexMesh.MESH_NORMAL0);\r\n                        let offset = normalElement.offset / 4;\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset] = morphNormal[vertexIndex * 3];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 1] = morphNormal[vertexIndex * 3 + 1];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 2] = morphNormal[vertexIndex * 3 + 2];\r\n                    }\r\n                    let morphTangent = morphMap.get(\"TANGENT\");\r\n                    if (morphTangent) {\r\n                        let tangentElement = morphVertexDec.getVertexElementByUsage(VertexMesh.MESH_TANGENT0);\r\n                        let offset = tangentElement.offset / 4;\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset] = morphTangent[vertexIndex * 3];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 1] = morphTangent[vertexIndex * 3 + 1];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 2] = morphTangent[vertexIndex * 3 + 2];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 3] = subData.attributeMap.get(\"TANGENT\")[vertexIndex * 4 + 3];\r\n                    }\r\n                }\r\n            }\r\n\r\n            subVertexOffset += subData.vertexCount;\r\n        }\r\n\r\n        bounds.setMin(min);\r\n        bounds.setMax(max);\r\n\r\n        mesh.morphTargetData = morphData;\r\n        morphData.initData();\r\n    }\r\n\r\n    /**\r\n     * 创建 Mesh\r\n     * @param mesh \r\n     */\r\n    protected createMesh(glTFMesh: glTF.glTFMesh, glTFSkin?: glTF.glTFSkin): Mesh {\r\n        let layaMesh: Mesh = new Mesh();\r\n\r\n        let glTFMeshPrimitives: glTF.glTFMeshPrimitive[] = glTFMesh.primitives;\r\n        let morphWeights: number[] = glTFMesh.weights;\r\n\r\n        let boneCount: number = (glTFSkin) ? glTFSkin.joints.length : 0;\r\n        let subDatas: PrimitiveSubMesh[] = [];\r\n\r\n        glTFMeshPrimitives.forEach((glTFMeshPrimitive: glTF.glTFMeshPrimitive) => {\r\n\r\n            let mode: glTF.glTFMeshPrimitiveMode = glTFMeshPrimitive.mode;\r\n            if (mode == undefined)\r\n                mode = glTF.glTFMeshPrimitiveMode.TRIANGLES;\r\n            if (glTF.glTFMeshPrimitiveMode.TRIANGLES != mode) {\r\n                // todo  只支持 gl.TRIANGLES 模式\r\n                console.warn(\"glTF Loader: only support gl.TRIANGLES.\");\r\n                debugger;\r\n            }\r\n\r\n            let vertexDeclarArr: string[] = [];\r\n            let attributeMap: Map<string, Float32Array> = new Map();\r\n            let attributes: { [name: string]: number } = glTFMeshPrimitive.attributes;\r\n\r\n            let position: Float32Array = this.getArrributeBuffer(attributes.POSITION, \"POSITION\", attributeMap, vertexDeclarArr);\r\n            let vertexCount: number = position.length / 3;\r\n            let indexArray: Uint32Array = this.getIndexBuffer(glTFMeshPrimitive.indices, vertexCount);\r\n            let positionAccessor = this._data.accessors[attributes.POSITION];\r\n\r\n            let normal: Float32Array = this.getArrributeBuffer(attributes.NORMAL, \"NORMAL\", attributeMap, vertexDeclarArr);\r\n            /**\r\n             * When normals are not specified, client implementations MUST calculate flat normals and the provided tangents (if present) MUST be ignored.\r\n             */\r\n            if (!normal) {\r\n                normal = this.calculateFlatNormal(position, indexArray);\r\n                vertexDeclarArr.push(\"NORMAL\");\r\n                attributeMap.set(\"NORMAL\", normal);\r\n            }\r\n\r\n            let color: Float32Array = this.getArrributeBuffer(attributes.COLOR_0, \"COLOR\", attributeMap, vertexDeclarArr);\r\n            let uv: Float32Array = this.getArrributeBuffer(attributes.TEXCOORD_0, \"UV\", attributeMap, vertexDeclarArr);\r\n            let uv1: Float32Array = this.getArrributeBuffer(attributes.TEXCOORD_1, \"UV1\", attributeMap, vertexDeclarArr);\r\n            let blendWeight: Float32Array = this.getArrributeBuffer(attributes.WEIGHTS_0, \"BLENDWEIGHT\", attributeMap, vertexDeclarArr);\r\n            let blendIndices: Float32Array = this.getArrributeBuffer(attributes.JOINTS_0, \"BLENDINDICES\", attributeMap, vertexDeclarArr);\r\n\r\n            let tangent: Float32Array;\r\n            tangent = this.getArrributeBuffer(attributes.TANGENT, \"TANGENT\", attributeMap, vertexDeclarArr);\r\n            // :(\r\n            if (tangent) {\r\n                for (let tangentIndex = 0; tangentIndex < tangent.length; tangentIndex += 4) {\r\n                    tangent[tangentIndex + 3] *= -1;\r\n                }\r\n            }\r\n\r\n            // todo  vertex color\r\n            // if (color) {\r\n            //     let material = glTFUtils._glTFMaterials[glTFMeshPrimitive.material];\r\n            //     material.enableVertexColor = true;\r\n            // }\r\n\r\n            let targets: { [name: string]: number }[] = glTFMeshPrimitive.targets;\r\n            let morphtargets: SubMorphData = { weights: morphWeights, position: false, normal: false, tangent: false, targets: {}, boundMin: [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], boundMax: [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE] };\r\n            if (targets) {\r\n\r\n                let morphtargetMap: { [name: string]: Map<string, Float32Array> };\r\n                let targetNames = glTFMesh.extras?.targetNames || [];\r\n                morphtargetMap = morphtargets.targets;\r\n\r\n                targets.forEach((target, index) => {\r\n                    let targetName = targetNames[index] || `target_${index}`;\r\n                    let morph = new Map<string, Float32Array>();\r\n                    morphtargetMap[targetName] = morph;\r\n\r\n                    let morphPosition = <Float32Array>this.getBufferwithAccessorIndex(target.POSITION);\r\n                    let morphNormal = <Float32Array>this.getBufferwithAccessorIndex(target.NORMAL);\r\n                    let morphTangent = <Float32Array>this.getBufferwithAccessorIndex(target.TANGENT);\r\n\r\n                    if (morphPosition) {\r\n                        morph.set(\"POSITION\", morphPosition);\r\n                        morphtargets.position = true;\r\n\r\n                        if (position) {\r\n                            let vertexCount: number = position.length / 3;\r\n\r\n                            for (let i = 0; i < vertexCount; i++) {\r\n                                let offset = i * 3;\r\n\r\n                                let morphX = position[offset] + morphPosition[offset];\r\n                                let morphY = position[offset + 1] + morphPosition[offset + 1];\r\n                                let morphZ = position[offset + 2] + morphPosition[offset + 2];\r\n\r\n                                morphtargets.boundMin[0] = Math.min(morphX, morphtargets.boundMin[0]);\r\n                                morphtargets.boundMin[1] = Math.min(morphY, morphtargets.boundMin[1]);\r\n                                morphtargets.boundMin[2] = Math.min(morphZ, morphtargets.boundMin[2]);\r\n\r\n                                morphtargets.boundMax[0] = Math.max(morphX, morphtargets.boundMax[0]);\r\n                                morphtargets.boundMax[1] = Math.max(morphY, morphtargets.boundMax[1]);\r\n                                morphtargets.boundMax[2] = Math.max(morphZ, morphtargets.boundMax[2]);\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                    if (morphNormal) {\r\n                        morph.set(\"NORMAL\", morphNormal);\r\n                        morphtargets.normal = true;\r\n                    }\r\n                    if (morphTangent) {\r\n                        morph.set(\"TANGENT\", morphTangent);\r\n                        morphtargets.tangent = true;\r\n                    }\r\n                });\r\n            }\r\n\r\n            let boneIndicesList: Array<Uint16Array> = new Array<Uint16Array>();\r\n            let subIndexStartArray: number[] = [];\r\n            let subIndexCountArray: number[] = [];\r\n\r\n            if (glTFSkin) {\r\n                if (boneCount > maxSubBoneCount) {\r\n                    // todo 划分 subMesh\r\n                    this.splitSubMeshByBonesCount(attributeMap, morphtargets, indexArray, boneIndicesList, subIndexStartArray, subIndexCountArray);\r\n                    vertexCount = attributeMap.get(\"POSITION\").length / 3;\r\n                }\r\n                else {\r\n                    subIndexStartArray[0] = 0;\r\n                    subIndexCountArray[0] = indexArray.length;\r\n                    boneIndicesList[0] = new Uint16Array(boneCount);\r\n                    for (let bi = 0; bi < boneCount; bi++) {\r\n                        boneIndicesList[0][bi] = bi;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                subIndexStartArray[0] = 0;\r\n                subIndexCountArray[0] = indexArray.length;\r\n            }\r\n            let vertexDeclaration: string = vertexDeclarArr.toString();\r\n\r\n            let subData: PrimitiveSubMesh = new PrimitiveSubMesh();\r\n            subDatas.push(subData);\r\n\r\n            subData.attributeMap = attributeMap;\r\n            subData.boundMax = positionAccessor.max;\r\n            subData.boundMin = positionAccessor.min;\r\n            subData.morphtargets = morphtargets;\r\n            subData.indices = indexArray;\r\n            subData.vertexCount = vertexCount;\r\n            subData.vertexDecler = vertexDeclaration;\r\n            subData.boneIndicesList = boneIndicesList;\r\n            subData.subIndexStartArray = subIndexStartArray;\r\n            subData.subIndexCountArray = subIndexCountArray;\r\n        });\r\n\r\n        this.parseMeshwithSubMeshData(subDatas, layaMesh);\r\n        this.applyglTFSkinData(layaMesh, subDatas, glTFSkin);\r\n        this.applyMorphTarget(layaMesh, subDatas);\r\n        return layaMesh;\r\n    }\r\n\r\n    /**\r\n     * 计算 SkinnedMeshSprite3D local bounds\r\n     * @param skinned \r\n     */\r\n    private calSkinnedSpriteLocalBounds(skinned: SkinnedMeshSprite3D): void {\r\n        let render: SkinnedMeshRenderer = skinned.skinnedMeshRenderer;\r\n        let mesh: Mesh = skinned.meshFilter.sharedMesh;\r\n        let rootBone: Sprite3D = render.rootBone;\r\n\r\n        let oriRootMatrix: Matrix4x4 = rootBone.transform.worldMatrix;\r\n        let invertRootMatrix: Matrix4x4 = new Matrix4x4();\r\n        oriRootMatrix.invert(invertRootMatrix);\r\n\r\n        let indices = mesh.getIndices();\r\n\r\n        let positions: Vector3[] = [];\r\n        let boneIndices: Vector4[] = [];\r\n        let boneWeights: Vector4[] = [];\r\n        mesh.getPositions(positions);\r\n        mesh.getBoneIndices(boneIndices);\r\n        mesh.getBoneWeights(boneWeights);\r\n\r\n        let oriBoneIndeices: Vector4[] = [];\r\n        mesh._subMeshes.forEach((subMesh: SubMesh, index: number) => {\r\n            let bonelists: Uint16Array[] = subMesh._boneIndicesList;\r\n            bonelists.forEach((bonelist: Uint16Array, listIndex: number) => {\r\n                let start: number = subMesh._subIndexBufferStart[listIndex];\r\n                let count: number = subMesh._subIndexBufferCount[listIndex];\r\n                let endIndex: number = count + start;\r\n                for (let iindex = start; iindex < endIndex; iindex++) {\r\n                    let ii: number = indices[iindex];\r\n                    let boneIndex: Vector4 = boneIndices[ii];\r\n                    let x: number = bonelist[boneIndex.x];\r\n                    let y: number = bonelist[boneIndex.y];\r\n                    let z: number = bonelist[boneIndex.z];\r\n                    let w: number = bonelist[boneIndex.w];\r\n                    oriBoneIndeices[ii] = new Vector4(x, y, z, w);\r\n                }\r\n            });\r\n        });\r\n\r\n        let inverseBindPoses: Matrix4x4[] = mesh._inverseBindPoses;\r\n        let bones: Sprite3D[] = render.bones;\r\n        let ubones: Matrix4x4[] = [];\r\n        let tempMat: Matrix4x4 = new Matrix4x4();\r\n        bones.forEach((bone, index) => {\r\n            ubones[index] = new Matrix4x4();\r\n            Matrix4x4.multiply(invertRootMatrix, bone.transform.worldMatrix, tempMat);\r\n            Matrix4x4.multiply(tempMat, inverseBindPoses[index], ubones[index]);\r\n        });\r\n\r\n        let skinTransform: Matrix4x4 = new Matrix4x4;\r\n        let resPos: Vector3 = new Vector3();\r\n        let min: Vector3 = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        let max: Vector3 = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        for (let index = 0; index < positions.length; index++) {\r\n            let pos: Vector3 = positions[index];\r\n            let boneIndex: Vector4 = oriBoneIndeices[index];\r\n            let boneWeight: Vector4 = boneWeights[index];\r\n\r\n            if (!(boneIndex && boneWeight)) {\r\n                continue;\r\n            }\r\n\r\n            for (let ei = 0; ei < 16; ei++) {\r\n                skinTransform.elements[ei] = ubones[boneIndex.x].elements[ei] * boneWeight.x;\r\n                skinTransform.elements[ei] += ubones[boneIndex.y].elements[ei] * boneWeight.y;\r\n                skinTransform.elements[ei] += ubones[boneIndex.z].elements[ei] * boneWeight.z;\r\n                skinTransform.elements[ei] += ubones[boneIndex.w].elements[ei] * boneWeight.w;\r\n            }\r\n            Vector3.transformV3ToV3(pos, skinTransform, resPos);\r\n            Vector3.min(min, resPos, min);\r\n            Vector3.max(max, resPos, max);\r\n\r\n        }\r\n\r\n        // positions.forEach((pos: Vector3, index: number) => {\r\n        //     let boneIndex: Vector4 = oriBoneIndeices[index];\r\n        //     let boneWeight: Vector4 = boneWeights[index];\r\n\r\n        //     for (let ei = 0; ei < 16; ei++) {\r\n        //         skinTransform.elements[ei] = ubones[boneIndex.x].elements[ei] * boneWeight.x;\r\n        //         skinTransform.elements[ei] += ubones[boneIndex.y].elements[ei] * boneWeight.y;\r\n        //         skinTransform.elements[ei] += ubones[boneIndex.z].elements[ei] * boneWeight.z;\r\n        //         skinTransform.elements[ei] += ubones[boneIndex.w].elements[ei] * boneWeight.w;\r\n        //     }\r\n        //     Vector3.transformV3ToV3(pos, skinTransform, resPos);\r\n        //     Vector3.min(min, resPos, min);\r\n        //     Vector3.max(max, resPos, max);\r\n        // });\r\n\r\n        positions = null;\r\n        boneIndices = boneWeights = oriBoneIndeices = null;\r\n        indices = null;\r\n        ubones = null;\r\n\r\n        render.localBounds.setMin(min);\r\n        render.localBounds.setMax(max);\r\n        render.localBounds = render.localBounds;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 补全 skinnedMeshSprite 所需数据\r\n     * @param glTFNode \r\n     * @param skinned \r\n     */\r\n    private fixSkinnedSprite(glTFNode: glTF.glTFNode, skinned: SkinnedMeshSprite3D): void {\r\n        let skin: glTF.glTFSkin = this._data.skins[glTFNode.skin];\r\n        let skinnedMeshRenderer: SkinnedMeshRenderer = skinned.skinnedMeshRenderer;\r\n        skin.joints.forEach(nodeIndex => {\r\n            let bone: Sprite3D = this._nodes[nodeIndex];\r\n            skinnedMeshRenderer.bones.push(bone);\r\n        });\r\n        if (skin.skeleton == undefined) {\r\n            skin.skeleton = skin.joints[0];\r\n        }\r\n        skinnedMeshRenderer.rootBone = this._nodes[skin.skeleton];\r\n\r\n        this.calSkinnedSpriteLocalBounds(skinned);\r\n    }\r\n\r\n    /**\r\n     * @interna\r\n     * 获取 Animator 根节点\r\n     */\r\n    private getAnimationRoot(channels: glTF.glTFAnimationChannel[]): Sprite3D {\r\n        const isContainNode = (nodeArr: number[], findNodeIndex: number): boolean => {\r\n            if (!nodeArr)\r\n                return false;\r\n            if (nodeArr.indexOf(findNodeIndex) == -1) {\r\n                for (let index = 0; index < nodeArr.length; index++) {\r\n                    let glTFNode: glTF.glTFNode = this._data.nodes[nodeArr[index]];\r\n                    if (isContainNode(glTFNode.children, findNodeIndex)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        let target: glTF.glTFAnimationChannelTarget = channels[0].target;\r\n        let spriteIndex: number = target.node;\r\n        for (let index = 0; index < this._data.scenes.length; index++) {\r\n            let glTFScene: glTF.glTFScene = this._data.scenes[index];\r\n            if (isContainNode(glTFScene.nodes, spriteIndex)) {\r\n                return this._scenes[index];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 动画路径信息\r\n     * @param root \r\n     * @param curSprite \r\n     */\r\n    private getAnimationPath(root: Sprite3D, curSprite: Sprite3D): string[] {\r\n        let paths: string[] = [];\r\n        if (root == curSprite)\r\n            return paths;\r\n\r\n        let sprite: Sprite3D = curSprite;\r\n        while (sprite.parent != root) {\r\n            sprite = <Sprite3D>sprite.parent;\r\n            paths.push(sprite.name);\r\n        }\r\n        paths = paths.reverse();\r\n        paths.push(curSprite.name);\r\n        return paths;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载 Animation\r\n     * @param animations \r\n     */\r\n    private loadAnimations(animations?: glTF.glTFAnimation[]): void {\r\n        if (!animations)\r\n            return;\r\n\r\n        animations.forEach((animation: glTF.glTFAnimation, index: number) => {\r\n            // todo \r\n            this.loadAnimation(animation);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载 Animation\r\n     * @param animation \r\n     */\r\n    private loadAnimation(animation: glTF.glTFAnimation): Animator {\r\n        // todo extension and extra\r\n\r\n        return this.createAnimator(animation);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 创建 Animator 组件\r\n     * @param animation \r\n     */\r\n    private createAnimator(animation: glTF.glTFAnimation): Animator {\r\n\r\n        let channels: glTF.glTFAnimationChannel[] = animation.channels;\r\n        let samplers: glTF.glTFAnimationSampler[] = animation.samplers;\r\n\r\n        let animatorRoot: Sprite3D = this.getAnimationRoot(channels);\r\n\r\n        if (!animatorRoot) {\r\n            return null;\r\n        }\r\n\r\n        let animator: Animator = animatorRoot.getComponent(Animator);\r\n        if (!animator) {\r\n            animator = animatorRoot.addComponent(Animator);\r\n            let animatorLayer: AnimatorControllerLayer = new AnimatorControllerLayer(\"AnimatorLayer\");\r\n            animator.addControllerLayer(animatorLayer);\r\n            animatorLayer.defaultWeight = 1.0;\r\n        }\r\n\r\n        let clip: AnimationClip = this.createAnimatorClip(animation, animatorRoot);\r\n        let animatorLayer: AnimatorControllerLayer = animator.getControllerLayer();\r\n\r\n        let animationName: string = clip.name;\r\n\r\n        if (animatorLayer.getAnimatorState(animationName)) {\r\n            animationName = clip.name = `${animationName}_${this.generateId(animationName)}`;\r\n        }\r\n\r\n        let animatorState: AnimatorState = new AnimatorState();\r\n        // todo  state name\r\n        animatorState.name = animationName;\r\n        animatorState.clip = clip;\r\n        animatorLayer.addState(animatorState);\r\n        animatorLayer.defaultState = animatorState;\r\n        animatorLayer.playOnWake = true;\r\n\r\n        return animator;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 创建 AnimationClip\r\n     * @param animation \r\n     * @param animatorRoot \r\n     * @returns \r\n     */\r\n    protected createAnimatorClip(animation: glTF.glTFAnimation, animatorRoot: Sprite3D): AnimationClip {\r\n        let clip: AnimationClip = new AnimationClip();\r\n\r\n        let duration: number = 0;\r\n\r\n        let channels: glTF.glTFAnimationChannel[] = animation.channels;\r\n        let samplers: glTF.glTFAnimationSampler[] = animation.samplers;\r\n\r\n        let clipNodes: ClipNode[] = [];\r\n        channels.forEach((channel: glTF.glTFAnimationChannel, index: number) => {\r\n            let target: glTF.glTFAnimationChannelTarget = channel.target;\r\n            let sampler: glTF.glTFAnimationSampler = samplers[channel.sampler];\r\n            let targetPath: glTF.glTFAnimationChannelTargetPath = target.path;\r\n\r\n            let timeBuffer = this.getBufferwithAccessorIndex(sampler.input);\r\n            let outBuffer = this.getBufferwithAccessorIndex(sampler.output);\r\n\r\n            let timeArray = new Float32Array(timeBuffer);\r\n            let outArray = new Float32Array(outBuffer);\r\n\r\n            let sprite: Sprite3D = this._nodes[target.node];\r\n\r\n            let animaPaths = this.getAnimationPath(animatorRoot, sprite);\r\n\r\n            if (targetPath == glTF.glTFAnimationChannelTargetPath.WEIGHTS) {\r\n\r\n                let mesh = sprite.getComponent(MeshFilter)?.sharedMesh;\r\n                if (mesh && mesh.morphTargetData) {\r\n\r\n                    let ownerStr = sprite.getComponent(SkinnedMeshRenderer) ? \"SkinnedMeshRenderer\" : \"MeshRenderer\";\r\n\r\n                    let morphData = mesh.morphTargetData;\r\n                    let channelCount = morphData.channelCount;\r\n                    // check data \r\n                    if (outArray.length / timeArray.length == channelCount) {\r\n                        for (let channelIndex = 0; channelIndex < channelCount; channelIndex++) {\r\n                            let morphChannel = morphData.getMorphChannelbyIndex(channelIndex);\r\n                            let channelName = morphChannel.name;\r\n\r\n                            let clipNode: ClipNode = {};\r\n                            clipNodes.push(clipNode);\r\n                            clipNode.paths = animaPaths;\r\n                            clipNode.interpolation = sampler.interpolation;\r\n                            clipNode.timeArray = timeArray;\r\n                            clipNode.valueArray = new Float32Array(timeArray.length);\r\n                            for (let i = 0; i < timeArray.length; i++) {\r\n                                clipNode.valueArray[i] = outArray[i * channelCount + channelIndex];\r\n                            }\r\n\r\n                            clipNode.propertyOwner = ownerStr;\r\n                            clipNode.propertise = [];\r\n                            clipNode.propertise.push(\"morphTargetValues\");\r\n                            clipNode.propertise.push(channelName);\r\n                            clipNode.propertyLength = clipNode.propertise.length;\r\n                            clipNode.type = 0;\r\n                            clipNode.callbackFunc = \"_changeMorphTargetValue\";\r\n                            clipNode.callbackParams = [channelName];\r\n                            clipNode.propertyChangePath = \"morphTargetValues\";\r\n\r\n                            clipNode.duration = clipNode.timeArray[clipNode.timeArray.length - 1];\r\n                            duration = Math.max(duration, clipNode.duration);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                let clipNode: ClipNode = {};\r\n                clipNodes.push(clipNode);\r\n                clipNode.timeArray = timeArray;\r\n                clipNode.valueArray = outArray;\r\n                let interpolation = sampler.interpolation;\r\n                clipNode.interpolation = interpolation;\r\n\r\n                clipNode.paths = animaPaths;\r\n\r\n                switch (targetPath) {\r\n                    case glTF.glTFAnimationChannelTargetPath.TRANSLATION:\r\n                        clipNode.propertyOwner = \"transform\";\r\n                        clipNode.propertyLength = 1;\r\n                        clipNode.propertise = [];\r\n                        clipNode.propertise.push(\"localPosition\");\r\n                        clipNode.type = 1;\r\n                        break;\r\n                    case glTF.glTFAnimationChannelTargetPath.ROTATION:\r\n                        clipNode.propertyOwner = \"transform\";\r\n                        clipNode.propertyLength = 1;\r\n                        clipNode.propertise = [];\r\n                        clipNode.propertise.push(\"localRotation\");\r\n                        clipNode.type = 2;\r\n                        break;\r\n                    case glTF.glTFAnimationChannelTargetPath.SCALE:\r\n                        clipNode.propertyOwner = \"transform\";\r\n                        clipNode.propertyLength = 1;\r\n                        clipNode.propertise = [];\r\n                        clipNode.propertise.push(\"localScale\");\r\n                        clipNode.type = 3;\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n\r\n                clipNode.duration = clipNode.timeArray[clipNode.timeArray.length - 1];\r\n                duration = Math.max(duration, clipNode.duration);\r\n            }\r\n        });\r\n\r\n        clip.name = animation.name ? animation.name : `Animation_${this.generateId(\"Animation\")}`;\r\n        clip._duration = duration;\r\n        clip.islooping = true;\r\n        clip._frameRate = 30;\r\n        let nodeCount: number = clipNodes.length;\r\n        let nodes: KeyframeNodeList = clip._nodes;\r\n        nodes.count = nodeCount;\r\n        let nodesMap: any = clip._nodesMap = {};\r\n        let nodesDic: any = clip._nodesDic = {};\r\n        for (let i: number = 0; i < nodeCount; i++) {\r\n            let node: KeyframeNode = new KeyframeNode();\r\n\r\n            let glTFClipNode: ClipNode = clipNodes[i];\r\n\r\n            nodes.setNodeByIndex(i, node);\r\n            node._indexInList = i;\r\n            // todo type\r\n            let type: number = node.type = glTFClipNode.type;\r\n            let pathLength: number = glTFClipNode.paths.length;\r\n            node._setOwnerPathCount(pathLength);\r\n            let tempPath: string[] = glTFClipNode.paths;\r\n            for (let j: number = 0; j < pathLength; j++) {\r\n                node._setOwnerPathByIndex(j, tempPath[j]);\r\n            }\r\n            let nodePath: string = node._joinOwnerPath(\"/\");\r\n            let mapArray: KeyframeNode[] = nodesMap[nodePath];\r\n            (mapArray) || (nodesMap[nodePath] = mapArray = []);\r\n            mapArray.push(node);\r\n            node.propertyOwner = glTFClipNode.propertyOwner;\r\n            let propertyLength: number = glTFClipNode.propertyLength;\r\n            node._setPropertyCount(propertyLength);\r\n            for (let j: number = 0; j < propertyLength; j++) {\r\n                node._setPropertyByIndex(j, glTFClipNode.propertise[j]);\r\n            }\r\n            let fullPath: string = nodePath + \".\" + node.propertyOwner + \".\" + node._joinProperty(\".\");\r\n            nodesDic[fullPath] = fullPath;\r\n            node.fullPath = fullPath;\r\n\r\n            node.callbackFunData = glTFClipNode.callbackFunc;\r\n            node.callParams = glTFClipNode.callbackParams;\r\n            node.propertyChangePath = glTFClipNode.propertyChangePath;\r\n\r\n            let keyframeCount: number = glTFClipNode.timeArray.length;\r\n\r\n            // laya animation version \"LAYAANIMATION:04\"\r\n            for (let j: number = 0; j < keyframeCount; j++) {\r\n                switch (type) {\r\n                    case 0:\r\n                        let floatKeyFrame = new FloatKeyframe();\r\n                        node._setKeyframeByIndex(j, floatKeyFrame);\r\n                        floatKeyFrame.time = glTFClipNode.timeArray[j];\r\n\r\n                        switch (glTFClipNode.interpolation) {\r\n                            case glTF.glTFAnimationSamplerInterpolation.CUBICSPLINE:\r\n                                {\r\n                                    floatKeyFrame.value = glTFClipNode.valueArray[3 * j + 1];\r\n                                    // todo\r\n                                    floatKeyFrame.inTangent = glTFClipNode.valueArray[3 * j + 0];\r\n                                    floatKeyFrame.outTangent = glTFClipNode.valueArray[3 * j + 2];\r\n                                }\r\n                                break;\r\n                            case glTF.glTFAnimationSamplerInterpolation.STEP:\r\n                                floatKeyFrame.value = glTFClipNode.valueArray[j];\r\n                                floatKeyFrame.inTangent = Infinity;\r\n                                floatKeyFrame.outTangent = Infinity;\r\n                                break;\r\n                            case glTF.glTFAnimationSamplerInterpolation.LINEAR:\r\n                            default:\r\n                                {\r\n                                    floatKeyFrame.value = glTFClipNode.valueArray[j];\r\n\r\n                                    let lastI = j == 0 ? j : j - 1;\r\n                                    let lastTime = glTFClipNode.timeArray[lastI];\r\n                                    let lastValue = glTFClipNode.valueArray[lastI];\r\n                                    let lastTimeDet = lastI == j ? 1 : (floatKeyFrame.time - lastTime);\r\n\r\n                                    floatKeyFrame.inTangent = (floatKeyFrame.value - lastValue) / lastTimeDet;\r\n\r\n                                    let nextI = j == keyframeCount - 1 ? j : j + 1;\r\n                                    let nextTime = glTFClipNode.timeArray[nextI];\r\n                                    let nextValue = glTFClipNode.valueArray[nextI];\r\n                                    let nextTimeDet = nextI == j ? 1 : (nextTime - floatKeyFrame.time);\r\n\r\n                                    floatKeyFrame.outTangent = (nextValue - floatKeyFrame.value) / nextTimeDet;\r\n\r\n                                    if (lastI == j) {\r\n                                        floatKeyFrame.inTangent = floatKeyFrame.outTangent;\r\n                                    }\r\n                                    if (nextI == j) {\r\n                                        floatKeyFrame.outTangent = floatKeyFrame.inTangent;\r\n                                    }\r\n                                }\r\n                                break;\r\n                        }\r\n\r\n                        break;\r\n                    case 1: // local position\r\n                    case 3: // local scale\r\n                    case 4: // local euler angler raw\r\n                        let floatArrayKeyframe: Vector3Keyframe = new Vector3Keyframe();\r\n                        node._setKeyframeByIndex(j, floatArrayKeyframe);\r\n                        let startTimev3: number = floatArrayKeyframe.time = glTFClipNode.timeArray[j];\r\n                        let inTangent: Vector3 = floatArrayKeyframe.inTangent;\r\n                        let outTangent: Vector3 = floatArrayKeyframe.outTangent;\r\n                        let value: Vector3 = floatArrayKeyframe.value;\r\n\r\n                        switch (glTFClipNode.interpolation) {\r\n                            case glTF.glTFAnimationSamplerInterpolation.CUBICSPLINE:\r\n                                value.setValue(glTFClipNode.valueArray[9 * j + 3], glTFClipNode.valueArray[9 * j + 4], glTFClipNode.valueArray[9 * j + 5]);\r\n                                inTangent.setValue(glTFClipNode.valueArray[9 * j + 0], glTFClipNode.valueArray[9 * j + 1], glTFClipNode.valueArray[9 * j + 2]);\r\n                                outTangent.setValue(glTFClipNode.valueArray[9 * j + 6], glTFClipNode.valueArray[9 * j + 7], glTFClipNode.valueArray[9 * j + 8]);\r\n                                break;\r\n                            case glTF.glTFAnimationSamplerInterpolation.STEP:\r\n                                value.setValue(glTFClipNode.valueArray[3 * j], glTFClipNode.valueArray[3 * j + 1], glTFClipNode.valueArray[3 * j + 2]);\r\n                                inTangent.setValue(Infinity, Infinity, Infinity);\r\n                                outTangent.setValue(Infinity, Infinity, Infinity);\r\n                                break;\r\n                            case glTF.glTFAnimationSamplerInterpolation.LINEAR:\r\n                            default:\r\n                                {\r\n                                    value.setValue(glTFClipNode.valueArray[3 * j], glTFClipNode.valueArray[3 * j + 1], glTFClipNode.valueArray[3 * j + 2]);\r\n\r\n                                    let lastI = j == 0 ? j : j - 1;\r\n                                    let lastTime = glTFClipNode.timeArray[lastI];\r\n                                    let lastX = glTFClipNode.valueArray[3 * lastI];\r\n                                    let lastY = glTFClipNode.valueArray[3 * lastI + 1];\r\n                                    let lastZ = glTFClipNode.valueArray[3 * lastI + 2];\r\n\r\n                                    let lastTimeDet = lastI == j ? 1 : startTimev3 - lastTime;\r\n                                    inTangent.x = (value.x - lastX) / lastTimeDet;\r\n                                    inTangent.y = (value.y - lastY) / lastTimeDet;\r\n                                    inTangent.z = (value.z - lastZ) / lastTimeDet;\r\n\r\n                                    let nextI = j == keyframeCount - 1 ? j : j + 1;\r\n                                    let nextTime = glTFClipNode.timeArray[nextI];\r\n                                    let nextX = glTFClipNode.valueArray[3 * nextI];\r\n                                    let nextY = glTFClipNode.valueArray[3 * nextI + 1];\r\n                                    let nextZ = glTFClipNode.valueArray[3 * nextI + 2];\r\n\r\n                                    let nestTimeDet = nextI == j ? 1 : nextTime - startTimev3;\r\n                                    outTangent.x = (nextX - value.x) / nestTimeDet;\r\n                                    outTangent.y = (nextY - value.y) / nestTimeDet;\r\n                                    outTangent.z = (nextZ - value.z) / nestTimeDet;\r\n\r\n                                    if (lastI == j) {\r\n                                        outTangent.cloneTo(inTangent);\r\n                                    }\r\n                                    if (nextI == j) {\r\n                                        inTangent.cloneTo(outTangent);\r\n                                    }\r\n                                }\r\n                                break;\r\n                        }\r\n                        break;\r\n                    case 2: // local rotation\r\n                        let quaternionKeyframe: QuaternionKeyframe = new QuaternionKeyframe();\r\n                        node._setKeyframeByIndex(j, quaternionKeyframe);\r\n                        let startTimeQu: number = quaternionKeyframe.time = glTFClipNode.timeArray[j];\r\n                        let inTangentQua: Vector4 = quaternionKeyframe.inTangent;\r\n                        let outTangentQua: Vector4 = quaternionKeyframe.outTangent;\r\n                        let valueQua: Quaternion = quaternionKeyframe.value;\r\n                        switch (glTFClipNode.interpolation) {\r\n                            case glTF.glTFAnimationSamplerInterpolation.CUBICSPLINE:\r\n                                valueQua.set(glTFClipNode.valueArray[12 * j + 4], glTFClipNode.valueArray[12 * j + 5], glTFClipNode.valueArray[12 * j + 6], glTFClipNode.valueArray[12 * j + 7]);\r\n                                inTangentQua.setValue(glTFClipNode.valueArray[12 * j + 0], glTFClipNode.valueArray[12 * j + 1], glTFClipNode.valueArray[12 * j + 2], glTFClipNode.valueArray[12 * j + 3]);\r\n                                outTangentQua.setValue(glTFClipNode.valueArray[12 * j + 8], glTFClipNode.valueArray[12 * j + 9], glTFClipNode.valueArray[12 * j + 10], glTFClipNode.valueArray[12 * j + 11]);\r\n                                break;\r\n                            case glTF.glTFAnimationSamplerInterpolation.STEP:\r\n                                valueQua.set(glTFClipNode.valueArray[4 * j + 0], glTFClipNode.valueArray[4 * j + 1], glTFClipNode.valueArray[4 * j + 2], glTFClipNode.valueArray[4 * j + 3]);\r\n                                inTangentQua.setValue(Infinity, Infinity, Infinity, Infinity);\r\n                                outTangentQua.setValue(Infinity, Infinity, Infinity, Infinity);\r\n                                break;\r\n\r\n                            case glTF.glTFAnimationSamplerInterpolation.LINEAR:\r\n                            default:\r\n                                {\r\n                                    valueQua.set(glTFClipNode.valueArray[4 * j + 0], glTFClipNode.valueArray[4 * j + 1], glTFClipNode.valueArray[4 * j + 2], glTFClipNode.valueArray[4 * j + 3]);\r\n\r\n                                    let lastI = j == 0 ? j : j - 1;\r\n                                    let lastTime = glTFClipNode.timeArray[lastI];\r\n                                    let lastX = glTFClipNode.valueArray[4 * lastI];\r\n                                    let lastY = glTFClipNode.valueArray[4 * lastI + 1];\r\n                                    let lastZ = glTFClipNode.valueArray[4 * lastI + 2];\r\n                                    let lastW = glTFClipNode.valueArray[4 * lastI + 3];\r\n\r\n                                    let lastTimeDet = lastI == j ? 1 : startTimeQu - lastTime;\r\n                                    inTangentQua.x = (valueQua.x - lastX) / lastTimeDet;\r\n                                    inTangentQua.y = (valueQua.y - lastY) / lastTimeDet;\r\n                                    inTangentQua.z = (valueQua.z - lastZ) / lastTimeDet;\r\n                                    inTangentQua.w = (valueQua.w - lastW) / lastTimeDet;\r\n\r\n                                    let nextI = j == keyframeCount - 1 ? j : j + 1;\r\n                                    let nextTime = glTFClipNode.timeArray[nextI];\r\n                                    let nextX = glTFClipNode.valueArray[4 * nextI];\r\n                                    let nextY = glTFClipNode.valueArray[4 * nextI + 1];\r\n                                    let nextZ = glTFClipNode.valueArray[4 * nextI + 2];\r\n                                    let nextW = glTFClipNode.valueArray[4 * nextI + 3];\r\n\r\n                                    if ((valueQua.x * nextX + valueQua.y * nextY + valueQua.z * nextZ + valueQua.w * nextW) < 0) {\r\n                                        nextX *= -1;\r\n                                        nextY *= -1;\r\n                                        nextZ *= -1;\r\n                                        nextW *= -1;\r\n                                        glTFClipNode.valueArray[4 * nextI] = nextX;\r\n                                        glTFClipNode.valueArray[4 * nextI + 1] = nextY;\r\n                                        glTFClipNode.valueArray[4 * nextI + 2] = nextZ;\r\n                                        glTFClipNode.valueArray[4 * nextI + 3] = nextW;\r\n                                    }\r\n\r\n                                    let nestTimeDet = nextI == j ? 1 : nextTime - startTimeQu;\r\n                                    outTangentQua.x = (nextX - valueQua.x) / nestTimeDet;\r\n                                    outTangentQua.y = (nextY - valueQua.y) / nestTimeDet;\r\n                                    outTangentQua.z = (nextZ - valueQua.z) / nestTimeDet;\r\n                                    outTangentQua.w = (nextW - valueQua.w) / nestTimeDet;\r\n\r\n                                    if (lastI == j) {\r\n                                        outTangentQua.cloneTo(inTangentQua);\r\n                                    }\r\n                                    if (nextI == j) {\r\n                                        inTangentQua.cloneTo(outTangentQua);\r\n                                    }\r\n\r\n                                }\r\n                                break;\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        clipNodes = null;\r\n\r\n        return clip;\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * 辅助记录 sub morph data 所需数据\r\n */\r\nclass SubMorphData {\r\n    weights: number[];\r\n    position: boolean;\r\n    boundMin: number[];\r\n    boundMax: number[];\r\n    normal: boolean;\r\n    tangent: boolean;\r\n    targets: { [name: string]: Map<string, Float32Array> }\r\n}\r\n\r\n/**\r\n * @internal\r\n * 辅助记录 submesh 所需数据\r\n */\r\nclass PrimitiveSubMesh {\r\n\r\n    attributeMap: Map<string, Float32Array>;\r\n    boundMin: number[];\r\n    boundMax: number[];\r\n    indices: Uint32Array;\r\n    vertexDecler: string;\r\n    vertexCount: number;\r\n    boneIndicesList: Uint16Array[];\r\n    subIndexStartArray: number[];\r\n    subIndexCountArray: number[];\r\n\r\n    morphtargets: SubMorphData;\r\n\r\n    constructor() {\r\n\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * 辅助记录 animator clip 所需数据\r\n */\r\ninterface ClipNode {\r\n    paths?: string[];\r\n    propertyOwner?: string;\r\n    propertyLength?: number;\r\n    propertise?: string[];\r\n    timeArray?: Float32Array;\r\n    valueArray?: Float32Array;\r\n    interpolation?: glTF.glTFAnimationSamplerInterpolation;\r\n    duration?: number;\r\n    type?: number;\r\n    callbackFunc?: string;\r\n    callbackParams?: any[];\r\n    propertyChangePath?: string;\r\n}\r\n\r\nLaya.onInitModule(() => {\r\n    glTFShader.init();\r\n});\r\n","import { IBatchProgress } from \"../../net/BatchProgress\";\r\nimport { Texture2D } from \"../../resource/Texture2D\";\r\nimport { glTFResource } from \"../glTFResource\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\n\r\nimport { Material } from \"../../d3/core/material/Material\";\r\nimport { PBRMaterial } from \"../../d3/core/material/PBRMaterial\";\r\nimport * as glTF from \"../glTFInterface\";\r\nimport { PBRShaderLib } from \"../../d3/shader/pbr/PBRShaderLib\";\r\nimport { glTFShader } from \"../shader/glTFShader\";\r\n\r\nconst ExtensionName = \"KHR_materials_anisotropy\";\r\n\r\ndeclare module \"../glTFInterface\" {\r\n\r\n    export interface glTFMaterialAnisotropy {\r\n        /** The anisotropy strength. When anisotropyTexture is present, this value is multiplied by the blue channel. default: 0.0 */\r\n        anisotropyStrength: number;\r\n        /** The rotation of the anisotropy in tangent, bitangent space, measured in radians counter-clockwise from the tangent. When anisotropyTexture is present, anisotropyRotation provides additional rotation to the vectors in the texture. default: 0.0 */\r\n        anisotropyRotation: number;\r\n        /** The anisotropy texture. Red and green channels represent the anisotropy direction in [-1, 1] tangent, bitangent space, to be rotated by anisotropyRotation. The blue channel contains strength as [0, 1] to be multiplied by anisotropyStrength. */\r\n        anisotropyTexture: glTFTextureInfo;\r\n    }\r\n\r\n}\r\n\r\nexport class KHR_materials_anisotropy implements glTFExtension {\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    loadTextures(basePath: string, progress?: IBatchProgress): Promise<any> {\r\n        let materials = this._resource.data.materials;\r\n        let textures = this._resource.data.textures;\r\n\r\n        if (materials && textures) {\r\n            let promises: Array<Promise<Texture2D>> = [];\r\n            materials.forEach(material => {\r\n                let extension: glTF.glTFMaterialAnisotropy = material.extensions?.KHR_materials_anisotropy;\r\n                if (extension) {\r\n                    if (extension.anisotropyTexture) {\r\n                        let index = extension.anisotropyTexture.index;\r\n                        let promise = this._resource.loadTextureFromglTF(index, false, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                }\r\n            });\r\n            return Promise.all(promises);\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n\r\n    additionMaterialProperties(glTFMaterial: glTF.glTFMaterial, material: Material): void {\r\n        let extension: glTF.glTFMaterialAnisotropy = glTFMaterial.extensions.KHR_materials_anisotropy;\r\n\r\n        let anisotropy = extension.anisotropyStrength ?? 0.0;\r\n        let rotation = extension.anisotropyRotation ?? 0.0;\r\n\r\n        material.setDefine(PBRShaderLib.DEFINE_ANISOTROPY, true);\r\n        material.setFloat(\"u_AnisotropyStrength\", anisotropy);\r\n        material.setFloat(\"u_AnisotropyRotation\", rotation);\r\n\r\n        if (extension.anisotropyTexture) {\r\n            let tex = this._resource.getTextureWithInfo(extension.anisotropyTexture);\r\n            material.setTexture(\"u_AnisotropyTexture\", tex);\r\n            material.setDefine(glTFShader.Define_AnisotropyMap, true);\r\n        }\r\n    }\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_anisotropy(resource));","import { Material } from \"../../d3/core/material/Material\";\r\nimport { PBRMaterial } from \"../../d3/core/material/PBRMaterial\";\r\nimport { PBRShaderLib } from \"../../d3/shader/pbr/PBRShaderLib\";\r\nimport { IBatchProgress } from \"../../net/BatchProgress\";\r\nimport { Texture2D } from \"../../resource/Texture2D\";\r\nimport * as glTF from \"../glTFInterface\";\r\n\r\nimport { glTFResource } from \"../glTFResource\";\r\nimport { glTFShader } from \"../shader/glTFShader\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\n\r\nconst ExtensionName = \"KHR_materials_clearcoat\";\r\n\r\ndeclare module \"../glTFInterface\" {\r\n\r\n    export interface glTFMaterialClearCoat {\r\n        /** The clearcoat layer intensity. default: 0.0*/\r\n        clearcoatFactor?: number;\r\n        /** The base color texture */\r\n        clearcoatTexture?: glTFTextureInfo;\r\n        /** The clearcoat layer roughness.  default: 0.0*/\r\n        clearcoatRoughnessFactor?: number;\r\n        /** The clearcoat layer roughness texture.*/\r\n        clearcoatRoughnessTexture?: glTFTextureInfo;\r\n        /** The clearcoat normal map texture. */\r\n        clearcoatNormalTexture?: glTFMaterialNormalTextureInfo;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @internal\r\n * https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat\r\n * \r\n * exclusions: KHR_materials_pbrSpecularGlossiness, KHR_materials_unlit\r\n */\r\nexport class KHR_materials_clearcoat implements glTFExtension {\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    loadTextures(basePath: string, progress?: IBatchProgress): Promise<any> {\r\n        let materials = this._resource.data.materials;\r\n        let textures = this._resource.data.textures;\r\n\r\n        if (materials && textures) {\r\n            let promises: Array<Promise<Texture2D>> = [];\r\n            materials.forEach(material => {\r\n                let extension: glTF.glTFMaterialClearCoat = material.extensions?.KHR_materials_clearcoat;\r\n                if (extension) {\r\n                    if (extension.clearcoatTexture) {\r\n                        let index = extension.clearcoatTexture.index\r\n                        let promise = this._resource.loadTextureFromglTF(index, false, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                    if (extension.clearcoatRoughnessTexture) {\r\n                        let index = extension.clearcoatRoughnessTexture.index;\r\n                        let promise = this._resource.loadTextureFromglTF(index, false, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                    if (extension.clearcoatNormalTexture) {\r\n                        let index = extension.clearcoatNormalTexture.index;\r\n                        let promise = this._resource.loadTextureFromglTF(index, false, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                }\r\n            });\r\n            return Promise.all(promises);\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n\r\n    additionMaterialProperties(glTFMaterial: glTF.glTFMaterial, material: Material): void {\r\n        let extension: glTF.glTFMaterialClearCoat = glTFMaterial.extensions.KHR_materials_clearcoat;\r\n        let clearCoat = extension.clearcoatFactor ?? 0.0;\r\n        let clearCoatRoughness = extension.clearcoatRoughnessFactor ?? 0.0;\r\n\r\n        material.setDefine(PBRShaderLib.DEFINE_CLEARCOAT, true);\r\n\r\n        material.setFloat(\"u_ClearCoatFactor\", clearCoat);\r\n        if (extension.clearcoatTexture) {\r\n            let tex = this._resource.getTextureWithInfo(extension.clearcoatTexture);\r\n            material.setTexture(\"u_ClearCoatTexture\", tex);\r\n            material.setDefine(glTFShader.Define_ClearCoatMap, true)\r\n        }\r\n\r\n        material.setFloat(\"u_ClearCoatRoughness\", clearCoatRoughness);\r\n        if (extension.clearcoatRoughnessTexture) {\r\n            let tex = this._resource.getTextureWithInfo(extension.clearcoatRoughnessTexture);\r\n            material.setTexture(\"u_ClearCoatRoughnessTexture\", tex);\r\n            material.setDefine(glTFShader.Define_ClearCoatRoughnessMap, true);\r\n        }\r\n\r\n        if (extension.clearcoatNormalTexture) {\r\n            let tex = this._resource.getTextureWithInfo(extension.clearcoatNormalTexture);\r\n            material.setTexture(\"u_ClearCoatNormalTexture\", tex);\r\n            material.setDefine(glTFShader.Define_ClearCoatNormalMap, true);\r\n            let scale = extension.clearcoatNormalTexture.scale ?? 1.0;\r\n            material.setFloat(\"u_ClearCoatNormalScale\", scale);\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_clearcoat(resource));","import { Material } from \"../../d3/core/material/Material\";\r\nimport { IBatchProgress } from \"../../net/BatchProgress\";\r\nimport { glTFMaterial } from \"../glTFInterface\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\n\r\nimport * as glTF from \"../glTFInterface\";\r\nimport { glTFResource } from \"../glTFResource\";\r\nimport { PBRStandardMaterial } from \"../../d3/core/material/PBRStandardMaterial\";\r\n\r\nconst ExtensionName = \"KHR_materials_emissive_strength\";\r\n\r\ndeclare module \"../glTFInterface\" {\r\n\r\n    export interface glTFMaterialEmissionStrength {\r\n        /** The strength adjustment to be multiplied with the material's emissive value. default: 1.0 */\r\n        emissiveStrength: number;\r\n    }\r\n\r\n}\r\n\r\nexport class KHR_materials_emissive_strength implements glTFExtension {\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    additionMaterialProperties?(glTFMaterial: glTFMaterial, material: Material): void {\r\n\r\n        let extension: glTF.glTFMaterialEmissionStrength = glTFMaterial.extensions.KHR_materials_emissive_strength;\r\n\r\n        let emissionStrength = extension.emissiveStrength ?? 1.0;\r\n\r\n        material.setFloat(\"u_EmissionStrength\", emissionStrength);\r\n    }\r\n\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_emissive_strength(resource));","import * as glTF from \"../glTFInterface\";\r\n\r\nimport { Material } from \"../../d3/core/material/Material\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\nimport { UnlitMaterial } from \"../../d3/core/material/UnlitMaterial\";\r\nimport { glTFResource } from \"../glTFResource\";\r\n\r\nconst ExtensionName = \"KHR_materials_unlit\";\r\n\r\n/**\r\n * @internal\r\n * https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/README.md\r\n */\r\nexport class KHR_materials_unlit implements glTFExtension {\r\n\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    createMaterial(glTFMaterial: glTF.glTFMaterial): Material {\r\n        let unlit = new UnlitMaterial();\r\n\r\n        let pbrMetallicRoughness = glTFMaterial.pbrMetallicRoughness;\r\n        if (pbrMetallicRoughness) {\r\n            if (pbrMetallicRoughness.baseColorFactor) {\r\n                let color = unlit.albedoColor;\r\n                color.fromArray(pbrMetallicRoughness.baseColorFactor);\r\n                color.toGamma(color);\r\n                unlit.albedoColor = color;\r\n            }\r\n\r\n            if (pbrMetallicRoughness.baseColorTexture) {\r\n                unlit.albedoTexture = this._resource.getTextureWithInfo(pbrMetallicRoughness.baseColorTexture);\r\n            }\r\n        }\r\n\r\n        this._resource.applyMaterialRenderState(glTFMaterial, unlit);\r\n\r\n        return unlit;\r\n    }\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_unlit(resource));\r\n","import { ILoadTask, IResourceLoader, Loader } from \"../net/Loader\";\r\nimport * as glTF from \"./glTFInterface\";\r\nimport { glTFResource } from \"./glTFResource\";\r\n\r\nimport \"./extensions/KHR_materials_anisotropy\";\r\nimport \"./extensions/KHR_materials_clearcoat\";\r\nimport \"./extensions/KHR_materials_emissive_strength\";\r\nimport \"./extensions/KHR_materials_unlit\";\r\n\r\nclass glTFLoader implements IResourceLoader {\r\n    load(task: ILoadTask) {\r\n        return task.loader.fetch(task.url, \"json\", task.progress.createCallback(0.5), task.options).then((data: glTF.glTF) => {\r\n            let glTF = new glTFResource();\r\n            return glTF._parse(data, task.url, task.progress).then(() => glTF);\r\n        });\r\n    }\r\n}\r\n\r\nLoader.registerLoader([\"gltf\"], glTFLoader);\r\n\r\nclass glbLoader implements IResourceLoader {\r\n    load(task: ILoadTask): Promise<any> {\r\n        return task.loader.fetch(task.url, \"arraybuffer\", task.progress.createCallback(0.5), task.options).then((data: ArrayBuffer) => {\r\n            let glTF = new glTFResource();\r\n            return glTF._parseglb(data, task.url, task.progress).then(() => glTF);\r\n        });\r\n    }\r\n}\r\n\r\nLoader.registerLoader([\"glb\"], glbLoader);\r\n"],"names":["Shader3D","ShaderDataType","Vector4","Vector3","SubShader","Prefab","Base64Tool","ILaya","URL","Byte","Loader","HDREncodeFormat","MaterialRenderMode","RenderState","PBRShaderLib","Material","PBRStandardMaterial","Sprite3D","SkinnedMeshSprite3D","MeshSprite3D","VertexMesh","IndexFormat","LayaGL","BufferUsage","SubMesh","Matrix4x4","skinnedMatrixCache","MorphTargetData","MorphTargetChannel","MorphTarget","Mesh","Animator","AnimatorControllerLayer","AnimatorState","AnimationClip","MeshFilter","SkinnedMeshRenderer","KeyframeNode","FloatKeyframe","Vector3Keyframe","QuaternionKeyframe","Laya","ExtensionName","UnlitMaterial"],"mappings":"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"}